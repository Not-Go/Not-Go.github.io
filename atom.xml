<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>建波的学习妙妙屋</title>
  
  
  <link href="https://not-go.github.io/atom.xml" rel="self"/>
  
  <link href="https://not-go.github.io/"/>
  <updated>2023-07-05T06:07:37.535Z</updated>
  <id>https://not-go.github.io/</id>
  
  <author>
    <name>牟建波</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://not-go.github.io/2023/07/05/hello-world/"/>
    <id>https://not-go.github.io/2023/07/05/hello-world/</id>
    <published>2023-07-05T06:07:37.535Z</published>
    <updated>2023-07-05T06:07:37.535Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>专业核心基础理论：计算机组成原理</title>
    <link href="https://not-go.github.io/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/"/>
    <id>https://not-go.github.io/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/</id>
    <published>2023-04-20T04:19:00.000Z</published>
    <updated>2023-06-30T11:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="专业核心基础理论：计算机组成原理"><a href="#专业核心基础理论：计算机组成原理" class="headerlink" title="专业核心基础理论：计算机组成原理"></a>专业核心基础理论：计算机组成原理</h1><h2 id="第一章：计算机系统概述"><a href="#第一章：计算机系统概述" class="headerlink" title="第一章：计算机系统概述"></a>第一章：计算机系统概述</h2><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630144745843.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630144745843.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630144745843"><hr><h3 id="第一节：计算机发展历程"><a href="#第一节：计算机发展历程" class="headerlink" title="第一节：计算机发展历程"></a>第一节：计算机发展历程</h3><h4 id="计算机硬件的发展"><a href="#计算机硬件的发展" class="headerlink" title="计算机硬件的发展"></a>计算机硬件的发展</h4><p><strong><mark>计算机系统&#x3D;硬件+软件</mark></strong></p><p><strong>计算机硬件的发展：</strong></p><ul><li><strong>第一代计算机：(使用电子管)</strong></li><li><strong>第二代计算机：(使用晶体管)</strong></li><li><strong>第三代计算机：(使用较小规模的集成)</strong></li><li><strong>第四代计算机：(使用较大规模的集成)</strong></li></ul><p><strong>已经经历了4代，计算机的速度越来越快，并且体积变得越来越小</strong></p><p><strong>发展趋势：更微型、多用途；更巨型、超高速</strong></p><blockquote><p><strong>晶体管之父：肖克利（1956年诺贝尔物理学奖得主）</strong></p><p><strong>1957年，”八叛徒”创立了仙童半导体</strong><br><strong>1959年，仙童半导体发明了“集成电路”</strong><br><strong>1968年，摩尔离开仙童，创立intel</strong><br><strong>1969年，仙童销售部负责人桑德斯离开仙童，创立AMD</strong></p></blockquote><p><strong>摩尔定律，集成电路上的晶体管数量每18月就会翻一翻，所以每18月计算机的处理效率就会提高一倍</strong></p><hr><h4 id="计算机软件的发展"><a href="#计算机软件的发展" class="headerlink" title="计算机软件的发展"></a>计算机软件的发展</h4><p><strong>计算机软件技术的发展，促进计算机系统的发展。</strong></p><p><strong>计算机语言的发展经历了面向机器的机器语言和汇编语言、面向问题的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的 FORTRAN、结构化程序设计的 PASCAL到面向对象的C++和适应网络环境的Java。</strong></p><p><strong>同时，直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如 Windows、UNIX、 Linux等。</strong></p><hr><h4 id="计算机的分类与发展方向"><a href="#计算机的分类与发展方向" class="headerlink" title="计算机的分类与发展方向"></a>计算机的分类与发展方向</h4><p><strong>可以分为：</strong></p><ul><li><strong>电子模拟计算机和电子数字计算机。</strong></li></ul><p><strong>数字计算机又可以按照用途分为：</strong></p><ul><li><p><strong>专用计算机和通用计算机</strong></p></li><li><p><strong>通用计算机又分为：巨型机、大型机、中型机、小型机、微型机和单片机6类。</strong></p></li></ul><p><strong>按照指令和数据流可以分为：</strong></p><ul><li><strong><code>单指令流和单数据流系统（SISD）</code>，即传统的冯·诺依曼体系结构</strong></li><li><strong><code>单指令流和多数据流系统（SIMD）</code>，包括阵列处理器和向量处理器系统</strong></li><li><strong><code>多指令流和单数据流系统（MISD）</code>，这种计算机实际上不存在</strong></li><li><strong><code>多指令流和多数据流系统（MIMD）</code>，包括多处理器和计算机系统</strong></li></ul><hr><h3 id="第二节：计算机系统层次结构"><a href="#第二节：计算机系统层次结构" class="headerlink" title="第二节：计算机系统层次结构"></a>第二节：计算机系统层次结构</h3><h4 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h4><p><strong>计算机系统由硬件系统和软件系统共同构建起来</strong></p><hr><h4 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h4><p><strong>1.早期的冯·诺依曼机</strong></p><blockquote><p><strong>美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。</strong></p><p><strong><font color=blue>什么是存储程序原理？按此原理，计算机应具有哪几大功能？</font></strong></p><p><strong><code>“程序存储”</code>：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。<code>即按地址访问并顺序执行指令</code></strong></p><p><strong>计算机按照此原理应具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能</strong></p></blockquote><ul><li><strong><font color=red>冯诺曼体系结构特点:</font></strong></li></ul><ol><li><strong>计算机硬件系统由五大部件组成(存储器、运算器、控制器、输出设备、输入设备)</strong></li><li><strong>指令和数据以<code>同等地位</code>存于存储器，可按地址寻访</strong></li><li><strong>指令和数据用二进制表示</strong></li><li><strong>指令由操作码和地址码组成</strong></li><li><strong>存储程序</strong></li><li><strong>以运算器为中心</strong></li></ol><blockquote><p><strong>早期的冯·诺依曼机以运算器为中心，且是单处理机，最根本的特征是采用“存储程序”原理，基本工作方式是控制流驱动方式！</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630145843483.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630145843483.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630145843483"><p><strong>2.现代计算机的组织结构</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630145911885.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630145911885.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630145911885"><p><strong>3.计算机的功能部件</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630145925917.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630145925917.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630145925917"><p><strong>五大部分：</strong></p><ul><li><p><strong>&lt;1&gt; 输入设备，是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等</strong></p></li><li><p><strong>&lt;2&gt; 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机。</strong></p></li><li><p><strong>&lt;3&gt; 存储器，存储器分为 <code>主存储器</code>(内存储器，<code>CPU能直接访问</code>)和 <code>辅助存储器</code>(外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)。</strong></p></li></ul><p><strong>主存储器的工作方式是<code>按存储单元的地址进行存取</code>，这种存取方式称为<code>按地址存取方式</code>(<mark>相联存储器</mark>既可以既可以按照<mark>地址寻址，又可以按照内容寻址</mark>，为了与传统存储器区别，又称为内容寻址的存储器！)</strong></p><p><strong>主存储器是由地址寄存器(MAR)，数据寄存器(MDR)，存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU，MAR和MDR是在CPU中的。</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150050662.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150050662.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150050662"><ul><li><strong>&lt;4&gt; 运算器，是计算机的运算单元，用于算术运算和逻辑运算。运算器的核心单元是算术逻辑单元(ALU)</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150121687.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150121687.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150121687"><ul><li><strong>&lt;5&gt; 控制器，控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成为中央处理器，简称CPU。有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150141485.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150141485.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150141485"><p><strong>一般将<code>运算器和控制器</code>集成到同一个芯片上，称为<code>中央处理器(CPU)</code>。<code>CPU和主存储器</code>共同构成<code>主机</code>，而除主机外的其他硬件装置(外存、I&#x2F;O设备等)统称为外部设备，简称外设。</strong></p><p><strong>图1.4所示为冯・诺依曼结构的模型机。CPU包含ALU、通用寄存器组GPRs、标志寄存器、控制器、指令寄存器IR、程序计数器PC、存储器地址寄存器MAR和存储器数据寄存器MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改PC以得到下一条指令的地址，可以控制ALU执行什么运算，可以控制主存是进行读操作还是写操作(读&#x2F;写控制信号)。</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150227231.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150227231.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150227231"><p><strong>CPU和主存之间通过<code>一组总线</code>相连，总线中有<code>地址、控制和数据3组信号线</code>。MAR中的地址信息会直接送到地址线上，用于指向读&#x2F;写操作的主存存储单元；控制线中有读&#x2F;写信号线，指出数据是从CPU写入主存还是从主存读出到CPU,根据是读操作还是写操作来控制将MDR中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。</strong></p><hr><h4 id="计算机软件的分类"><a href="#计算机软件的分类" class="headerlink" title="计算机软件的分类"></a>计算机软件的分类</h4><p><strong>1.系统软件和应用软件</strong></p><p><strong>计算机软件，一般分为系统软件和应用软件</strong></p><ul><li><strong>系统软件包括 操作系统，数据库管理系统，语言处理系统(比如编译器)，分布式软件系统，网络软件系统，标准库系统，服务性系统(比如连接程序)。</strong></li><li><strong>应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序。</strong></li></ul><p><strong>注意：数据库管理系统和数据库系统是有区别的。数据库管理系统是系统软件。而数据库系统一般是由数据库，数据库管理系统，数据库管理员和应用系统构成。所以只能说它里面有系统软件，但并不能说它为系统软件。</strong></p><p><strong>2.三个级别的语言</strong></p><ul><li><strong>1)<code>机器语言</code>。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。<code>机器语言是计算机唯一可以直接识别和执行的语言</code>。</strong></li><li><strong>2)<code>汇编语言</code>。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</strong></li><li><strong>3)<code>高级语言</code>。高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</strong></li></ul><p><strong>由高级语言转换到汇编语言的过程叫做<code>编译</code>，由汇编语言转换到机器语言的过程叫做<code>汇编</code>，边翻译边执行的叫做<code>解析</code>。</strong></p><p><strong>机器语言是唯一可以控制cpu的语言，因为它的符号不利于人识别和书写，为了方便理解和记忆，将机器语言换一些通俗易懂的符号，这就变成了汇编语言。一般来说在在编译器中高级语言先转换为汇编在转换为机器语言，也有直接转换为机器语言的情况。</strong></p><blockquote><p><strong><code>机器语言是计算机唯一可以直接执行的语言</code>，汇编语言用助记符编写，以便记忆。而正则语言是编译原理中符合正则文法的语言。</strong></p><p><strong>解释程序的特点是翻译一句执行一句，边翻译边执行：由高级语言转化为汇编语言的过程称为<code>编译</code>，把汇编语言源程序翻译成机器语言程序的过程称为<code>汇编</code>。</strong></p></blockquote><hr><h4 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150539596.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150539596.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150539596"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150548774.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150548774.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150548774"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150626426.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150626426.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150626426"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150636882.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150636882.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150636882"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150701114.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150701114.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150701114"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150708137.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150708137.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150708137"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150717728.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150717728.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150717728"><blockquote><p><strong><code>IR</code>存放当下欲执行的指令；<code>PC</code>存放下一条指令的地址；</strong></p><p><strong><code>MAR</code>存放欲访问的存储单元地址；<code>MDR</code>存放从存储单元取来的数据！</strong></p><p><strong><code>地址译码器</code>是主存的构成部分，不属于CPU；地址寄存器虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器！</strong></p><p><strong>关于CPU存取速度的比较：寄存器（CPU内部）&gt; Cache(高速的SRAM) &gt; 内存 （SDRAM）</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150814551.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150814551.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150814551"><p><strong>上图是计算机的工作流程，首先PC将指令地址发送给MAR，MAR根据地址在存储体中找到指令数据存放在MDR中，之后MDR将指令存放在IR中，取指令结束，之后指令中的操作码进入CU中，地址码重复上述取指令步骤，将数据发送到ACC中，执行指令结束。注意区分指令和数据的依据:指令周期的不同阶段</strong></p><hr><h3 id="第三节：计算机性能指标"><a href="#第三节：计算机性能指标" class="headerlink" title="第三节：计算机性能指标"></a>第三节：计算机性能指标</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150901667.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630150901667.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630150901667"><p><strong>1.<code>机器字长</code>：<code>计算机的位数</code>（机器字长），表示计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数。计算机字长通常选定为字节(8位)的整数倍，通常是2,4,8倍。不同的计算机，字节可能不同</strong></p><blockquote><p><strong><code>机器字长、指令字长、存储字长的区别和联系是什么？</code></strong></p><ul><li><p><strong>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。</strong></p></li><li><p><strong>指令字长：一个指令字中包含的二进制代码的位数。</strong></p></li><li><p><strong><code>存储字长</code>：一个存储单元存储的二进制代码的长度。<code>等于MDR的位数</code>， 它们都必须是字节的整数倍。</strong></p></li><li><p><strong><code>数据字长：数据总线一次能传送信息的位数</code>，它可以不等于MDR的位数。</strong></p></li></ul><p><strong>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</strong></p><p><strong>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</strong></p><p><strong>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</strong></p></blockquote><p><strong>2.数据通路带宽：数据总线一次所能传送信息的位数。</strong></p><p><strong>3.主存容量：MAR的位数反映存储单元的个数，如MAR为16位，表示存储单元为216 &#x3D; 64K;若MDR为32位，则存储容量为216x32.</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151117704.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151117704.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630151117704"><p><strong>4.运算速度</strong></p><blockquote><p><strong><code>吞吐量</code>，指系统在单位时间内处理请求的数量 ；从用户观点看，它是<code>评价计算机系统性能的综合参数！</code></strong></p><p><strong>响应时间，指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间。</strong></p></blockquote><blockquote><p><strong><code>CPU时钟周期</code>。通常为节拍脉冲或T周期，即主频的倒数，它是<code>CPU中最小的时间单位</code>，每个动作至少需要1个时钟周期。</strong></p><p><strong>主频(CPU时钟频率)。机器内部主时钟的频率，是衡量机器速度的重要参数。</strong></p><ul><li><strong>CPU周期又称为机器周期，由多个时钟周期组成！</strong></li><li><strong>指令周期&gt;CPU周期&gt;时钟周期</strong></li></ul></blockquote><blockquote><p><strong><code>CPI（Clock cycle Per Instruction），即执行一条指令所需的时钟周期数。</code></strong></p></blockquote><blockquote><p><strong>CPU执行时间，指运行一个程序所花费的时间。</strong><br><strong>CPU执行时间 &#x3D; CPU时钟周期数&#x2F;主频 &#x3D; (指令条数xCPI)&#x2F;主频</strong><br><strong>CPU的性能取决于三个要素:主频、CPI 、指令条数</strong></p></blockquote><blockquote><p><strong><code>IPS</code>(Instructions Per Second) &#x3D;<code>主频/平均CPI</code>，每秒执行多少指令</strong></p><p><strong><code>MIPS</code>(Million Instructions Per Second)&#x3D;即每秒执行多少百万条指令。</strong></p><p><strong><code>MFLOPS</code>(Mega Floating-point Operations Per Second)&#x3D;<code>浮点操作次数/(执行时间x106),</code>即每秒执行多少百万次浮点运算。</strong></p><p><strong><code>GFLOPS</code>(Giga Floating-point Operations Per Second)&#x3D;<code>浮点操作次数/(执行时间x109)</code>，即每秒执行多少十亿次浮点运算。</strong></p><p><strong><code>TFLOPS</code>(Tera Floating-point Operations Per Second)&#x3D;<code>浮点操作次数/(执行时间x1012)</code>，即每秒执行多少万亿次浮点运算。</strong></p></blockquote><hr><h2 id="第二章：数据的表示与运算"><a href="#第二章：数据的表示与运算" class="headerlink" title="第二章：数据的表示与运算"></a>第二章：数据的表示与运算</h2><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151352937.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151352937.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630151352937"><hr><h3 id="第一节：数制与编码"><a href="#第一节：数制与编码" class="headerlink" title="第一节：数制与编码"></a>第一节：数制与编码</h3><h4 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151504866.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151504866.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630151504866"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151512419.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151512419.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630151512419"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151519856.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151519856.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630151519856"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151547980.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151547980.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630151547980"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151612195.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630151612195.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630151612195"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152024650.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152024650.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152024650"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152037758.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152037758.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152037758"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152045052.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152045052.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152045052"><hr><h4 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152253254.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152253254.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152253254"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152158561.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152158561.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152158561"><p><strong>注意：这是为了表示0和9，所以1010~1111都是违法的，以前都没在意！</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152226918.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152226918.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152226918"><hr><h4 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152556243.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152556243.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152556243"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152337837.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152337837.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152337837"><p><strong>1.字符编码ASCII码</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152407676.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152407676.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152407676"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152420545.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152420545.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152420545"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152445497.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152445497.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152445497"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152512752.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152512752.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152512752"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152523556.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152523556.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152523556"><hr><h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152714897.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152714897.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152714897"><blockquote><p><strong>任意两个码字之间最少变化的二进制位数称为<code>码距</code>，码距大于等于2的数据校验码开始具有检错的能力。<code>码距越大，检错、纠错能力越强</code>。奇偶校验码的码距等于2,可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能检测出偶数位错误；海明码的码距大于2,因此不仅可以发现错误，还能指出错误的位置。<code>仅靠增加奇偶校验位的位数不能提高正确性，还要考虑码距</code>。</strong></p><p><strong>具有检、纠错能力的数据校验码的实现原理：在编码中，除合法码字外，再加入一些非法码字，当某个合法码字出现错误时，就变为非法码字。合理安排非法码字的数量和编码规则就能达到纠错的目的。</strong></p></blockquote><p><strong>1.奇偶校验码(PC)</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152858090.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152858090.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152858090"><p><strong><mark>原编码上加一个校验位，码距等于2！</mark></strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152835626.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152835626.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152835626"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152848283.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152848283.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152848283"><p><strong>2.海明校验码(HC)</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153034981.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153034981.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153034981"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152941603.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152941603.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152941603"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152949581.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152949581.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152949581"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152957898.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630152957898.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630152957898"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153005759.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153005759.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153005759"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153012880.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153012880.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153012880"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153023991.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153023991.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153023991"><p><strong>3.循环冗余校验码(CRC)</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153522090.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153522090.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153522090"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153339852.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153339852.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153339852"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153347007.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153347007.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153347007"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153400480.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153400480.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153400480"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153411512.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153411512.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153411512"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153420630.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153420630.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153420630"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153429085.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153429085.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153429085"><blockquote><p><strong><font color=red>CRC校验码是可以纠错的，前面这个是因为信息位太长</font></strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153503749.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630153503749.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630153503749"><hr><h3 id="第二节：定点数的表示和运算-章节缺失，王道视频去补充"><a href="#第二节：定点数的表示和运算-章节缺失，王道视频去补充" class="headerlink" title="第二节：定点数的表示和运算(章节缺失，王道视频去补充)"></a>第二节：定点数的表示和运算(章节缺失，王道视频去补充)</h3><hr><h2 id="第三章：存储系统"><a href="#第三章：存储系统" class="headerlink" title="第三章：存储系统"></a>第三章：存储系统</h2><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/20210118103433182.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/20210118103433182.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20210118103433182"><hr><h3 id="第一节：存储器概述"><a href="#第一节：存储器概述" class="headerlink" title="第一节：存储器概述"></a>第一节：存储器概述</h3><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174240361.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174240361.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174240361"><blockquote><p><strong><code>相联存储器</code>的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以它是<code>按内容或地址进行寻址</code>的，价格较为昂贵。<code> 一般用来制作TLB、相联 Cache等</code>。</strong></p></blockquote><p><strong>按在计算机中的作用对存储器分类：</strong></p><ul><li><p><strong>1&gt; <code>主存储器,简称主存</code>。CPU可以直接随机地对其进行访问，也可以和高速缓存器及辅助存储器交换数据。</strong></p></li><li><p><strong>2&gt; <code>辅助存储器,简称辅存</code>，不能与CPU直接相连，用来存放当前暂时不用的程序和数据</strong></p></li><li><p><strong>3&gt; <code>高速缓冲存储器</code>,位于主存和CPU之间，用来存放正在执行的程序段和数据</strong></p></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174227556.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174227556.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174227556"><p><strong>按存储介质分类：</strong></p><ul><li><strong>磁表面存储器（磁盘，磁带），磁心存储器半导体存储器（MOS型存储器，双极存储器）和光存储器（光盘）。</strong></li></ul><p><strong>按存取方式分类：</strong></p><ul><li><p><strong>1&gt; <code>随机存储器（RAM）</code>。存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存取单元的物理位置无关，主要用作主存或高速缓冲存储器。</strong></p></li><li><p><strong>2&gt; <code>只读存储器（ROM）</code>。存储器的内容只能随机读出而不能写入。。即使断电，内容也不会丢失。</strong></p></li><li><p><strong>3&gt; <code>串行访问存储器</code>。对存储单元进行读&#x2F;写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘）。</strong></p></li></ul><p><strong>按信息的可保存性分类：</strong></p><ul><li><strong>断电后，存储信息即消失的存储器，称为易失性存储器，如RAM。断电后信息仍然保持的存储器，称为非易失性存储器，如ROM，磁表面存储器和光存储器。若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出；若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</strong></li></ul><hr><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><p><strong>存储器的性能指标，有3个主要的性能指标，存储容量，单位成本和存储速度</strong></p><ul><li><strong>1&gt; 存储容量：存储字数*字长</strong></li><li><strong>2&gt; 单位成本：每位价格&#x3D;总成本&#x2F;总容量</strong></li><li><strong>3&gt; 存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期</strong></li></ul><p><strong>存取时间：存取时间时指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</strong></p><p><strong>存取周期：它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。</strong></p><p><strong>主存带宽：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字&#x2F;秒，字节&#x2F;秒</strong></p><p><strong>存取时间不等于存储周期，通常存储周期大于存取时间。因为任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174444055.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174444055.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174444055"><hr><h3 id="第二节：存储器的层次结构"><a href="#第二节：存储器的层次结构" class="headerlink" title="第二节：存储器的层次结构"></a>第二节：存储器的层次结构</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174524996.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174524996.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174524996"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174515262.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174515262.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174515262"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174536815.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174536815.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174536815"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174545595.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174545595.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174545595"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174554857.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174554857.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174554857"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174602835.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174602835.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174602835"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174611292.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630174611292.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630174611292"><hr><h3 id="第三节：半导体随机存储器"><a href="#第三节：半导体随机存储器" class="headerlink" title="第三节：半导体随机存储器"></a>第三节：半导体随机存储器</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175642769.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175642769.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175642769"><hr><h4 id="SRAM和DRAM"><a href="#SRAM和DRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175522789.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175522789.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175522789"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175421384.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175421384.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175421384"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175428672.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175428672.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175428672"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175441427.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175441427.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175441427"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175450967.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175450967.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175450967"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175501522.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175501522.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175501522"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175510772.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175510772.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175510772"><hr><h4 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175620933.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175620933.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175620933"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175628013.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630175628013.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630175628013"><hr><h4 id="主存的基本组成-章节缺失，王道视频补充"><a href="#主存的基本组成-章节缺失，王道视频补充" class="headerlink" title="主存的基本组成(章节缺失，王道视频补充)"></a>主存的基本组成(章节缺失，王道视频补充)</h4><hr><h3 id="第四节：主存储器与CPU的连接"><a href="#第四节：主存储器与CPU的连接" class="headerlink" title="第四节：主存储器与CPU的连接"></a>第四节：主存储器与CPU的连接</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180439046.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180439046.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180439046"><hr><h4 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h4><p><strong>1.位扩展</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180233101.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180233101.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180233101"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180240336.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180240336.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180240336"><p><strong>2.字扩展</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180354231.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180354231.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180354231"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180259692.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180259692.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180259692"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180306969.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180306969.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180306969"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180318662.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180318662.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180318662"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180324998.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180324998.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180324998"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180331167.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180331167.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180331167"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180340702.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180340702.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180340702"><p><strong>3.字位同时扩展法</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180426384.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180426384.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180426384"><hr><h4 id="主存与CPU的连接例题"><a href="#主存与CPU的连接例题" class="headerlink" title="主存与CPU的连接例题"></a>主存与CPU的连接例题</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180645440.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180645440.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180645440"><blockquote><p><strong>设CPU有16根地址线，8根数据线，并用MREQ作为访存控制信号（低电平有效），用WR作为读&#x2F;写控制信号（高电平为读，低电平为写）。现有下列存储芯片：1K×4位RAM，4K×8位RAM，8K×8位RAM，2K×8位ROM，4K×8位ROM，8K×8位ROM及74LS138译码器和各种门电路。画出CPU与存储器的连接图，要求：</strong><br><strong>1）主存地址空间分配：6000H～67FFH为系统程序区；6800H～6BFFH为用户程序区。</strong><br><strong>2）合理选用上述存储芯片，说明各选几片？</strong><br><strong>3）详细画出存储芯片的片选逻辑图。</strong><br><strong>补充：系统程序区用ROM，用户程序区用RAM</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180618048.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180618048.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180618048"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180627315.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180627315.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180627315"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180633352.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180633352.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180633352"><hr><h3 id="第五节：双端口RAM和多模块存储器"><a href="#第五节：双端口RAM和多模块存储器" class="headerlink" title="第五节：双端口RAM和多模块存储器"></a>第五节：双端口RAM和多模块存储器</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180838022.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180838022.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180838022"><hr><h4 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180733186.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180733186.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180733186"><hr><h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180751041.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180751041.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180751041"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180759267.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180759267.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180759267"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180808876.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180808876.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180808876"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180818439.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180818439.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180818439"><blockquote><p><strong>交叉存储器实际上是一种模块式的存储器，它能并行执行多个独立的读&#x2F;写操作。</strong></p></blockquote><hr><h3 id="第六节：高速缓冲存储器"><a href="#第六节：高速缓冲存储器" class="headerlink" title="第六节：高速缓冲存储器"></a>第六节：高速缓冲存储器</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180909445.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180909445.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180909445"><hr><h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181027280.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181027280.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181027280"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180952170.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180952170.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180952170"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180959503.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630180959503.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630180959503"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181007639.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181007639.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181007639"><hr><h4 id="Cache的基本工作原理"><a href="#Cache的基本工作原理" class="headerlink" title="Cache的基本工作原理"></a>Cache的基本工作原理</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181134383.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181134383.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181134383"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181055558.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181055558.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181055558"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181105703.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181105703.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181105703"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181112172.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181112172.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181112172"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181118549.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181118549.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181118549"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181125443.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181125443.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181125443"><hr><h4 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181431479.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181431479.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181431479"><blockquote><p><strong><code>随机算法(RAND)</code>:随机地确定替换的 Cache块。它的实现比较简单，但没有依据程序访问的局部性原理，故可能命中率较低</strong></p><p><strong><code>先进先出算法(FIFO)</code>:选择最早调入的行进行替换。它比较容易实现，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入 Cache的块替换掉。</strong></p><p><strong><code>近期最少使用算法（LRU)</code>:依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，平均命中率要比FFO要高，是堆栈类算法。</strong></p><p><strong>LRU算法对每行设置一个计数器， Cache每命中一次，命中行计数器清0,而其他各行计数器均加1,需要替换时比较各特定行的计数值，将计数值最大的行换出。</strong></p><p><strong><code>最不经常使用算法(LFU)</code>:将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1,需要替换时比较各特定行的计数值，将计数值最小的行换出。</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181307942.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181307942.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181307942"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181317339.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181317339.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181317339"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181324986.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181324986.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181324986"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181331392.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181331392.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181331392"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181337271.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181337271.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181337271"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181345426.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181345426.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181345426"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181356032.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181356032.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181356032"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181402651.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181402651.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181402651"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181408976.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181408976.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181408976"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181416906.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181416906.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181416906"><hr><h3 id="第七节：虚拟存储器"><a href="#第七节：虚拟存储器" class="headerlink" title="第七节：虚拟存储器"></a>第七节：虚拟存储器</h3><h4 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181620308.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181620308.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181620308"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181627410.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181627410.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181627410"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181633367.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181633367.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181633367"><hr><h4 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h4><blockquote><p><strong>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位。每个程序对应一个段表，每段对应一个页表。</strong></p><p><strong><mark>虚拟地址：段号+段内页号+页内地址</mark></strong></p></blockquote><hr><h4 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h4><blockquote><p><strong>页表、段表存放在主存中，收到虚拟地址后要先访问主存，査询页表、段表，进行虚实地址转换。</strong></p><p><strong>放在主存中的页表称为慢表(Page)</strong></p><p><strong>提高变换速度→用高速绥沖存储器存放常用的页表项 → 快表(TLB)</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181839825.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181839825.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181839825"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181846665.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630181846665.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630181846665"><hr><h2 id="第四章：指令系统"><a href="#第四章：指令系统" class="headerlink" title="第四章：指令系统"></a>第四章：指令系统</h2><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182003166.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182003166.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182003166"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183745051.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183745051.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183745051"><hr><h3 id="第一节：指令格式"><a href="#第一节：指令格式" class="headerlink" title="第一节：指令格式"></a>第一节：指令格式</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182102174.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182102174.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182102174"><hr><h4 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182243909.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182243909.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182243909"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182117558.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182117558.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182117558"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182126243.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182126243.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182126243"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182132647.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182132647.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182132647"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182139634.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182139634.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182139634"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182147835.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182147835.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182147835"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182155931.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182155931.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182155931"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182201926.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182201926.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182201926"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182212492.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182212492.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182212492"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182223119.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182223119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182223119"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182229610.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182229610.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182229610"><hr><h3 id="第二节：指令寻址方式"><a href="#第二节：指令寻址方式" class="headerlink" title="第二节：指令寻址方式"></a>第二节：指令寻址方式</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182712821.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182712821.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182712821"><hr><h4 id="指令的数据存放"><a href="#指令的数据存放" class="headerlink" title="指令的数据存放"></a>指令的数据存放</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182626574.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182626574.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182626574"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182637339.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182637339.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182637339"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182645554.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182645554.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182645554"><hr><h4 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182658318.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182658318.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182658318"><hr><h4 id="数据的寻址方式"><a href="#数据的寻址方式" class="headerlink" title="数据的寻址方式"></a>数据的寻址方式</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183556968.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183556968.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183556968"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182939262.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182939262.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182939262"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182945689.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182945689.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182945689"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182952443.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182952443.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182952443"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182958099.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630182958099.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630182958099"><blockquote><p><strong>1.隐含寻址</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183036684.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183036684.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183036684"><p><strong>2.立即寻址</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183103290.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183103290.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183103290"><p><strong>3.直接寻址</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183112961.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183112961.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183112961"><p><strong>4.间接寻址</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183218179.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183218179.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183218179"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183151833.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183151833.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183151833"><p><strong>5.寄存器寻址</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183243538.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183243538.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183243538"><p><strong>6.寄存器间接寻址</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183309545.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183309545.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183309545"></blockquote><p><strong>偏移寻址</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183456607.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183456607.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183456607"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183503598.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183503598.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183503598"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183509651.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183509651.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183509651"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183515635.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183515635.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183515635"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183521942.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183521942.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183521942"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183530265.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183530265.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183530265"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183536218.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183536218.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183536218"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183544150.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183544150.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183544150"><p><strong>堆栈寻址</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183638026.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183638026.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183638026"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183644263.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183644263.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183644263"><hr><h3 id="第三节：CISC和RISC的基本概念"><a href="#第三节：CISC和RISC的基本概念" class="headerlink" title="第三节：CISC和RISC的基本概念"></a>第三节：CISC和RISC的基本概念</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183716541.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183716541.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183716541"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183725380.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183725380.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183725380"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183731763.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183731763.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183731763"><hr><h2 id="第五章：中央处理器"><a href="#第五章：中央处理器" class="headerlink" title="第五章：中央处理器"></a>第五章：中央处理器</h2><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183831017.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183831017.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183831017"><hr><h3 id="第一节：CPU的功能和基本构造"><a href="#第一节：CPU的功能和基本构造" class="headerlink" title="第一节：CPU的功能和基本构造"></a>第一节：CPU的功能和基本构造</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184310506.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184310506.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184310506"><hr><h4 id="CPU的基本功能"><a href="#CPU的基本功能" class="headerlink" title="CPU的基本功能"></a>CPU的基本功能</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183928329.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630183928329.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630183928329"><p><strong>CPU的功能:</strong></p><ol><li><strong>指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。</strong></li><li><strong>操作控制：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。</strong></li><li><strong>时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。</strong></li><li><strong>数据加工：对数据进行算术和逻辑运算。</strong></li><li><strong>中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理。</strong></li></ol><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184001873.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184001873.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184001873"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184009060.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184009060.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184009060"><hr><h4 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h4><blockquote><p><strong>1.运算器</strong></p><ul><li><strong>算术逻辑单元ALU</strong></li><li><strong>累加寄存器ACC</strong></li><li><strong>程序字状态寄存器PSW</strong></li><li><strong>计数器CT</strong></li><li><strong>暂存寄存器</strong></li><li><strong>通用寄存器组</strong></li><li><strong>移位器</strong></li></ul></blockquote><blockquote><p><strong>通用寄存器供用户自由编程，可以存放数据和地址。而指令寄存器是专门用于存放指令的专用寄存器，不能由通用寄存器代替。</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184105642.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184105642.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184105642"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184115554.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184115554.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184115554"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184134374.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184134374.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184134374"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184143433.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184143433.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184143433"><blockquote><p><strong>2.控制器</strong></p><ul><li><strong>程序计数器PC:存放下一条指令在主存中的地址，具有自增功能。</strong></li><li><strong>指令寄存器IR：存放当前正在执行的指令。</strong></li><li><strong>指令译码器</strong></li><li><strong>存储器地址寄存器MAR</strong></li><li><strong>存储器数据寄存器MDR</strong></li><li><strong>时序系统</strong></li><li><strong>微操作信号发生器</strong></li></ul></blockquote><blockquote><p><strong>条件转移指令执行时，需要对<code>标志寄存器</code>的内容进行测试，判断是否满足转移条件。</strong></p><p><strong>转移指令时，需要判断转移是否成功，若成功则PC修改为转移指令的目标地址，否则下一条指令的地址仍然为PC自增后的地址。</strong></p><p><strong>指令包括操作码字段和地址码字段，但指令译码器仅对操作码字段进行译码，借以确定指令的操作功能。</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184231379.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184231379.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184231379"><blockquote><p><strong>注意：CPU内部寄存器大致可分为两类：一类是用户可见的寄存器，可对这类寄存器编程，如通用寄存器组、程序状态字寄存器；另一类是用户不可见的寄存器，对用户是透明的，不可对这类寄存器编程，如存储器地址寄存器MAR、存储器数据寄存器MDR、指令寄存器IR。</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184253543.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184253543.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184253543"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184300440.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184300440.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184300440"><hr><h3 id="第二节：指令执行过程"><a href="#第二节：指令执行过程" class="headerlink" title="第二节：指令执行过程"></a>第二节：指令执行过程</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184833129.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184833129.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184833129"><hr><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184427179.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184427179.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184427179"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184438340.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184438340.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184438340"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184447321.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184447321.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184447321"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184456782.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184456782.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184456782"><hr><h4 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h4><p><strong>取指周期：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184522707.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184522707.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184522707"><p><strong>间址周期：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184541475.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184541475.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184541475"><blockquote><p><strong>间址周期的作用是取操作数的有效地址，因此间址周期结束后，MDR的内容为操作数地址。</strong></p></blockquote><p><strong>执行周期</strong>：</p><blockquote><p><strong>根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行操作不同，因此没有统一的数据流向。</strong></p></blockquote><p><strong>中断周期：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184801231.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184801231.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184801231"><hr><h4 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184822244.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184822244.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184822244"><hr><h3 id="第三节：数据通路的功能和基本结构"><a href="#第三节：数据通路的功能和基本结构" class="headerlink" title="第三节：数据通路的功能和基本结构"></a>第三节：数据通路的功能和基本结构</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185151494.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185151494.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185151494"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184909058.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184909058.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184909058"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184916216.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184916216.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184916216"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184923316.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184923316.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184923316"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184929648.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184929648.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184929648"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184938502.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184938502.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184938502"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184949699.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630184949699.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630184949699"><p><strong>专用数据通路方式：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185053527.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185053527.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185053527"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185059927.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185059927.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185059927"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185107568.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185107568.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185107568"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185113640.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185113640.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185113640"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185120523.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185120523.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185120523"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185127362.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185127362.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185127362"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185134471.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185134471.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185134471"><hr><h3 id="第四节：控制器的功能和工作原理"><a href="#第四节：控制器的功能和工作原理" class="headerlink" title="第四节：控制器的功能和工作原理"></a>第四节：控制器的功能和工作原理</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185838774.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185838774.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185838774"><hr><h4 id="控制器的结构和功能"><a href="#控制器的结构和功能" class="headerlink" title="控制器的结构和功能"></a>控制器的结构和功能</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185231878.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185231878.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185231878"><p><strong>控制器是计算机系统的指挥中心，控制器的主要功能有：</strong></p><ul><li><strong>1)从主存中取出一条指令，并指出下一条指令在主存中的位置。</strong></li><li><strong>2)对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</strong></li><li><strong>3)指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185251898.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185251898.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185251898"><hr><h4 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h4><p><strong>1.硬布线控制单元图</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185331812.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185331812.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185331812"><p><strong>2.CPU的控制方式</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185436921.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185436921.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185436921"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185444638.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185444638.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185444638"><p><strong>3.硬布线控制单元设计步骤</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185507325.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185507325.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185507325"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185516987.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185516987.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185516987"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185523832.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185523832.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185523832"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185530403.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185530403.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185530403"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185536983.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185536983.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185536983"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185546925.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185546925.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185546925"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185553579.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185553579.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185553579"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185559921.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185559921.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185559921"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185608638.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185608638.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185608638"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185615389.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185615389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185615389"><hr><h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190436565.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190436565.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190436565"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185929000.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185929000.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185929000"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185935876.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185935876.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185935876"><p><strong>1.微程序控制的基本概念</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185959790.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630185959790.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630185959790"><p><strong>2.微程序控制组成和工作过程</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190023725.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190023725.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190023725"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190033044.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190033044.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190033044"><p><strong>3.微指令的格式</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190056833.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190056833.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190056833"><p><strong>4.微指令的编码方式</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190117619.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190117619.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190117619"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190125319.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190125319.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190125319"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190132375.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190132375.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190132375"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190139242.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190139242.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190139242"><p><strong>5.微指令的地址形成方式</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190207477.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190207477.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190207477"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190216915.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190216915.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190216915"><p><strong>6.微指令控制单元的设计</strong></p><p><strong>设计步骤：</strong></p><ol><li><strong>分析每个阶段的微操作序列</strong></li><li><strong>写出对应机器指令的微操作命令及节拍安排</strong></li><li><strong>确定微指令格式</strong></li><li><strong>编写微指令码点</strong></li></ol><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190311514.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190311514.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190311514"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190318713.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190318713.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190318713"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190326359.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190326359.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190326359"><p><strong>7.动态微程序设计和毫微程序设计</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190358133.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190358133.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190358133"><p><strong>8.硬布线与微程序控制器的特点</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190423621.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190423621.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190423621"><hr><h3 id="第五节：指令流水线"><a href="#第五节：指令流水线" class="headerlink" title="第五节：指令流水线"></a>第五节：指令流水线</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191252047.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191252047.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191252047"><hr><h4 id="指令流水的基本概念"><a href="#指令流水的基本概念" class="headerlink" title="指令流水的基本概念"></a>指令流水的基本概念</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190538083.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190538083.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190538083"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190545761.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190545761.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190545761"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190552260.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190552260.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190552260"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190558395.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190558395.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190558395"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190605251.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190605251.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190605251"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190614996.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190614996.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190614996"><p><strong>补充：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190746633.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190746633.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190746633"><hr><h4 id="影响流水线的因素"><a href="#影响流水线的因素" class="headerlink" title="影响流水线的因素"></a>影响流水线的因素</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190922615.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190922615.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190922615"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190820445.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190820445.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190820445"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190828398.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190828398.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190828398"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190839134.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190839134.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190839134"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190847853.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190847853.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190847853"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190858168.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190858168.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190858168"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190905241.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630190905241.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630190905241"><hr><h4 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h4><blockquote><p><strong>1.部件功能级、处理机级和处理机间级流水线</strong></p><ul><li><p><strong>根据流水线使用的级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。</strong></p></li><li><p><strong>部件功能级流水就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。</strong></p></li><li><p><strong>处理机级流水是把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存及写回5个子过程。</strong></p></li><li><p><strong>处理机间流水是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。</strong></p></li></ul><p><strong>2.单功能流水线和多功能流水线</strong></p><ul><li><p><strong>按流水线可以完成的功能，流水线可分为单功能流水线和多功能流水线。</strong></p></li><li><p><strong>单功能流水线指只能实现一种固定的专门功能的流水线；</strong></p></li><li><p><strong>多功能流水线指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。</strong></p></li></ul><p><strong>3.动态流水线和静态流水线</strong></p><ul><li><strong>按同一时间内各段之问的连接方式，流水线可分为静态流水线和动态流水线。</strong></li><li><strong>静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</strong></li><li><strong>动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</strong></li></ul><p><strong>4.线性流水线和非线性流水线</strong></p><ul><li><strong>按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。</strong></li><li><strong>线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</strong></li><li><strong>作线性流水线存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</strong></li></ul></blockquote><hr><h4 id="超标量流水线的基本概念"><a href="#超标量流水线的基本概念" class="headerlink" title="超标量流水线的基本概念"></a>超标量流水线的基本概念</h4><p><strong>1.超标量流水技术</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191140604.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191140604.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191140604"><p><strong>2.超流水技术</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191203827.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191203827.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191203827"><p><strong>3.超长指令集</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191224056.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191224056.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191224056"><hr><h2 id="第六章：总线"><a href="#第六章：总线" class="headerlink" title="第六章：总线"></a>第六章：总线</h2><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191933365.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191933365.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191933365"><hr><h3 id="第一节：总线的概述"><a href="#第一节：总线的概述" class="headerlink" title="第一节：总线的概述"></a>第一节：总线的概述</h3><h4 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191356449.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191356449.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191356449"><p><strong>总线的特性：</strong></p><ol><li><strong>机械特性：尺寸、形状、管脚数、排列顺序</strong></li><li><strong>电气特性：传输方向和有效的电平范围</strong></li><li><strong>功能特性：每根传输线的功能(地址、数据、控制)</strong></li><li><strong>时间特性：信号的时序关系</strong></li></ol><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191409774.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191409774.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191409774"><hr><h4 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191625907.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191625907.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191625907"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191617663.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191617663.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191617663"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191634158.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191634158.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191634158"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191704626.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191704626.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191704626"><p><strong>系统总线的结构：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191734019.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191734019.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191734019"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191746862.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191746862.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191746862"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191756782.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191756782.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191756782"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191807798.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630191807798.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630191807798"><hr><h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4><blockquote><p><strong>总线的性能指标</strong></p><ul><li><strong>1.总线的传输周期（总线周期）</strong></li><li><strong>2.总线时钟周期</strong></li><li><strong>3.总线的工作频率</strong></li><li><strong>4.总线的时钟频率</strong></li><li><strong>5.总线宽度</strong></li><li><strong>6.总线带宽</strong></li><li><strong>7.总线复用</strong></li><li><strong>8.信号线数</strong></li></ul></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192045571.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192045571.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192045571"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192054019.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192054019.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192054019"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192104969.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192104969.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192104969"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192117676.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192117676.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192117676"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192128172.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192128172.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192128172"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192137422.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192137422.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192137422"><hr><h3 id="第二节：总线仲裁"><a href="#第二节：总线仲裁" class="headerlink" title="第二节：总线仲裁"></a>第二节：总线仲裁</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192159353.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192159353.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192159353"><hr><h4 id="总线仲裁的基本概念"><a href="#总线仲裁的基本概念" class="headerlink" title="总线仲裁的基本概念"></a>总线仲裁的基本概念</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192248362.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192248362.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192248362"><hr><h4 id="集中仲裁方式"><a href="#集中仲裁方式" class="headerlink" title="集中仲裁方式"></a>集中仲裁方式</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192408604.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192408604.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192408604"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192257528.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192257528.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192257528"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192309632.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192309632.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192309632"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192323807.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192323807.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192323807"><hr><h4 id="分布式仲裁方式"><a href="#分布式仲裁方式" class="headerlink" title="分布式仲裁方式"></a>分布式仲裁方式</h4><p><strong>特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</strong></p><ul><li><strong>当设备有总线请求时，它们就把各自唯一的仲裁号发送到共享的仲裁总线上</strong></li><li><strong>每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较；</strong></li><li><strong>如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号；</strong></li><li><strong>最后，获胜者的仲裁号保留在仲裁总线上。</strong></li></ul><hr><h3 id="第三节：总线的操作和定时"><a href="#第三节：总线的操作和定时" class="headerlink" title="第三节：总线的操作和定时"></a>第三节：总线的操作和定时</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192716850.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192716850.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192716850"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192606083.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192606083.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192606083"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192614513.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192614513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192614513"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192622537.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192622537.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192622537"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192630524.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192630524.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192630524"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192638096.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192638096.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192638096"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192644950.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192644950.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192644950"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192652061.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192652061.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192652061"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192700894.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192700894.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192700894"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192707850.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192707850.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192707850"><hr><h3 id="第四节：总线标准"><a href="#第四节：总线标准" class="headerlink" title="第四节：总线标准"></a>第四节：总线标准</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193129129.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193129129.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193129129"><p><strong>总线标准的基本概念：</strong></p><ul><li><p><strong>总线标准是国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范。按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。</strong></p></li><li><p><strong>系统总线标准：ISA、EISA、VESA、PCI、PCI- Express等。</strong></p></li><li><p><strong>设备总线标准：IDE、AGP、RS-232C、USB、SATA、SCSI、 PCMCIA等。</strong></p></li><li><p><strong>局部总线标准：在ISA.总线和CPU总线之间增加的一级总线或管理层，如PCI、PCI-E、VESA、AGP等，可以节省系统的总带宽。</strong></p></li><li><p><strong>即插即用( Plug-and-Play)的作用是自动配置（低层）计算机中的板卡和其他设备，然后告诉对应的设备都做了什么。把物理设备和软件（设备驱动程序）相配合，并操作设备，在每个设备和它的驱动程序之间建立通信信道</strong></p></li><li><p><strong>热插拔( hot-plugging或 Hot Swap)即带电插拔，热插拔功能就是允许用户在不关闭系统，不切断电源的情况下取出和更换损坏的硬盘、电源或板卡等部件，从而提高了系统对灾难的及时恢复能力、扩展性和灵活性等，例如一些面向高端应用的磁盘镜像系统都可以提供磁盘的热插拔功能。</strong></p></li></ul><hr><h4 id="常见的总线标准"><a href="#常见的总线标准" class="headerlink" title="常见的总线标准"></a>常见的总线标准</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193139202.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193139202.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193139202"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192833326.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192833326.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192833326"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192840361.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192840361.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192840361"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192850969.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192850969.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192850969"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192858885.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192858885.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192858885"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192906364.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192906364.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192906364"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192920546.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192920546.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192920546"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192932760.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192932760.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192932760"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192945105.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192945105.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192945105"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192952215.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630192952215.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630192952215"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193001342.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193001342.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193001342"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193014186.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193014186.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193014186"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193027024.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193027024.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193027024"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193044606.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193044606.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193044606"><hr><h2 id="第七章：I-x2F-O系统"><a href="#第七章：I-x2F-O系统" class="headerlink" title="第七章：I&#x2F;O系统"></a>第七章：I&#x2F;O系统</h2><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/20210119200603623.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/20210119200603623.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20210119200603623"><hr><h3 id="第一节：I-x2F-O系统基本概念"><a href="#第一节：I-x2F-O系统基本概念" class="headerlink" title="第一节：I&#x2F;O系统基本概念"></a>第一节：I&#x2F;O系统基本概念</h3><h4 id="I-x2F-O系统"><a href="#I-x2F-O系统" class="headerlink" title="I&#x2F;O系统"></a>I&#x2F;O系统</h4><p><strong>输入、输出是以主机为中心谈论的！输入、输出设备都属于外部设备</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193340477.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193340477.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193340477"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193347894.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193347894.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193347894"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193400436.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193400436.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193400436"><hr><h4 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193423206.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193423206.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193423206"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193434121.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193434121.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193434121"><hr><h3 id="第二节：外部设备"><a href="#第二节：外部设备" class="headerlink" title="第二节：外部设备"></a>第二节：外部设备</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193519803.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193519803.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193519803"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193726521.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193726521.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193726521"><p><strong>外部设备：外部设备也称外围设备，是除了主机以外的、能直接或间接与计算机交换信息的装置。</strong></p><hr><h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4><p><strong>用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193548246.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193548246.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193548246"><hr><h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4><p><strong>用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193610596.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193610596.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193610596"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193619749.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193619749.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193619749"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193629385.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193629385.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193629385"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193642699.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193642699.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193642699"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193701732.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193701732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193701732"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193708883.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193708883.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193708883"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193715291.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193715291.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193715291"><hr><h4 id="外存设备"><a href="#外存设备" class="headerlink" title="外存设备"></a>外存设备</h4><p><strong>是指除计算机内存及CPU缓存等以外的存储器。硬磁盘、光盘等是最基本的外存设备</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193949533.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193949533.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193949533"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193759055.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193759055.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193759055"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193805902.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193805902.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193805902"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193814516.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193814516.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193814516"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193822726.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193822726.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193822726"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193837116.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193837116.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193837116"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193845176.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193845176.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193845176"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193852165.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193852165.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193852165"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193859819.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193859819.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193859819"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193907376.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193907376.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193907376"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193927402.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193927402.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193927402"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193936542.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630193936542.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630193936542"><hr><h3 id="第三节：I-x2F-O接口"><a href="#第三节：I-x2F-O接口" class="headerlink" title="第三节：I&#x2F;O接口"></a>第三节：I&#x2F;O接口</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194136947.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194136947.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194136947"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194018727.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194018727.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194018727"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194027205.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194027205.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194027205"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194037183.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194037183.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194037183"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194047767.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194047767.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194047767"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194107142.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194107142.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194107142"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194117599.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194117599.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194117599"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194128247.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194128247.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194128247"><hr><h3 id="第四节：I-x2F-O方式"><a href="#第四节：I-x2F-O方式" class="headerlink" title="第四节：I&#x2F;O方式"></a>第四节：I&#x2F;O方式</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194201335.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194201335.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194201335"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194208754.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194208754.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194208754"><hr><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194217593.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194217593.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194217593"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194230364.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194230364.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194230364"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194330499.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194330499.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194330499"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194336970.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194336970.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194336970"><hr><h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195044225.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195044225.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195044225"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194625041.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194625041.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194625041"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194638045.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194638045.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194638045"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194646315.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194646315.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194646315"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194655888.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194655888.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194655888"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194705017.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194705017.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194705017"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194712071.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194712071.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194712071"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194718877.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194718877.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194718877"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194724888.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194724888.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194724888"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194731995.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194731995.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194731995"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194740069.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194740069.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194740069"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194746773.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194746773.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194746773"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194753602.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194753602.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194753602"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194759339.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630194759339.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630194759339"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195013671.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195013671.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195013671"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195020477.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195020477.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195020477"><hr><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195243195.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195243195.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195243195"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195108708.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195108708.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195108708"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195116515.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195116515.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195116515"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195123644.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195123644.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195123644"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195130740.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195130740.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195130740"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195137769.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195137769.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195137769"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195145143.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195145143.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195145143"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195159958.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195159958.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195159958"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195208155.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195208155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195208155"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195215017.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195215017.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195215017"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195222658.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195222658.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195222658"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195232274.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-zu-cheng-yuan-li/image-20230630195232274.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230630195232274">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;专业核心基础理论：计算机组成原理&quot;&gt;&lt;a href=&quot;#专业核心基础理论：计算机组成原理&quot; class=&quot;headerlink&quot; title=&quot;专业核心基础理论：计算机组成原理&quot;&gt;&lt;/a&gt;专业核心基础理论：计算机组成原理&lt;/h1&gt;&lt;h2 id=&quot;第一章：计算机系统</summary>
      
    
    
    
    <category term="专业核心基础理论(九大件)" scheme="https://not-go.github.io/categories/%E4%B8%93%E4%B8%9A%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-%E4%B9%9D%E5%A4%A7%E4%BB%B6/"/>
    
    
    <category term="专业核心基础理论" scheme="https://not-go.github.io/tags/%E4%B8%93%E4%B8%9A%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>专业核心基础理论：计算机网络</title>
    <link href="https://not-go.github.io/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/"/>
    <id>https://not-go.github.io/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/</id>
    <published>2023-04-20T04:17:00.000Z</published>
    <updated>2023-06-30T13:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="专业核心理论基础：计算机网络"><a href="#专业核心理论基础：计算机网络" class="headerlink" title="专业核心理论基础：计算机网络"></a>专业核心理论基础：计算机网络</h1><h2 id="第一章：计算机网络体系结构"><a href="#第一章：计算机网络体系结构" class="headerlink" title="第一章：计算机网络体系结构"></a>第一章：计算机网络体系结构</h2><h3 id="第一节：计算机网络概述"><a href="#第一节：计算机网络概述" class="headerlink" title="第一节：计算机网络概述"></a>第一节：计算机网络概述</h3><h4 id="1-计算机网络的概念、组成、功能和分类"><a href="#1-计算机网络的概念、组成、功能和分类" class="headerlink" title="1.计算机网络的概念、组成、功能和分类"></a>1.计算机网络的概念、组成、功能和分类</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113023119.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113023119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109113023119"><hr><h5 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113329284.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113329284.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109113329284"><hr><h5 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h5><h6 id="从组成部分来看"><a href="#从组成部分来看" class="headerlink" title="从组成部分来看"></a>从组成部分来看</h6><ul><li><strong>一个完整的计算机网络主要由<code>硬件、软件和协议</code>三大部分组成，缺一不可</strong></li><li><strong>硬件主要由主机(也称端系统)，通信链路(如双绞线、光纤)、交换设备(如路由、交换机等)和通信处理机(如网卡)等组成</strong></li><li><strong>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件(如网络操作系统、邮件收发程序、FTP程序、聊天程序等)</strong></li><li><strong>协议是计算机网络的核心，协议规定了网络传输数据时所遵循的规范。就如同我们现实生活中的法律一样，网络世界也必须遵循一定的规则</strong></li></ul><hr><h6 id="从工作方式来看"><a href="#从工作方式来看" class="headerlink" title="从工作方式来看"></a>从工作方式来看</h6><ul><li><strong>计算机网络(主要指Internet)可分为<code>边缘部分和核心部分</code></strong></li><li><strong>边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信(如传输数据、音频或视频)和资源共享</strong></li><li><strong>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113449491.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113449491.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109113449491"><hr><h6 id="从功能组成来看"><a href="#从功能组成来看" class="headerlink" title="从功能组成来看"></a>从功能组成来看</h6><ul><li><strong>计算机网络由<code>通信子网和资源子网</code>组成</strong></li><li><strong>通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现计算机之间的<code>数据通信</code></strong></li><li><strong>资源子网是实现<code>资源共享</code>功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113510815.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113510815.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109113510815"><hr><h5 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h5><h6 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h6><ul><li><strong>数据通信是计算机网络最基本和最重要的功能，实现联网计算机之间的各种信息传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113534097.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113534097.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109113534097"><hr><h6 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h6><ul><li><strong>资源共享可以是软件共享、数据共享和硬件共享</strong></li><li><strong>计算机网络中的资源互通有无，分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率</strong></li></ul><hr><h6 id="分布式处理"><a href="#分布式处理" class="headerlink" title="分布式处理"></a>分布式处理</h6><ul><li><strong>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其它计算机系统，让它帮你处理，从而利用空闲计算机资源以提高整个系统的利用率</strong></li></ul><hr><h6 id="提高可靠性"><a href="#提高可靠性" class="headerlink" title="提高可靠性"></a>提高可靠性</h6><ul><li><strong>计算机网络中的各台计算机可以通过网络互为替代机，当一台计算机崩了，可以让另一台计算机来完成它的工作</strong></li></ul><hr><h6 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h6><ul><li><strong>将工作任务均衡的分配给计算机网络中的各台计算机</strong></li></ul><hr><h5 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h5><h6 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113636135.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113636135.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109113636135"><ul><li><strong><code>广域网（WAN）</code>：也称远程网。关于网提供长距离通信，通常是<code>几十千米到几千千米</code>的区域，比如跨国通信。连接关于网的各结点交换机的链路一般都是高速链路，具有较大的通信容量</strong></li><li><strong><code>城域网（MAN）</code>：覆盖范围跨越几个街区甚至整个城市，覆盖范围约<code>5~50km</code>，城域网大多采用以太网技术，因此有时也常并入局域网的范围进行讨论</strong></li><li><strong><code>局域网（LAN）</code>：范围<code>几十米到几千米</code>的区域。一般用微机或工作站通过高速线路相连。传统上，<code>局域网使用广播技术，而广域网使用交换技术</code></strong></li><li><strong><code>个人区域网（PAN）</code>：覆盖范围大约<code>十米左右</code>。指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也常称为无线个人区域网（WPAN）</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113701882.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113701882.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109113701882"><hr><h6 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h6><ul><li><strong>广播式网络。所有联网计算机都共享一个<code>公共通信信道</code>。当一台计算机利用<code>共享通信信道</code>发送报文分组时，所有其他计算机都会收听到这个分组。接受到该分组的计算机将通过检查目的地之来决定是否接受该分组</strong></li><li><strong>点对点网络。每条物理线路连接一对计算机</strong></li></ul><hr><h6 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h6><ul><li><strong>网络拓扑结构是指网络总的结点（路由器、主机等）于通信线路（网线）之间的几何关系（如总线形、环形）表示的网路结构，主要指通信子网的拓扑结构</strong></li><li><strong>分为四类：<code>总线形、星形、环形、网状形</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113855595.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109113855595.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109113855595"><blockquote><ul><li><strong>总线形：用单根传输线把计算机连接起来</strong></li><li><strong>星形：每个终端或计算机都以单独的线路和中央设备相连</strong></li><li><strong>环形：所有计算机接口设备连接成一个环</strong></li><li><strong>网状形：一般情况下，每个结点至少有两条路径与其他结点相连，多用于广域网</strong></li></ul></blockquote><hr><h6 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h6><ul><li><strong>公用网（Public Network）。也称公众网。指电信公司出资建造的大型网络</strong></li><li><strong>专用网（Private Network）。指某个部门为满足本单位特殊业务需要而建造的网络。这种网络不向本单位以外人提供服务。如铁路、典礼、军队等部门专用网络</strong></li></ul><hr><h6 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h6><ul><li><p><strong><code>电路交换网络</code>。在源结点和目的结点之间建立起一条专用的通路用于传输数据，包括建立连接（占用通信资源）、传输数据（一直占用通信资源）和断开连接（释放通信资源）三个阶段。最典型的电路交换网是传统电话网络。该类网络的特点是整个报文的比特流连续的从源点直达终点，好像在一条管道中传送</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114003295.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114003295.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114003295"></li><li><p><strong><code>报文交换网络</code>。也称<code>存储-转发网络</code>。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文、这个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点，每个报文可以单独选择到达目的结点的路径</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114017888-16732356370121.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114017888-16732356370121.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114017888"></li><li><p><strong><code>分组交换网络</code>。也称<code>包交换网络</code>。其原理是将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以<code>储存-转发方式</code>传输</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114109477.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114109477.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114109477"></li><li><p><strong>&#x3D;&#x3D;三种交换的比较：&#x3D;&#x3D;</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114135026.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114135026.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114135026"></li></ul><hr><h6 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h6><ul><li><strong>传输介质可分为有线和无线两大类</strong></li><li><strong>有线网络可分为双绞线网络、同轴电缆网络等</strong></li><li><strong>无线网络可分为蓝牙、微波、无线电等类型</strong></li></ul><hr><h4 id="2-计算机网络的性能指标-速率、带宽、吞吐量、时延、往返时延、时延带宽积、信道利用率"><a href="#2-计算机网络的性能指标-速率、带宽、吞吐量、时延、往返时延、时延带宽积、信道利用率" class="headerlink" title="2.计算机网络的性能指标(速率、带宽、吞吐量、时延、往返时延、时延带宽积、信道利用率)"></a>2.计算机网络的性能指标(速率、带宽、吞吐量、时延、往返时延、时延带宽积、信道利用率)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114348864.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114348864.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114348864"><hr><h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114559215.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114559215.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114559215"><hr><h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114613333.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114613333.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114613333"><hr><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114622090.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114622090.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114622090"><p><strong>&#x3D;&#x3D;PC机和交换机链路带宽100Mb&#x2F;s，每秒最多传输100Mb的数据。因为两个服务器速率很慢，所以服务器传输数据给交换机，交换机然后传输数据给PC机一秒钟传输数据最大只能是30Mb&#x2F;s&#x3D;&#x3D;</strong></p><hr><h5 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h5><ul><li><strong>指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成;<code>发送时延、传播时延、处理时延、排队时延</code></strong></li><li><strong><code>总时延=发送时延+传播时延+处理时延+排队时延</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114701176.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114701176.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114701176"><hr><h6 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h6><ul><li><strong>结点将分组的所有比特推向（传输）链路所需要的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特推向传输链路所需要的时间。也称<code>传输时延</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114721719.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114721719.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114721719"><ul><li><strong>如下图所示：假设我们的发送速率为 10b&#x2F;s ，数据长度为10个bit，所以我们的发送时延为1秒</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114738181.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114738181.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114738181"><hr><h6 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h6><ul><li><strong>电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的一端传播到另一端所需要的时间</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114847208.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114847208.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114847208"><ul><li><strong>我们假设AB之间的链路长度为100米，传输数率为10m&#x2F;s，则传播时延为10秒</strong></li><li><strong>一般在链路中，传输速率为2.0×10^8 m&#x2F;s 左右</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114905719.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114905719.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114905719"><ul><li><strong>一道题目计算发送时延和传播时延：</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114924323.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114924323.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114924323"><hr><h6 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h6><ul><li><strong>分组在进入路由器后要先在输入队列中排队等待处理。因为路由器可能也同时在处理其他链路传过来的数据，所以需要等待。然后终于等到路由器来处理你的数据了，路由器处理完你的数据后，会给你一个转发端口，然后你就拿着这个端口号又在输出队列中排队等待转发，因为等待转发的不止你一个啊，路由器一下会处理很多的数据，这就产生了排队时延</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114946023.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109114946023.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109114946023"><hr><h6 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h6><ul><li><strong>数据在交换结点为存储转发而进行的一些必要的处理所花费的时间</strong></li><li><strong>例如：分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115001831.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115001831.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115001831"><hr><h5 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h5><ul><li><strong>指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特</strong></li><li><strong>因此又称为以比特为单位的链路长度</strong></li><li><strong><code>时延带宽积 = 传播时延×信道带宽</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115026997.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115026997.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115026997"><hr><h5 id="往返时延-RTT"><a href="#往返时延-RTT" class="headerlink" title="往返时延(RTT)"></a>往返时延(RTT)</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115038418.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115038418.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115038418"><hr><h5 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h5><ul><li><strong>指出某一信道有百分之多少的时间是有数据通过的</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115057593-1688126378364-40.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115057593-1688126378364-40.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115057593"><hr><h3 id="第二节：计算机网络体系结构与参考模型"><a href="#第二节：计算机网络体系结构与参考模型" class="headerlink" title="第二节：计算机网络体系结构与参考模型"></a>第二节：计算机网络体系结构与参考模型</h3><h4 id="1-计算机网络的分层结构、协议、服务和接口"><a href="#1-计算机网络的分层结构、协议、服务和接口" class="headerlink" title="1.计算机网络的分层结构、协议、服务和接口"></a>1.计算机网络的分层结构、协议、服务和接口</h4><h5 id="为什么计算机网络要分层？"><a href="#为什么计算机网络要分层？" class="headerlink" title="为什么计算机网络要分层？"></a>为什么计算机网络要分层？</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115524285.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115524285.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115524285"><ul><li><strong>如上图所示，这是一台计算机向另一台计算机发送pdf文档的传输过程，传输过程分为大致4个步骤，这4个步骤合起来就是一个数据传输的解决方法。但是这4个步骤合起来，传输显得很复杂，不便于网络的研究、实现和维护。那么我们怎么解决这个问题呢？</strong></li><li><strong>我们可以采用“分层”的方式解决这个问题，将一个复杂大问题分解成若干子问题，那么子问题就相对来说更加容易研究和处理</strong></li></ul><hr><h5 id="如何分层呢？"><a href="#如何分层呢？" class="headerlink" title="如何分层呢？"></a>如何分层呢？</h5><ul><li><strong>刚刚上面那张图已经大致列出了两台计算机传输数据时需要计算机网络提供的4个大致功能，那我们分层就根据功能来划分。每个层次即是对相应功能的具体定义</strong></li><li><strong>分层也得遵守一些规则，这些规则是前人提出来的，我也就不解释了</strong></li><li><strong>分层基本原则：</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115557153.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115557153.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115557153"><hr><h5 id="认识分层结构-协议、接口、服务"><a href="#认识分层结构-协议、接口、服务" class="headerlink" title="认识分层结构(协议、接口、服务)"></a>认识分层结构(协议、接口、服务)</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115608248.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115608248.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115608248"><hr><p>​</p><h6 id="协议的组成"><a href="#协议的组成" class="headerlink" title="协议的组成"></a>协议的组成</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115625978.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115625978.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115625978"><hr><h6 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h6><ul><li><p><strong>注意：在一层内完成的全部功能并非都称之为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</strong></p></li><li><p><strong>上层使用下层所提供的服务必须与下层交换一些指令，这些指令在OSI中被称为服务原语。</strong></p></li><li><p><strong>OSI将原语划分为4类：</strong></p><p><strong>●请求(Request)：由服务用户发往服务提供者，请求它完成某项工作。</strong></p><p><strong>●指示(Indication)：由服务提供者发往服务用户，指示发生了某些事件。</strong></p><p><strong>●响应(Response)：由服务用户发往服务提供者，对前面发生的指示的响应。</strong></p><p><strong>●证实(Confirmation)：由服务提供者发往服务用户，对前面发生的请求的证实。</strong></p></li><li><p><strong>这4类原语用于不同的功能，如建立连接、传输数据和断开连接等。</strong></p></li><li><p><strong>有应答服务包括全部4种原语</strong></p></li><li><p><strong>无应答服务则只有请求和指示</strong></p></li><li><p><strong>举个例子来理解这四种原语</strong></p></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115811347.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115811347.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115811347"><hr><h6 id="协议、接口、服务之间的关系"><a href="#协议、接口、服务之间的关系" class="headerlink" title="协议、接口、服务之间的关系"></a>协议、接口、服务之间的关系</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115827880.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109115827880.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109115827880"><hr><h4 id="2-OSI参考模型-应用层、表示层、会话层、传输层、网络层、数据链路层、物理层"><a href="#2-OSI参考模型-应用层、表示层、会话层、传输层、网络层、数据链路层、物理层" class="headerlink" title="2.OSI参考模型(应用层、表示层、会话层、传输层、网络层、数据链路层、物理层)"></a>2.OSI参考模型(应用层、表示层、会话层、传输层、网络层、数据链路层、物理层)</h4><h5 id="网络分层结构背景"><a href="#网络分层结构背景" class="headerlink" title="网络分层结构背景"></a>网络分层结构背景</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120242434.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120242434.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120242434"><hr><h5 id="OSI怎么来的？"><a href="#OSI怎么来的？" class="headerlink" title="OSI怎么来的？"></a>OSI怎么来的？</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120319015.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120319015.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120319015"><hr><h5 id="OSI的结构"><a href="#OSI的结构" class="headerlink" title="OSI的结构"></a>OSI的结构</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120331398.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120331398.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120331398"><hr><h5 id="OSI数据传输图"><a href="#OSI数据传输图" class="headerlink" title="OSI数据传输图"></a>OSI数据传输图</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120410850.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120410850.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120410850"><hr><h5 id="OSI七层模型结构概述"><a href="#OSI七层模型结构概述" class="headerlink" title="OSI七层模型结构概述"></a>OSI七层模型结构概述</h5><h6 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层(Application Layer)"></a>应用层(Application Layer)</h6><ul><li><strong>应用层是OSI模型的最高层，是用户与网络的界面</strong></li><li><strong>应用层为特定类型的网络应用提供访问OSI环境的手段</strong></li><li><strong>因为用户的实际应用多种多样，就要求应用层采用不同的协议来解决不同应用类型的需求</strong></li><li><strong>典型的协议有：文件传输协议FTP、电子邮件协议SMTP、万维网HTTP等</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120455568.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120455568.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120455568"><hr><h6 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层(Presentation Layer)"></a>表示层(Presentation Layer)</h6><ul><li><strong>主要处理两个通信系统中交换信息的表示方式</strong></li><li><strong>不同机器采用的编码和表示方法不同，使用的数据结构不同</strong></li><li><strong>为了使不同的数据和信息之间能够互相交换，表示层采用抽象的标准方法定义数据结构</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120513798.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120513798.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120513798"><hr><h6 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层(Session Layer)"></a>会话层(Session Layer)</h6><ul><li><strong>会话层允许不同主机上的各个进程进行会话</strong></li><li><strong>会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务</strong></li><li><strong>增值服务即图上最上方的一句话</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120537435.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120537435.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120537435"><hr><h6 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层(Transport Layer)"></a>传输层(Transport Layer)</h6><ul><li><strong>传输层也称运输层，传输单位是报文段或用户数据报，传输层负责主机中两个进程之间的通信，功能是为<code>端到端</code>连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务</strong></li><li><strong>数据链路层是<code>点到点</code>的通信，传输层是<code>端到端</code>的通信</strong></li><li><strong><code>点到点</code>：可以理解为主机到主机之间的通信，一个点指一个硬件地址或IP地址，网络中参与通信的主机通过硬件地址或IP地址标识的</strong></li><li><strong><code>端到端</code>：指运行在不同主机内的两个进程之间的通信，一个进程由一个端口号来标识，所以称端到端通信</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120625514.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120625514.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120625514"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120641992.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120641992.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120641992"><hr><h6 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层(Network Layer)"></a>网络层(Network Layer)</h6><ul><li><strong>因为因特网的主要网络层协议是<code>无连接</code>的网际协议（Internet Protocol，IP）和许多<code>路由</code>选择协议，因此因特网的网络层也称<code>网际层或IP层</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120707880.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120707880.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120707880"><hr><h6 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层(Data Link Layer)"></a>数据链路层(Data Link Layer)</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120718191.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120718191.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120718191"><hr><h6 id="物理层-Physical-Layer"><a href="#物理层-Physical-Layer" class="headerlink" title="物理层(Physical Layer)"></a>物理层(Physical Layer)</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120729030-1688127295816-59.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109120729030-1688127295816-59.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109120729030"><hr><h4 id="3-TCP-x2F-IP参考模型、五层参考模型、OSI与TCP-x2F-IP参考模型比较"><a href="#3-TCP-x2F-IP参考模型、五层参考模型、OSI与TCP-x2F-IP参考模型比较" class="headerlink" title="3.TCP&#x2F;IP参考模型、五层参考模型、OSI与TCP&#x2F;IP参考模型比较"></a>3.TCP&#x2F;IP参考模型、五层参考模型、OSI与TCP&#x2F;IP参考模型比较</h4><h5 id="TCP-x2F-IP、OSI、五层参考模型结构图"><a href="#TCP-x2F-IP、OSI、五层参考模型结构图" class="headerlink" title="TCP&#x2F;IP、OSI、五层参考模型结构图"></a>TCP&#x2F;IP、OSI、五层参考模型结构图</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121011160.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121011160.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109121011160"><hr><h5 id="TCP-x2F-IP、OSI的相同点"><a href="#TCP-x2F-IP、OSI的相同点" class="headerlink" title="TCP&#x2F;IP、OSI的相同点"></a>TCP&#x2F;IP、OSI的相同点</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121045145.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121045145.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109121045145"><hr><h5 id="TCP-x2F-IP、OSI的不同点"><a href="#TCP-x2F-IP、OSI的不同点" class="headerlink" title="TCP&#x2F;IP、OSI的不同点"></a>TCP&#x2F;IP、OSI的不同点</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121053781.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121053781.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109121053781"><hr><h5 id="五层参考模型结构"><a href="#五层参考模型结构" class="headerlink" title="五层参考模型结构"></a>五层参考模型结构</h5><ul><li><strong>&#x3D;&#x3D;为了学习计算机网络，采取折中的方法，综合学习OSI和TCP&#x2F;IP的优点&#x3D;&#x3D;</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121113367.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121113367.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109121113367"><hr><h5 id="五层参考模型数据封装与解封装-数据传输"><a href="#五层参考模型数据封装与解封装-数据传输" class="headerlink" title="五层参考模型数据封装与解封装(数据传输)"></a>五层参考模型数据封装与解封装(数据传输)</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121129092-1688127402073-65.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121129092-1688127402073-65.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109121129092"><hr><h2 id="第二章：物理层"><a href="#第二章：物理层" class="headerlink" title="第二章：物理层"></a>第二章：物理层</h2><h3 id="第一节：通信基础"><a href="#第一节：通信基础" class="headerlink" title="第一节：通信基础"></a>第一节：通信基础</h3><h4 id="1-物理层接口特征、数据通信模型、物理层基本概念-数据、信号、码元、信源、新宿、速率、波特、带宽"><a href="#1-物理层接口特征、数据通信模型、物理层基本概念-数据、信号、码元、信源、新宿、速率、波特、带宽" class="headerlink" title="1.物理层接口特征、数据通信模型、物理层基本概念(数据、信号、码元、信源、新宿、速率、波特、带宽)"></a>1.物理层接口特征、数据通信模型、物理层基本概念(数据、信号、码元、信源、新宿、速率、波特、带宽)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121941085.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121941085.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109121941085"><hr><h5 id="物理层接口的特性"><a href="#物理层接口的特性" class="headerlink" title="物理层接口的特性"></a>物理层接口的特性</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121958087.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109121958087.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109121958087"><hr><h5 id="典型的数据通信模型"><a href="#典型的数据通信模型" class="headerlink" title="典型的数据通信模型"></a>典型的数据通信模型</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122006712.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122006712.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122006712"><hr><h5 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122015325.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122015325.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122015325"><hr><h5 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122022889.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122022889.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122022889"><hr><h5 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h5><h6 id="数据、信号、信源、信宿、信道"><a href="#数据、信号、信源、信宿、信道" class="headerlink" title="数据、信号、信源、信宿、信道"></a>数据、信号、信源、信宿、信道</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122053964.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122053964.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122053964"><hr><h6 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122106573.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122106573.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122106573"><hr><h6 id="速率、波特、带宽"><a href="#速率、波特、带宽" class="headerlink" title="速率、波特、带宽"></a>速率、波特、带宽</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122117034.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122117034.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122117034"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122127376-1688127764622-75.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122127376-1688127764622-75.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122127376"><hr><h4 id="2-奈氏准则和香农定理"><a href="#2-奈氏准则和香农定理" class="headerlink" title="2.奈氏准则和香农定理"></a>2.奈氏准则和香农定理</h4><h5 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122301510.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122301510.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122301510"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122308898.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122308898.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122308898"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122315449.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122315449.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122315449"><hr><h5 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122327652.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122327652.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122327652"><hr><h5 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122340402.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122340402.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122340402"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122346823.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122346823.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122346823"><hr><h5 id="奈氏准则和香农定理的比较"><a href="#奈氏准则和香农定理的比较" class="headerlink" title="奈氏准则和香农定理的比较"></a>奈氏准则和香农定理的比较</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122355006-1688127871965-83.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122355006-1688127871965-83.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122355006"><hr><h4 id="3-编码与调制"><a href="#3-编码与调制" class="headerlink" title="3.编码与调制"></a>3.编码与调制</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122612002.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122612002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122612002"><hr><h5 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h5><ul><li><strong>根据原始电信号的特征，基带信号可分为数字基带信号和模拟基带信号（相应地，信源也分为数字信源和模拟信源）其由信源决定</strong></li><li><strong>宽带信号的定义是传输速度达到200kbps或以上,不管模拟信号还是数字信号只要满足就可算作宽带信号</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122637474.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122637474.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122637474"><hr><h5 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h5><ul><li><strong>数据无论是数字的，还是模拟的，为了传输的目的都必须转变成信号。</strong></li><li><strong>把数据变换为模拟信号的过程称为调制，把数据变换为数字信号的过程称为编码</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122655299.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122655299.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122655299"><hr><h5 id="四种编码与调制方式"><a href="#四种编码与调制方式" class="headerlink" title="四种编码与调制方式"></a>四种编码与调制方式</h5><h6 id="数字数据”编码”为数字信号"><a href="#数字数据”编码”为数字信号" class="headerlink" title="数字数据”编码”为数字信号"></a>数字数据”编码”为数字信号</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122707305.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122707305.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122707305"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122713320.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122713320.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122713320"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122719198.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122719198.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122719198"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122726904.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122726904.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122726904"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122734099.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122734099.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122734099"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122750020.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122750020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122750020"><hr><h6 id="数字数据”调制”为模拟信号"><a href="#数字数据”调制”为模拟信号" class="headerlink" title="数字数据”调制”为模拟信号"></a>数字数据”调制”为模拟信号</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122803284.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122803284.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122803284"><hr><h6 id="模拟数据“编码”为数字信号"><a href="#模拟数据“编码”为数字信号" class="headerlink" title="模拟数据“编码”为数字信号"></a>模拟数据“编码”为数字信号</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122814443.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122814443.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122814443"><hr><h6 id="模拟数据“调制”为模拟信号"><a href="#模拟数据“调制”为模拟信号" class="headerlink" title="模拟数据“调制”为模拟信号"></a>模拟数据“调制”为模拟信号</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122823306-1688128132766-96.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109122823306-1688128132766-96.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109122823306"><hr><h3 id="第二节：传输介质及物理设备"><a href="#第二节：传输介质及物理设备" class="headerlink" title="第二节：传输介质及物理设备"></a>第二节：传输介质及物理设备</h3><h4 id="1-传输介质-双绞线、同轴电缆、光纤、无线电缆、微波、激光、红外线"><a href="#1-传输介质-双绞线、同轴电缆、光纤、无线电缆、微波、激光、红外线" class="headerlink" title="1.传输介质(双绞线、同轴电缆、光纤、无线电缆、微波、激光、红外线)"></a>1.传输介质(双绞线、同轴电缆、光纤、无线电缆、微波、激光、红外线)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123107048.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123107048.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123107048"><hr><h5 id="传输介质及其分类"><a href="#传输介质及其分类" class="headerlink" title="传输介质及其分类"></a>传输介质及其分类</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123115715.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123115715.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123115715"><hr><h5 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h5><h6 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123126770.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123126770.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123126770"><hr><h6 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123137056.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123137056.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123137056"><hr><h6 id="双绞线VS同轴电缆"><a href="#双绞线VS同轴电缆" class="headerlink" title="双绞线VS同轴电缆"></a>双绞线VS同轴电缆</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123151360.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123151360.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123151360"><hr><h6 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123201020.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123201020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123201020"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123208185.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123208185.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123208185"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123214886.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123214886.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123214886"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123221366.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123221366.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123221366"><hr><h5 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123233796-1688128373194-107.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123233796-1688128373194-107.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123233796"><hr><h4 id="2-物理层设备-中继器、集线器"><a href="#2-物理层设备-中继器、集线器" class="headerlink" title="2.物理层设备(中继器、集线器)"></a>2.物理层设备(中继器、集线器)</h4><h5 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123325132.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123325132.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123325132"><hr><h5 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123338784-1688128497417-110.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123338784-1688128497417-110.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123338784"><hr><h2 id="第三章：数据链路层"><a href="#第三章：数据链路层" class="headerlink" title="第三章：数据链路层"></a>第三章：数据链路层</h2><h3 id="第一节：数据链路层的功能"><a href="#第一节：数据链路层的功能" class="headerlink" title="第一节：数据链路层的功能"></a>第一节：数据链路层的功能</h3><h4 id="数据链路层的基本概念和功能概述"><a href="#数据链路层的基本概念和功能概述" class="headerlink" title="数据链路层的基本概念和功能概述"></a>数据链路层的基本概念和功能概述</h4><h5 id="数据链路层的基本概念"><a href="#数据链路层的基本概念" class="headerlink" title="数据链路层的基本概念"></a>数据链路层的基本概念</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123458902.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123458902.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123458902"><hr><h5 id="数据链路层的功能概述"><a href="#数据链路层的功能概述" class="headerlink" title="数据链路层的功能概述"></a>数据链路层的功能概述</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123508959.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123508959.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123508959"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123514935-1688128819528-114.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123514935-1688128819528-114.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123514935"><hr><h3 id="第二节：组帧"><a href="#第二节：组帧" class="headerlink" title="第二节：组帧"></a>第二节：组帧</h3><h4 id="封装成帧、帧定界、帧同步、组帧的四种方法-字符计数法、字符串的首位填充法、零比特填充的首位标志法、违规编码法"><a href="#封装成帧、帧定界、帧同步、组帧的四种方法-字符计数法、字符串的首位填充法、零比特填充的首位标志法、违规编码法" class="headerlink" title="封装成帧、帧定界、帧同步、组帧的四种方法(字符计数法、字符串的首位填充法、零比特填充的首位标志法、违规编码法)"></a>封装成帧、帧定界、帧同步、组帧的四种方法(字符计数法、字符串的首位填充法、零比特填充的首位标志法、违规编码法)</h4><h5 id="封装成帧、帧定界、帧同步"><a href="#封装成帧、帧定界、帧同步" class="headerlink" title="封装成帧、帧定界、帧同步"></a>封装成帧、帧定界、帧同步</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123822276.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123822276.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123822276"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123829715.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123829715.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123829715"><hr><h5 id="组帧的四种方法"><a href="#组帧的四种方法" class="headerlink" title="组帧的四种方法"></a>组帧的四种方法</h5><h6 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123839794.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123839794.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123839794"><hr><h6 id="字符填充的首尾定界法"><a href="#字符填充的首尾定界法" class="headerlink" title="字符填充的首尾定界法"></a>字符填充的首尾定界法</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123857978.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123857978.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123857978"><ul><li><strong>那么我们如何去解决这种错误呢？</strong></li><li><strong>我们可以在特殊字符（SOH、EOT、ESC）前面填充一个转义字符来区分</strong></li><li><strong>发送方在封装帧时，进行扫描，扫描到SOH、EOT、ESC（转义字符）时在其前面添加转义字符，以区分，告诉接受方这个和特殊字符相同的字符是数据，当然这些约定由双方之间的协议完成</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123919076.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123919076.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123919076"><hr><h6 id="零比特填充的首尾标志法"><a href="#零比特填充的首尾标志法" class="headerlink" title="零比特填充的首尾标志法"></a>零比特填充的首尾标志法</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123929507.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123929507.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123929507"><hr><h6 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123959303-1688128911174-122.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109123959303-1688128911174-122.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109123959303"><hr><h3 id="第三节：差错控制"><a href="#第三节：差错控制" class="headerlink" title="第三节：差错控制"></a>第三节：差错控制</h3><h4 id="差错控制-检错编码和纠错编码、奇偶校验码、CRC循环冗余码、海明码"><a href="#差错控制-检错编码和纠错编码、奇偶校验码、CRC循环冗余码、海明码" class="headerlink" title="差错控制(检错编码和纠错编码、奇偶校验码、CRC循环冗余码、海明码)"></a>差错控制(检错编码和纠错编码、奇偶校验码、CRC循环冗余码、海明码)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124558762.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124558762.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124558762"><hr><h5 id="为什么会出现差错控制？"><a href="#为什么会出现差错控制？" class="headerlink" title="为什么会出现差错控制？"></a>为什么会出现差错控制？</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124615360.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124615360.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124615360"><hr><h5 id="检验和纠正差错的编码方式"><a href="#检验和纠正差错的编码方式" class="headerlink" title="检验和纠正差错的编码方式"></a>检验和纠正差错的编码方式</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124623652.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124623652.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124623652"><hr><h6 id="关于数据链路层和物理层编码的区别"><a href="#关于数据链路层和物理层编码的区别" class="headerlink" title="关于数据链路层和物理层编码的区别"></a>关于数据链路层和物理层编码的区别</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124638587.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124638587.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124638587"><hr><h6 id="冗余编码"><a href="#冗余编码" class="headerlink" title="冗余编码"></a>冗余编码</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124646367.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124646367.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124646367"><hr><h5 id="检错编码-奇偶校验码、循环冗余码"><a href="#检错编码-奇偶校验码、循环冗余码" class="headerlink" title="检错编码(奇偶校验码、循环冗余码)"></a>检错编码(奇偶校验码、循环冗余码)</h5><h6 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124702075.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124702075.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124702075"><hr><h6 id="循环冗余码-CRC"><a href="#循环冗余码-CRC" class="headerlink" title="循环冗余码(CRC)"></a>循环冗余码(CRC)</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124710817.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124710817.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124710817"><hr><h5 id="纠错编码-海明码"><a href="#纠错编码-海明码" class="headerlink" title="纠错编码(海明码)"></a>纠错编码(海明码)</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124721316.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124721316.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124721316"><hr><h6 id="确定校验码位数r"><a href="#确定校验码位数r" class="headerlink" title="确定校验码位数r"></a>确定校验码位数r</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124732052.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124732052.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124732052"><hr><h6 id="确定校验码和数据的位置"><a href="#确定校验码和数据的位置" class="headerlink" title="确定校验码和数据的位置"></a>确定校验码和数据的位置</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124740667.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124740667.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124740667"><hr><h6 id="求出校验码的值"><a href="#求出校验码的值" class="headerlink" title="求出校验码的值"></a>求出校验码的值</h6><p><strong>参考我这个文章：<a href="https://blog.csdn.net/qq_29678157/article/details/128592461">校验码(点击跳转)</a></strong></p><hr><h6 id="检错和纠错"><a href="#检错和纠错" class="headerlink" title="检错和纠错"></a>检错和纠错</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124858690-1688129074569-134.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109124858690-1688129074569-134.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109124858690"><hr><h3 id="第四节：流量控制与可靠传输机制"><a href="#第四节：流量控制与可靠传输机制" class="headerlink" title="第四节：流量控制与可靠传输机制"></a>第四节：流量控制与可靠传输机制</h3><h4 id="流量控制-停止-等待协议、滑动窗口、后退N帧协议GBN、选择重传协议SR-、滑动窗口、可靠传输机制"><a href="#流量控制-停止-等待协议、滑动窗口、后退N帧协议GBN、选择重传协议SR-、滑动窗口、可靠传输机制" class="headerlink" title="流量控制(停止-等待协议、滑动窗口、后退N帧协议GBN、选择重传协议SR)、滑动窗口、可靠传输机制"></a>流量控制(停止-等待协议、滑动窗口、后退N帧协议GBN、选择重传协议SR)、滑动窗口、可靠传输机制</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/20200317145615651.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/20200317145615651.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20200317145615651"><hr><h5 id="什么是流量控制？"><a href="#什么是流量控制？" class="headerlink" title="什么是流量控制？"></a>什么是流量控制？</h5><ul><li><strong>流量控制是数据链路层的一种功能，流量控制对数据链路上的帧的发送速率进行控制，以使接收方有足够的缓冲空间来接受每个帧</strong></li><li><strong>流量控制的基本方法是由接收方控制发送方发送数据的速率</strong></li><li><strong>常见的流量控制方式有两种：<code>停止-等待协议、滑动窗口协议</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133020911.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133020911.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133020911"><hr><h5 id="什么是可靠传输机制？"><a href="#什么是可靠传输机制？" class="headerlink" title="什么是可靠传输机制？"></a>什么是可靠传输机制？</h5><ul><li><strong>可靠传输机制是为了使数据可以正确稳定的传输和接收而制定的规则</strong></li><li><strong>数据链路层的可靠传输通常使用<code>确认和超时重传</code>两种机制来完成</strong></li><li><strong><code>确认</code>：是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认</strong></li><li><strong><code>超时重传</code>：是指发送方在发送某一个数据帧以后就开始一个计时器，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，直到发送成功为止</strong></li><li><strong><code>自动重传请求（Auto Repeat reQuest，ARQ）</code>，通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一</strong></li><li><strong>传统自动重传请求分为三种，即<code>停等式（Stop-and-Wait）ARQ</code>、<code>后退N帧（Go-Back-N）ARQ</code>以及<code>选择性重传（Selective Repeat）ARQ</code>。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大，帧在线路上可以连续地流动，因此又称为连续ARQ协议</strong></li></ul><hr><p>​</p><h5 id="什么是滑动窗口机制？"><a href="#什么是滑动窗口机制？" class="headerlink" title="什么是滑动窗口机制？"></a>什么是滑动窗口机制？</h5><ul><li><strong>滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为<code>发送窗口</code>；同时，接收方也维持了一个连续的允许接收的帧的序号，称为<code>接收窗口</code></strong></li><li><strong>发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同</strong></li><li><strong>不同的滑动窗口协议窗口大小一般不同</strong></li><li><strong>发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133248061.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133248061.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133248061"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133259634.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133259634.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133259634"><ul><li><p><strong>在<code>发送端</code>，每收到一个确认帧，发送窗口就向前滑动一个帧的位置，当发送窗口内没有可以发送的帧（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接受方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送。</strong></p></li><li><p><strong>在<code>接受端</code>，当收到数据帧后，将窗口向前移一个位置，并发回确认帧，若收到的数据帧落在接受窗口之外则一律丢弃。</strong></p></li><li><p><strong>滑动窗口有以下<code>重要特性</code>：</strong></p><ul><li><strong>只有接受窗口向前滑动时（同时接受方发送确认帧），发送窗口才有可能（只有发送方收到确认帧才是一定）向前滑动</strong></li><li><strong>从滑动窗口的概念看，停止-等待协议、后退N帧协议和选择重传协议只有在发送窗口大小和接收窗口大小有所差别</strong></li><li><strong>停止-等待协议：发送窗口大小&#x3D;1，接受窗口大小&#x3D;1</strong></li><li><strong>后退N帧协议：发送窗口大小&gt;1，接受窗口大小&#x3D;1</strong></li><li><strong>选择重传协议：发送窗口大小&gt;1，接受窗口大小&gt;1</strong></li><li><strong>当接受窗口的大小为1时，可保证帧的有序接受</strong></li></ul></li></ul><hr><h5 id="可靠传输、流量控制、滑动窗口之间的关系"><a href="#可靠传输、流量控制、滑动窗口之间的关系" class="headerlink" title="可靠传输、流量控制、滑动窗口之间的关系"></a>可靠传输、流量控制、滑动窗口之间的关系</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133419267.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133419267.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133419267"><hr><h5 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h5><ul><li><strong><code>停止-等待协议也称为单帧滑动窗口与停止-等待协议</code></strong></li><li><strong>当发送窗口和接收窗口的大小固定为1时，滑动窗口协议退化为停等协议（stop-and-wait）</strong></li><li><strong>该协议规定发送方每发送一帧后就要停下来，等待接收方已正确接收的确认（acknowledgement）返回后才能继续发送下一帧</strong></li><li><strong>由于接收方需要判断接收到的帧是新发的帧还是重新发送的帧，因此发送方要为每一个帧加一个序号</strong></li><li><strong>由于停等协议规定只有一帧完全发送成功后才能发送新的帧，因而只用一比特来编号就够了</strong></li></ul><hr><h6 id="为什么要有停止-等待协议？"><a href="#为什么要有停止-等待协议？" class="headerlink" title="为什么要有停止-等待协议？"></a>为什么要有停止-等待协议？</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133457187.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133457187.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133457187"><hr><h6 id="研究停止-等待协议的前提"><a href="#研究停止-等待协议的前提" class="headerlink" title="研究停止-等待协议的前提"></a>研究停止-等待协议的前提</h6><ul><li><strong>虽然现在常用全双工通信方式，但是为了讨论方便，我们仅考虑一方发送数据（发送方），一方接收数据</strong></li></ul><hr><h6 id="停止-等待协议有几种应用情况？"><a href="#停止-等待协议有几种应用情况？" class="headerlink" title="停止-等待协议有几种应用情况？"></a>停止-等待协议有几种应用情况？</h6><ul><li><strong>两种：<code>无差错和有差错</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133536309.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133536309.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133536309"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133550002.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133550002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133550002"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133603745.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133603745.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133603745"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133610049.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133610049.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133610049"><h6 id="停止-等待协议性能分析"><a href="#停止-等待协议性能分析" class="headerlink" title="停止-等待协议性能分析"></a>停止-等待协议性能分析</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133635653.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133635653.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133635653"><ul><li><strong>发送方从开始发送数据到收到第一个确认帧ACK为止，这段时间称为一个<code>发送周期</code></strong></li><li><strong>信道利用率&#x3D;发送时间&#x2F;发送周期</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133649968.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133649968.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133649968"><p><strong>由于停等协议要为每一个帧进行确认后才继续发送下一帧，大大降低了信道利用率，因此又提出了<code>后退n帧协议（GBN）和选择重传协议（SR）</code></strong></p><hr><h5 id="多帧滑动窗口与后退N帧协议-GBN"><a href="#多帧滑动窗口与后退N帧协议-GBN" class="headerlink" title="多帧滑动窗口与后退N帧协议(GBN)"></a>多帧滑动窗口与后退N帧协议(GBN)</h5><ul><li><strong>后退n协议中，发送方在发完一个数据帧后，不停下来等待应答帧，而是连续发送若干个数据帧，即使在连续发送过程中收到了接收方发来的应答帧，也可以继续发送。且发送方在每发送完一个数据帧时都要设置超时定时器。只要在所设置的超时时间内仍未收到确认帧，就要重发相应的数据帧</strong></li><li><strong>如：当发送方发送了N个帧后，若发现该N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重新发送出错帧及其后的N帧</strong></li><li><strong>从这里不难看出，后退n协议一方面因连续发送数据帧而提高了效率，但另一方面，在重传时又必须把原来已正确传送过的数据帧进行重传（仅因这些数据帧之前有一个数据帧出了错），这种做法又使传送效率降低</strong></li><li><strong>由此可见，若传输信道的传输质量很差因而误码率较大时，连续测协议不一定优于停止等待协议。此协议中的发送窗口的大小为k，接收窗口仍是1</strong></li></ul><hr><h6 id="后退N帧协议-GBN-的滑动窗口"><a href="#后退N帧协议-GBN-的滑动窗口" class="headerlink" title="后退N帧协议(GBN)的滑动窗口"></a>后退N帧协议(GBN)的滑动窗口</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133743417.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133743417.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133743417"><hr><h6 id="GBN发送方响应的三件事"><a href="#GBN发送方响应的三件事" class="headerlink" title="GBN发送方响应的三件事"></a>GBN发送方响应的三件事</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133753307.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133753307.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133753307"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133814360.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133814360.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133814360"><hr><h6 id="GBN接受方要做的事"><a href="#GBN接受方要做的事" class="headerlink" title="GBN接受方要做的事"></a>GBN接受方要做的事</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133822675.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133822675.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133822675"><hr><h6 id="GBN发送方和接受方之间的传输过程"><a href="#GBN发送方和接受方之间的传输过程" class="headerlink" title="GBN发送方和接受方之间的传输过程"></a>GBN发送方和接受方之间的传输过程</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133837292.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133837292.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133837292"><hr><h6 id="GBN滑动窗口的限制"><a href="#GBN滑动窗口的限制" class="headerlink" title="GBN滑动窗口的限制"></a>GBN滑动窗口的限制</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133846658.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133846658.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133846658"><hr><h6 id="GBN重点知识"><a href="#GBN重点知识" class="headerlink" title="GBN重点知识"></a>GBN重点知识</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133855761.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133855761.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133855761"><p>​<img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133906530.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133906530.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133906530"></p><hr><h6 id="GBN性能分析"><a href="#GBN性能分析" class="headerlink" title="GBN性能分析"></a>GBN性能分析</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133916722.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133916722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133916722"><hr><h5 id="多帧滑动窗口与选择重传协议-SR"><a href="#多帧滑动窗口与选择重传协议-SR" class="headerlink" title="多帧滑动窗口与选择重传协议(SR)"></a>多帧滑动窗口与选择重传协议(SR)</h5><ul><li><strong>在后退n协议中，接收方若发现错误帧就不再接收后续的帧，即使是正确到达的帧，这显然是一种浪费。由此诞生了SR（SELECTICE REPEAT）</strong></li><li><strong>SR工作原理：当接收方发现某帧出错后，其后继续送来的正确的帧虽然不能立即递交给接收方的高层，但接收方仍可收下来，存放在一个缓冲区中，同时要求发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以将已存于缓冲区中的其余帧一并按正确的顺序递交上一层</strong></li><li><strong>显然，选择重发减少了浪费，但要求接收方有足够大的缓冲区空间</strong></li></ul><hr><h6 id="SR的滑动窗口"><a href="#SR的滑动窗口" class="headerlink" title="SR的滑动窗口"></a>SR的滑动窗口</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133954154.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109133954154.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109133954154"><hr><h6 id="SR发送方必须响应的三件事"><a href="#SR发送方必须响应的三件事" class="headerlink" title="SR发送方必须响应的三件事"></a>SR发送方必须响应的三件事</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134007705.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134007705.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109134007705"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134019557.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134019557.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109134019557"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134027864.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134027864.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109134027864"><hr><h6 id="SR接受方要做的事"><a href="#SR接受方要做的事" class="headerlink" title="SR接受方要做的事"></a>SR接受方要做的事</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134054159.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134054159.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109134054159"><hr><p>​</p><h6 id="SR发送方和接受方之间的传输过程"><a href="#SR发送方和接受方之间的传输过程" class="headerlink" title="SR发送方和接受方之间的传输过程"></a>SR发送方和接受方之间的传输过程</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134116354.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134116354.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109134116354"><hr><h6 id="SR滑动串口的大小限制"><a href="#SR滑动串口的大小限制" class="headerlink" title="SR滑动串口的大小限制"></a>SR滑动串口的大小限制</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134126334.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134126334.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109134126334"><hr><h6 id="SR重点知识"><a href="#SR重点知识" class="headerlink" title="SR重点知识"></a>SR重点知识</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134151510-1688129306557-164.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109134151510-1688129306557-164.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109134151510"><hr><h3 id="第五节：介质访问控制"><a href="#第五节：介质访问控制" class="headerlink" title="第五节：介质访问控制"></a>第五节：介质访问控制</h3><h4 id="介质访问控制-静态划分信道：FDM、TDM、STDM、WDM、CDM，动态划分信道：ALOH、CSMA、CSMA-x2F-CD、CSMA-x2F-CA-、令牌传递协议"><a href="#介质访问控制-静态划分信道：FDM、TDM、STDM、WDM、CDM，动态划分信道：ALOH、CSMA、CSMA-x2F-CD、CSMA-x2F-CA-、令牌传递协议" class="headerlink" title="介质访问控制(静态划分信道：FDM、TDM、STDM、WDM、CDM，动态划分信道：ALOH、CSMA、CSMA&#x2F;CD、CSMA&#x2F;CA)、令牌传递协议"></a>介质访问控制(静态划分信道：FDM、TDM、STDM、WDM、CDM，动态划分信道：ALOH、CSMA、CSMA&#x2F;CD、CSMA&#x2F;CA)、令牌传递协议</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150228131.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150228131.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150228131"><hr><h5 id="传输数据的两种链路"><a href="#传输数据的两种链路" class="headerlink" title="传输数据的两种链路"></a>传输数据的两种链路</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150240613.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150240613.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150240613"><hr><h5 id="什么是介质访问控制？它有几种方法？"><a href="#什么是介质访问控制？它有几种方法？" class="headerlink" title="什么是介质访问控制？它有几种方法？"></a>什么是介质访问控制？它有几种方法？</h5><ul><li><strong>介质访问控制(medium access control)简称MAC。 是解决共用信道的使用产生竞争时，如何分配信道的使用权问题</strong></li><li><strong>常见的介质访问控制有下图所示几种方法：</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150306526.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150306526.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150306526"><hr><h5 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h5><p><strong>简单了解一下相关概念：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150327948.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150327948.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150327948"><ul><li><strong>信道划分的实质就是通过<code>分时、分频、分码</code>等方法把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对点信道</strong></li><li><strong>信道划分介质访问控制有一下4种方法：</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150347410.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150347410.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150347410"><hr><h6 id="频分多路复用-FDM"><a href="#频分多路复用-FDM" class="headerlink" title="频分多路复用(FDM)"></a>频分多路复用(FDM)</h6><ul><li><strong>频分多路复用（Frequency-division multiplexing，FDM），是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150405066.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150405066.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150405066"><hr><h6 id="时分多路复用-TDM"><a href="#时分多路复用-TDM" class="headerlink" title="时分多路复用(TDM)"></a>时分多路复用(TDM)</h6><ul><li><strong>时分多路复用（Time-Division Multiplexing，TDM）一种数字或者模拟（较罕见）的多路复用技术。使用这种技术，两个以上的信号或数据流可以同时在一条通信线路上传输，其表现为同一通信信道的子信道。但在物理上来看，信号还是轮流占用物理信道的</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150426795.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150426795.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150426795"><ul><li><strong>如果说TDM中，A\B\C\D四个用户，有三个用户没传输数据，则造成了信道利用率不高，于是引入了另一种方法来解决这种问题，提高信道利用率</strong></li><li><strong>这种方法交是统计时分复用STDM</strong></li><li><strong>统计时分复用（Statistical Time Division Multiplexing）是一种根据用户实际需要动态分配线路资源的时分复用方法。只有当用户有数据要传输时才给他分配线路资源，当用户暂停发送数据时，不给他分配线路资源，线路的传输能力可以被其他用户使用。采用统计时分复用时，每个用户的数据传输速率可以高于平均速率，最高可达到线路总的传输能力</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150449540.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150449540.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150449540"><ul><li><strong>这里我们假设线路传输速率为8000b&#x2F;s</strong></li><li><strong>采用TDM，则4个用户的平均速率为2000b&#x2F;s</strong></li><li><strong>采用STDM，则每个用户的最高速率可达8000b&#x2F;s</strong></li></ul><hr><h6 id="波分多路复用-WDM"><a href="#波分多路复用-WDM" class="headerlink" title="波分多路复用(WDM)"></a>波分多路复用(WDM)</h6><ul><li><strong>波分复用技术（wavelength-division multiplexing, WDM）</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150525164.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150525164.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150525164"><hr><h6 id="码分多路复用-CDM"><a href="#码分多路复用-CDM" class="headerlink" title="码分多路复用(CDM)"></a>码分多路复用(CDM)</h6><p><strong>码分多路复用是采用不同的编码来区分各路原始信号的一-种复用方式。与FDM和TDM不同,它既共享信道的频率，又共享时间。下面举一个 直观的例子来理解码分复用，如下图所示：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150548026.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150548026.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150548026"><blockquote><ul><li><strong>假设 A 站要向 C 站运输黄豆， B 站要向 C 站运输绿豆， A 与 C 、 B 与 C 之间有一条公共的道路，可以类比为广播信道</strong></li><li><strong>在频分复用方式下，公共道路被划分为两个车道，分别提供给 A 到 C 的车和 B 到 C 的车行走，两类车可以同时行走，但只分到了公共车道的一半，因此频分复用（波分复用也一样）共享时间而不共享空间</strong></li><li><strong>在时分复用方式下，先让 A 到 C 的车走一趟，再让 B 到 C 的车走一趟，两类车交替地占用公共车道。公共车道没有划分，因此两车共享了空间，但不共享时间</strong></li><li><strong>码分复用与另外两种信道划分方式大为不同，在码分复用情况下，黄豆与绿豆放在同一辆车上运送，到达 C 后，由 C 站负责把车上的黄豆和绿豆分开</strong></li><li><strong>因此，黄豆和绿豆的运送，在码分复用的情况下，既共享了空间，也共享了时间</strong></li></ul></blockquote><ul><li><strong><code>码分多址（ code oivision Multiple Access , CDMA ）</code>是码分复用的一种方式，其原理是<code>每比特时间</code>被分成 m 个更短的时间槽，称为码片（ ChiP ) ，通常情况下每比特有 64 或 128 个码片。<code>每个站点被指定一个唯一的 m 位代码或码片序列</code></strong></li><li><strong>发送 1时，站点发送<code>mbit码片序列</code>；发送<code>0</code> 时，站点发送<code>mbit码片序列的反码</code></strong></li><li><strong>当两个或多个站点同时发送时，各路数据在信道中<code>线性相加</code></strong></li><li><strong>为从信道中分离出各路信号，要求各个站点的码片序列<code>相互正交</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150802509.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150802509.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150802509"><ul><li><strong>简单理解就是， A 站向 C 站发出的信号用一个向量来表示， B 站向 C 站发出的信号用另一个向量来表示，两个向量要求相互正交。<code>向量中的分量，就是所谓的码片</code></strong></li><li><strong>&#x3D;&#x3D;举个例子计算加深理解：&#x3D;&#x3D;</strong></li><li><strong>假如站点 A 的码片序列被指定为 000 110 11 ，则 A 站发送 000 110 11 就表示发送比特 1 ，发送111 001 00 就表示发送比特 0</strong> </li><li><strong>按惯例将码片序列中的 0 写为-l ，将 1 写为＋ l , A 站的码片序列就是<code>-l - l -l + l + l -l + l + l</code></strong></li><li><strong>令向量 <code>S</code> 表示 A 站的码片向量，令 T 表示 B 站的码片向量</strong></li><li><strong>两个不同站的码片序列正交，且向量 S 和 T 的规格化内积为(S*T)&#x2F;8&#x3D; 0 ,所以令向量 T 为<code>- l - l + l -1 + l + l + l - 1</code></strong></li><li><strong>S和T具有以下运算性质：</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150909119.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109150909119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109150909119"><ul><li><strong>当 A 站向 C 站发送数据 l 时，就发送了向量 &#96;&#96;-l ,-l ,-l ,+l,+l,-l,+l,+l&#96;</strong></li><li><strong>当 B 站向 C 站发送数据 0 时，就发送 T 向量<code>+l, +l, -1 ,+1, -l ,-l ,-l ,+1</code></strong></li><li><strong>两个向量到了公共信道上就进行叠加，实际上就是线性相加，得到 <code>S + T = ( 0 0 -2 2 0 -2 0 2 )</code></strong></li><li><strong>到达 C 站后，进行数据分离。如果要得到来自 A 站的数据，那么就让 S 与 S + T 进行规格化内积，得到 S·( S +T ) &#x3D; l 所以 A 站发出的数据是 1</strong> </li><li><strong>同理，如果要得到来自 B 站的数据，那么 T . ( S + T ) ＝- 1 因此从 B 站发送过来的信号向量是一个反码向量，代表 0</strong></li></ul><blockquote><p><strong>什么是规格化内积：就是内积结果再除以向量的维数，如向量s（1，2，3）点乘向量t（7，8，9）的规格化内积为（1<em>7+2</em>8+3*9）&#x2F; 3 &#x3D; 50 &#x2F; 3</strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151025464.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151025464.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151025464"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151053371.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151053371.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151053371"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151112403.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151112403.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151112403"><hr><h5 id="动态划分信道"><a href="#动态划分信道" class="headerlink" title="动态划分信道"></a>动态划分信道</h5><ul><li><strong>动态划分信道分为：随机访问介质访问控制、轮询访问介质访问控制</strong></li><li><strong>特点：信道并非在用户通信时固定分配给用户</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151144026.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151144026.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151144026"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151222879.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151222879.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151222879"><hr><h6 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h6><p><strong>ALOHA协议是由美国夏威夷大学开发的一种网络协议。处于OSI模型中的数据链路层。它属于随机存取协议（Random Access Protocol）中的一种。它分为<code>纯ALOHA协议和分段ALOHA协议</code>（或时隙ALOHA协议）</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151340271.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151340271.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151340271"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151349121.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151349121.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151349121"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151354526.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151354526.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151354526"><hr><h6 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h6><p><strong>全称Carrier Sense Multiple Access (CSMA)，是一种允许多个设备在同一信道发送信号的协议，其中的设备监听其它设备是否忙碌，只有在线路空闲时才发送</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151410887.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151410887.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151410887"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151419578.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151419578.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151419578"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151427511.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151427511.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151427511"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151434534.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151434534.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151434534"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151442367.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151442367.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151442367"><hr><h6 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151453203.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151453203.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151453203"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151504015.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151504015.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151504015"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151511458.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151511458.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151511458"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151518336.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151518336.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151518336"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151526259.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151526259.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151526259"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151532921.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151532921.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151532921"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151539867.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151539867.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151539867"><hr><h6 id="CSMA-x2F-CA协议"><a href="#CSMA-x2F-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151548540.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151548540.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151548540"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151558181.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151558181.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151558181"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151604528.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151604528.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151604528"><hr><h6 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151631569.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151631569.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151631569"><p><strong>从主节点向从节点发送的报文信息可以看出，如果一个节点要发送的数据很多，它不会一直发送到结束，它发送到最大数据帧就是结束，主节点开始轮询下一个节点，等再次轮询到它时才能继续发送。即如果从节点要发送的数据很多时，它不是一次性发送结束的</strong></p><hr><h6 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151659127.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151659127.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151659127"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/20200321195854637.gif" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/20200321195854637.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20200321195854637"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151728628.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151728628.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151728628"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151749360-1688129613537-205.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109151749360-1688129613537-205.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109151749360"><hr><h3 id="第六节：局域网"><a href="#第六节：局域网" class="headerlink" title="第六节：局域网"></a>第六节：局域网</h3><h4 id="局域网-以太网与IEEE-802-3、IEEE-802-11"><a href="#局域网-以太网与IEEE-802-3、IEEE-802-11" class="headerlink" title="局域网(以太网与IEEE 802.3、IEEE 802.11)"></a>局域网(以太网与IEEE 802.3、IEEE 802.11)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/20200322150409577.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/20200322150409577.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20200322150409577"><hr><h5 id="局域网的基本概念与体系结构"><a href="#局域网的基本概念与体系结构" class="headerlink" title="局域网的基本概念与体系结构"></a>局域网的基本概念与体系结构</h5><h6 id="局域网的概念及特点"><a href="#局域网的概念及特点" class="headerlink" title="局域网的概念及特点"></a>局域网的概念及特点</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153214243.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153214243.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153214243"><hr><h6 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153229579.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153229579.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153229579"><hr><h6 id="局域网传输介质"><a href="#局域网传输介质" class="headerlink" title="局域网传输介质"></a>局域网传输介质</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153246058.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153246058.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153246058"><hr><h6 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153306749.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153306749.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153306749"><hr><h6 id="局域网分类"><a href="#局域网分类" class="headerlink" title="局域网分类"></a>局域网分类</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153324594.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153324594.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153324594"><hr><h6 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153358640.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153358640.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153358640"><hr><h6 id="MAC子层与LLC子层"><a href="#MAC子层与LLC子层" class="headerlink" title="MAC子层与LLC子层"></a>MAC子层与LLC子层</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153441387.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153441387.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153441387"><hr><h5 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h5><h6 id="以太网概述"><a href="#以太网概述" class="headerlink" title="以太网概述"></a>以太网概述</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153457803.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153457803.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153457803"><hr><h6 id="以太网提供无连接、不可靠的服务"><a href="#以太网提供无连接、不可靠的服务" class="headerlink" title="以太网提供无连接、不可靠的服务"></a>以太网提供无连接、不可靠的服务</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153517597.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153517597.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153517597"><hr><h6 id="传输介质及拓扑结构"><a href="#传输介质及拓扑结构" class="headerlink" title="传输介质及拓扑结构"></a>传输介质及拓扑结构</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153541674.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153541674.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153541674"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153550189.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153550189.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153550189"><hr><h6 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a>10BASE-T以太网</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153604442.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153604442.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153604442"><hr><h6 id="适配器和MAC地址"><a href="#适配器和MAC地址" class="headerlink" title="适配器和MAC地址"></a>适配器和MAC地址</h6><ul><li><strong>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板[又称网络适配器(Adapter)</strong></li><li><strong>或网络接口卡(Network Interface Card, NIC)]实现的</strong></li><li><strong>网卡上装有处理器和存储器，是工作在数据链路层的网路组件</strong></li><li><strong>网卡是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153638724.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153638724.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153638724"><ul><li><strong>查MAC地址和生产厂家的网址：[查询入口](<a href="https://services10.ieee.org/as/authorization.oauth2?response_type=code&client_id=PF_AS_FOR_PA&redirect_uri=https://regauth.standards.ieee.org/pa/oidc/cb&state=eyJ6aXAiOiJERUYiLCJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2Iiwia2lkIjoiMWciLCJzdWZmaXgiOiJ4bjBxZGsuMTU4NTEwOTAyNyJ9..1wvwJEQmk8zlyDCR6xzv6w.4jExyuOMs6Qt6INrQ61yqGfXc77esIdhQMP6kBUmViDe_NJ70wE2p-Ykyj4pVbu8vUhr0MzQfnj5jbvte4h9YASnmq7aYeF36FrxZms5LhZacVFFQHEM-h8Ho2f9ifBv.uTdQGk0Q85lSvqiw0jzMog&nonce=Y04fmIFEkItAQV0USU5v87Ji2921ig3fJQlrbErN-5Q&scope=openid">https://services10.ieee.org/as/authorization.oauth2?response_type=code&amp;client_id=PF_AS_FOR_PA&amp;redirect_uri=https%3A%2F%2Fregauth.standards.ieee.org%2Fpa%2Foidc%2Fcb&amp;state=eyJ6aXAiOiJERUYiLCJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2Iiwia2lkIjoiMWciLCJzdWZmaXgiOiJ4bjBxZGsuMTU4NTEwOTAyNyJ9..1wvwJEQmk8zlyDCR6xzv6w.4jExyuOMs6Qt6INrQ61yqGfXc77esIdhQMP6kBUmViDe_NJ70wE2p-Ykyj4pVbu8vUhr0MzQfnj5jbvte4h9YASnmq7aYeF36FrxZms5LhZacVFFQHEM-h8Ho2f9ifBv.uTdQGk0Q85lSvqiw0jzMog&amp;nonce=Y04fmIFEkItAQV0USU5v87Ji2921ig3fJQlrbErN-5Q&amp;scope=openid</a> profile address email phone&amp;vnd_pi_requested_resource&#x3D;https%3A%2F%2Fregauth.standards.ieee.org%2Fstandards-ra-web%2F%20pub%2Fview.html&amp;vnd_pi_application_name&#x3D;RegAuth)</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153723469.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153723469.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153723469"><hr><h6 id="以太网DIX-Ethernet-V2标准的MAC帧的格式"><a href="#以太网DIX-Ethernet-V2标准的MAC帧的格式" class="headerlink" title="以太网DIX Ethernet V2标准的MAC帧的格式"></a>以太网DIX Ethernet V2标准的MAC帧的格式</h6><ul><li><strong>前同步码：其功能是使接收器建立比特同步。编码形式为多个“1”或“0”交替构成的二进制序列,最后一比特为“0”。在这种编码形式下，经过曼彻斯特编码后为一周期性方波</strong></li><li><strong>帧开始界符(sfd)：该字段的功能是指示一帧的开始</strong></li><li><strong>目的地址和源地址：</strong><ul><li><strong>目的地址字段用来指出帧要发住的工作站</strong></li><li><strong>源地址段指示发送该帧的工作站地址</strong></li></ul></li><li><strong>类型指明了上层所有的协议是什么</strong></li><li><strong>帧检验序列(FCS)处于帧的最后，其长度为32比特，用于检验帧在传输过程中有无差错</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153810312.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153810312.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153810312"><hr><h6 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153822351.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153822351.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153822351"><hr><h5 id="无线局域网IEEE-802-11"><a href="#无线局域网IEEE-802-11" class="headerlink" title="无线局域网IEEE 802.11"></a>无线局域网IEEE 802.11</h5><h6 id="IEEE-802-11标准简介"><a href="#IEEE-802-11标准简介" class="headerlink" title="IEEE 802.11标准简介"></a>IEEE 802.11标准简介</h6><ul><li><strong>IEEE 802.11是无线局域网的一系列协议标准，它们制定了MAC层协议，运行在多个物理层标准上。除基本的协调访问问题外，标准还进行错误控制(以克服通道固有的不可靠性)、适宜的寻址和关联规程(以处理站的可携带性和移动性)、互联过程(以扩展无线站的通信范围)，并且允许用户在移动的同时进行通信</strong></li><li><strong>802.11的MAC层采用CSMA&#x2F;CA协议进行介质访问控制。冲突避免要求每个发送结点在发送帧之前先侦听信道。如果信道空闲，那么结点可以发送帧;发送站在发送完一-帧之后，必须再等待一个短的时间间隔，检查接收站是否发回帧的确认ACK。如果接收到确认，那么说明此次发送未出现冲突，发送成功;如果在规定的时间内没有接收到确认，那么表明出现冲突,发送失败，重发该帧，直到在规定的最大重发次数之内，发送成功</strong></li><li><strong>注意:在无线局域网中，即使在发送过程中发生了碰撞，也要把整个帧发送完毕。而在有线局域网中，发生冲突则结点立即停止发送数据。要熟悉局域网的各种协议</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153922954.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153922954.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153922954"><hr><h6 id="IEEE-802-11的MAC帧头格式"><a href="#IEEE-802-11的MAC帧头格式" class="headerlink" title="IEEE 802.11的MAC帧头格式"></a>IEEE 802.11的MAC帧头格式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153953596.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109153953596.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109153953596"><ul><li><strong>几种不同功能的帧头格式</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154008922.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154008922.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154008922"><hr><h6 id="无线局域网的分类"><a href="#无线局域网的分类" class="headerlink" title="无线局域网的分类"></a>无线局域网的分类</h6><p><strong>无线局域网分为两类：有固定基础设施无线局域网、无固定基础设施无线局域网的自组织网络</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154023909.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154023909.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154023909"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154151985.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154151985.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154151985"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154200336-1688129730748-229.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154200336-1688129730748-229.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154200336"><hr><h3 id="第七节：广域网"><a href="#第七节：广域网" class="headerlink" title="第七节：广域网"></a>第七节：广域网</h3><h4 id="广域网-PPP协议、HDLC协议"><a href="#广域网-PPP协议、HDLC协议" class="headerlink" title="广域网(PPP协议、HDLC协议)"></a>广域网(PPP协议、HDLC协议)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154512572.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154512572.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154512572"><hr><h5 id="广域网的概念"><a href="#广域网的概念" class="headerlink" title="广域网的概念"></a>广域网的概念</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154522685.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154522685.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154522685"><ul><li><strong>广域网与局域网的区别与联系</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154537326.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154537326.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154537326"><hr><h5 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h5><h6 id="PPP简介及特点"><a href="#PPP简介及特点" class="headerlink" title="PPP简介及特点"></a>PPP简介及特点</h6><p><strong><code>点到点协议（Point to Point Protocol，PPP）</code>是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。 这种链路提供<code>全双工操作</code>，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案</strong></p><hr><h6 id="PPP功能"><a href="#PPP功能" class="headerlink" title="PPP功能"></a>PPP功能</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154630927.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154630927.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154630927"><hr><h6 id="PPP的三个组成部分"><a href="#PPP的三个组成部分" class="headerlink" title="PPP的三个组成部分"></a>PPP的三个组成部分</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154640495.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154640495.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154640495"><hr><h6 id="PPP状态图"><a href="#PPP状态图" class="headerlink" title="PPP状态图"></a>PPP状态图</h6><ul><li><strong>当线路处于静止状态时，不存在物理层连接</strong></li><li><strong>当线路检测到载波信号时，建立物理连接，线路变为建立状态。此时，LCP 开始选项商定，商定成功后就进入身份验证状态</strong></li><li><strong>双发身份验证通过后，进入网络状态。这时，采用NCP配置网络层，配置成功后，进入打开状态，然后就可进行数据传输</strong></li><li><strong>当数据传输完成后，线路转为终止状态。载波停止后则回到静止状态</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154704933.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154704933.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154704933"><hr><h6 id="PPP帧协议的帧格式"><a href="#PPP帧协议的帧格式" class="headerlink" title="PPP帧协议的帧格式"></a>PPP帧协议的帧格式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154713473.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154713473.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154713473"><hr><h5 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h5><h6 id="HDLC简介及特点"><a href="#HDLC简介及特点" class="headerlink" title="HDLC简介及特点"></a>HDLC简介及特点</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154722861.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154722861.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154722861"><hr><h6 id="HDLC的两种配置"><a href="#HDLC的两种配置" class="headerlink" title="HDLC的两种配置"></a>HDLC的两种配置</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154731044.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154731044.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154731044"><hr><h6 id="HDLC的三种站"><a href="#HDLC的三种站" class="headerlink" title="HDLC的三种站"></a>HDLC的三种站</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154740400.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154740400.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154740400"><hr><h6 id="HDLC的三种数据操作方式"><a href="#HDLC的三种数据操作方式" class="headerlink" title="HDLC的三种数据操作方式"></a>HDLC的三种数据操作方式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154749729.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154749729.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154749729"><hr><h6 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154803343.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154803343.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154803343"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154810972.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154810972.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154810972"><hr><h5 id="HDLC与PPP的异同"><a href="#HDLC与PPP的异同" class="headerlink" title="HDLC与PPP的异同"></a>HDLC与PPP的异同</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154834544-1688129890841-244.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109154834544-1688129890841-244.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109154834544"><hr><h3 id="第八节：数据链路层设备"><a href="#第八节：数据链路层设备" class="headerlink" title="第八节：数据链路层设备"></a>第八节：数据链路层设备</h3><h4 id="数据链路层设备-网桥、交换机"><a href="#数据链路层设备-网桥、交换机" class="headerlink" title="数据链路层设备(网桥、交换机)"></a>数据链路层设备(网桥、交换机)</h4><h5 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h5><ul><li><strong>首先我们了解一下<code>冲突域和广播域</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155133077.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155133077.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155133077"><hr><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><ul><li><strong>两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就称为一个网段</strong></li><li><strong>网桥工作在链路层的MAC子层，可以使以太网各网段成为隔离开的碰撞域</strong></li><li><strong>如果把网桥换成工作在物理层的转发器，那么就没有这种过滤通信量的功能</strong></li><li><strong>由于各网段相对独立，因此一个网段的故障不会影响到另一个网段的运行</strong></li></ul><p><strong>注意:网桥处理数据的对象是帧，所以它是工作在数据链路层的设备，中继器、放大器处理数据的对象是信号，所以它是工作在物理层的设备</strong></p><hr><h6 id="网桥信息处理方式"><a href="#网桥信息处理方式" class="headerlink" title="网桥信息处理方式"></a>网桥信息处理方式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155214435.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155214435.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155214435"><hr><h6 id="网桥的吞吐量举例"><a href="#网桥的吞吐量举例" class="headerlink" title="网桥的吞吐量举例"></a>网桥的吞吐量举例</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155222282.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155222282.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155222282"><hr><h6 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155244096.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155244096.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155244096"><hr><h6 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155252998.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155252998.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155252998"><p><strong>网桥必须具有路径选择的功能，接收到帧后，要决定正确的路径，将该帧转送到相应的目的局域网站点。根据路径选择算法的不同，可将网桥分为<code>透明网桥和源路由网桥</code></strong></p><hr><h6 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h6><ul><li><strong>透明网桥以混杂方式工作，它接收与之连接的所有LAN传送的每一帧</strong></li><li><strong>到达帧的路由选择过程取决于源LAN和目的LAN</strong></li><li><strong>①如果源LAN和目的LAN相同,那么丢弃该帧</strong></li><li><strong>②如果源LAN和目的LAN不同，那么转发该帧</strong></li><li><strong>③如果目的LAN未知，那么扩散该帧</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155340725.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155340725.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155340725"><hr><h6 id="源路由网桥-选择最佳路由"><a href="#源路由网桥-选择最佳路由" class="headerlink" title="源路由网桥(选择最佳路由)"></a>源路由网桥(选择最佳路由)</h6><ul><li><strong>在源路由网桥中，路由选择由发送数据帧的源站负责，网桥只根据数据真正的路由信息对帧进行接收和转发</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155359734.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155359734.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155359734"><hr><h5 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h5><h6 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155411384.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155411384.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155411384"><hr><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><ul><li><strong>以太网交换机的原理是，它检测从以太端口来的数据帧的源和目的地的MAC(介质访问层)地址，然后与系统内部的动态查找表进行比较，若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口</strong></li></ul><hr><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155429734.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155429734.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155429734"><hr><h6 id="两种交换模式"><a href="#两种交换模式" class="headerlink" title="两种交换模式"></a>两种交换模式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155437151-1688130030616-255.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155437151-1688130030616-255.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155437151"><hr><h2 id="第四章：网络层"><a href="#第四章：网络层" class="headerlink" title="第四章：网络层"></a>第四章：网络层</h2><h3 id="第一节：网络层的功能"><a href="#第一节：网络层的功能" class="headerlink" title="第一节：网络层的功能"></a>第一节：网络层的功能</h3><h4 id="1-网络层的功能-路由选择与分组转发、异构网络互联、拥塞控制"><a href="#1-网络层的功能-路由选择与分组转发、异构网络互联、拥塞控制" class="headerlink" title="1.网络层的功能(路由选择与分组转发、异构网络互联、拥塞控制)"></a>1.网络层的功能(路由选择与分组转发、异构网络互联、拥塞控制)</h4><h5 id="主要任务与传输单位"><a href="#主要任务与传输单位" class="headerlink" title="主要任务与传输单位"></a>主要任务与传输单位</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160258209.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160258209.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109160258209"><hr><h5 id="路由选择与分组转发"><a href="#路由选择与分组转发" class="headerlink" title="路由选择与分组转发"></a>路由选择与分组转发</h5><p><strong>路由器主要完成两个功能:是<code>路由选择 (确定哪一 条路径)</code>，二是<code>分组转发 (当一个分组 到达时所采取的动作)</code></strong></p><ul><li><strong>路由选择：指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由</strong></li><li><strong>分组转发：指路由器根据转发表将用户的IP数据报从合适的端口转发出去</strong></li></ul><p><strong><code>路由表</code>是根据<code>路由选择算法</code>得出的，而<code>转发表</code>是从<code>路由表</code>得出的</strong><br><strong><code>路由表</code>则需要对<code>网络拓扑变化的计算最优化</code>,<code>转发表</code>的结构应当使<code>查找过程最优化</code></strong><br><strong>在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160405240.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160405240.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109160405240"><hr><h5 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h5><p><strong>所谓<code>异构网络互联</code>，是指将两个以上的不同的计算机网络，通过一定的方法， 用一种或多种通信处理设备(即中间设备)相互连接起来，以构成更大的网络系统。中间设备又称<code>中间系统</code>或<code>中继系统</code></strong></p><ul><li><p><strong>根据所在的层次，<code>中继系统</code>分为以下4种：</strong></p><ul><li><p><strong>&#x3D;&#x3D;物理层中继系统&#x3D;&#x3D;：<code>中继器，集线器(Hub)</code></strong></p></li><li><p><strong>&#x3D;&#x3D;数据链路层中继系统&#x3D;&#x3D;：<code>网桥或交换机</code></strong></p></li><li><p><strong>&#x3D;&#x3D;网络层中继系统&#x3D;&#x3D;：<code>路由器</code></strong></p></li><li><p><strong>&#x3D;&#x3D;网络层以上的中继系统&#x3D;&#x3D;：<code>网关</code></strong></p></li></ul></li></ul><p><strong><code>网络互联</code>通常是指用<code>路由器</code>进行网络互联和路由选择</strong><br><strong><code>路由器</code>是一一台专用计算机，用于在互联网中进行路由选择</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160612702.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160612702.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109160612702"><hr><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><ul><li><p><strong>在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞</strong></p></li><li><p><strong>判断网络是否进入拥塞状态的方法是，观察网络的吞吐量与网络负载的关系:如果随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量，那么网络就可能已进入“轻度拥塞”状态;如果网络的负载继续增大，而网络的吞吐量下降到零，那么网络就可能已进入死锁状态</strong></p></li><li><p><strong>拥塞控制的作用是确保子网能够承载所达到的流量，这是一一个全局性的过程，涉及各方面的行为:主机、路由器及路由器内部的转发处理过程等。单一地增加资源并不能解决拥塞</strong></p></li><li><p><strong>流量控制和拥塞控制的区别:</strong></p><ul><li><p><strong>流量控制往往是指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收</strong></p></li><li><p><strong>拥塞控制必须确保通信子网能够传送待传送的数据，是一一个全局性的问题，涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素</strong></p></li></ul></li></ul><p><strong>&#x3D;&#x3D;拥塞控制的方法有两种&#x3D;&#x3D;：</strong></p><ul><li><p><strong>开环控制。在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。这是一种静态的预防方法。一旦整个系统启动并运行，中途就不再需要修改。开环控制手段包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度决策等。所有这些手段的共性是，在做决定时不考虑当前网络的状态</strong></p></li><li><p><strong>闭环控制。事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。闭环控制是基于反馈环路的概念，是一种动态的方法</strong></p></li></ul><hr><h4 id="2-电路交换、报文交换、分组交换"><a href="#2-电路交换、报文交换、分组交换" class="headerlink" title="2.电路交换、报文交换、分组交换"></a>2.电路交换、报文交换、分组交换</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155821117.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109155821117.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109155821117"><hr><h5 id="几种传输单元名词解析"><a href="#几种传输单元名词解析" class="headerlink" title="几种传输单元名词解析"></a>几种传输单元名词解析</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160846555.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160846555.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109160846555"><p><strong>这里探讨的电路交换、报文交换、分组交换，我们可以把这三种交换方式的交换数据单位看成一个整体去理解，不要过分去细究以上几种传输单元名词与这三种交换方式的关系</strong></p><hr><h5 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160909259.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109160909259.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109160909259"><ul><li><p><strong>在进行数据传输前，两个结点之间必须先建立一条专用 (双方独占)的物理通信路径(由通信双方之间的交换设备和链路逐段连接而成)，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束后才被释放</strong></p></li><li><p><strong>因此，电路交换技术分为三个阶段：<code>连接建立、数据传输和连接释放</code></strong></p></li><li><p><strong>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是，在数据传输的过程中，<code>用户始终占用端到端</code></strong></p></li><li><p><strong><code>电路交换技术的优点如下</code>:</strong></p><ul><li><strong>通信时延小。由于通信线路为通信双方用户专用，数据直达，因此传输数据的时延非常小。当传输的数据量较大时，这-优点非常明显</strong></li><li><strong>有序传输。双方通信时按发送顺序传送数据，不存在失序问题</strong></li><li><strong>没有冲突。不同的通信双方拥有不同的信道，不会出现争用物理信道的问题</strong></li><li><strong>适用范围广。电路交换既适用于传输模拟信号，又适用于传输数字信号</strong></li><li><strong>实时性强。通信双方之间的物理通路一旦建立， 双方就可以随时通信</strong></li><li><strong>控制简单。电路交换的交换设备(交换机等)及控制均较简单</strong></li></ul></li><li><p><strong><code>电路交换技术的缺点如下</code>:</strong></p><ul><li><strong>建立连接时间长。电路交换的平均连接建立时间对计算机通信来说太长</strong></li><li><strong>线路独占，使用效率低。电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用率低</strong></li><li><strong>灵活性差。只要在通信双方建立的通路中的任何一点出了故障，就必须重新拨号建立新的连接，这对十分紧急和重要的通信是很不利的</strong></li><li><strong>难以规格化。电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制</strong></li></ul></li><li><p><strong>注意，电路建立后，除源结点和目的结点外，电路上的任何结点都采取<code>“直通方式”</code>接收数据和发送数据，即不会存在存储转发所耗费的时间</strong></p></li></ul><hr><h5 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161140106.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161140106.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161140106"><ul><li><p><strong>数据交换的单位是报文，报文携带有源地址，目标地址，数据等信息</strong></p></li><li><p><strong><code>报文交换的主要特点是</code>：存储接受到的报文，判断其目标地址以选择路由，最后，在下一跳路由空闲时，将数据转发给下一跳路由。 中文名报文交换，外文名Message switching</strong></p></li><li><p><strong>报文交换技术的优点如下:</strong></p><ul><li><strong>无须建立连接。报文交换不需要为通信双方预先建立一条专用的通信线路，不存在建立连接时延，用户可以随时发送报文</strong></li><li><strong>动态分配线路。当发送方把报文交给交换设备时，交换设备先存储整个报文，然后选择一条合适的空闲线路，将报文发送出去</strong></li><li><strong>提高线路可靠性。如果某条传输路径发生故障，那么可重新选择另一条路径传输数据，因此提高了传输的可靠性</strong></li><li><strong>提高线路利用率。通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通道，因而大大提高了通信线路的利用率</strong></li><li><strong>提供多目标服务。一个报文可以同时发送给多个目的地址，这在电路交换中是很难实现的</strong></li></ul></li><li><p><strong>报文交换技术的<code>缺点</code>如下:</strong></p><ul><li><strong>由于数据进入交换结点后要经历存储、转发这一过程，因此会引起<code>转发时延</code>(包括接收报文、检验正确性、排队、发送时间等)</strong></li><li><strong>报文交换对报文的大小没有限制，这就要求<code>网络结点需要有较大的缓存空间</code></strong></li></ul></li><li><p><strong>注意:报文交换主要使用在早期的电报通信网中，现在较少使用，通常被较先进的分组交换方式所取代</strong></p></li></ul><hr><h5 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161538575.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161538575.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161538575"><ul><li><p><strong>同报文交换一样，分组交换也采用存储转发方式，但解决了报文交换中大报文传输的问题。分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小数据块，再加上一些必要的控制信息(如源地址、目的地址和编号信息等)，构成分组(Packet)。 网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一个结点，直到到达目的结点。到达目地之后的数据分组再重新组合起来，形成一条完整的数据</strong></p></li><li><p><strong>分组交换的<code>优点</code>如下:</strong></p><ul><li><strong>无建立时延。不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组</strong></li><li><strong>线路利用率高。通信双方不是固定占有- -条通信线路，而是在不同的时间一-段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率</strong></li><li><strong>简化了存储管理(相对于报文交换)。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易</strong></li><li><strong>加速传输。分组是逐个传输的，可以使后-一个分组的存储操作与前一一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外，传输一个分组所 需的缓冲区比传输一次报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的概率及时间也必然少得多</strong></li><li><strong>减少了出错概率和重发数据量。因为分组较短，其出错概率必然减小，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延</strong></li></ul></li><li><p><strong>分组交换的<code>缺点</code>如下:</strong></p><ul><li><strong>存在传输时延。尽管分组交换比报文交换的传输时延少，但相对于电路交换仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力</strong></li><li><strong>需要传输额外的信息量。每个小数据块都要加上源地址、目的地址和分组编号等信息，从而构成分组，因此使得传送的信息量增大了5%~10%，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加</strong></li><li><strong>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程</strong></li></ul></li><li><p><strong>分组交换<code>根据其</code>通信子网向端点系统提供的服务<code>，还可进一步分为</code>面向连接的虚电路<code>方式和 </code>无连接的数据报方式<code>。这两种服务方式都由网络层提供。要注意</code>数据报方式<code>和</code>虚电路方式<code>是</code>分组 交换的两种方式</strong></p></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161735092.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161735092.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161735092"><hr><h6 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161751643.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161751643.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161751643"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161804817.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161804817.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161804817"><hr><h6 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161815805.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161815805.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161815805"><ul><li><strong>在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的<code>虚电路号</code>分配给该虛电路，以区别于本系统中的其他虚电路。在传送数据时，<code>每个数据分组不仅要有分组号、校验和等控制信息，还要有它要通过的虚电路号</code>，以区别于其他虚电路上的分组。在虚电路网络中的每个结点上都维持–张<code>虚电路表</code>，表中的每项记录了一个打开的虚电路的信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。<code>数据的传输是双向进行的</code>，上述信息是在虚电路的建立过程中确定的</strong></li><li><strong><code>虚电路之所以是“虚”的，是因为这条电路不是专用的</code>，每个结点到其他结点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每条虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161935840.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161935840.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161935840"><hr><h6 id="数据报服务和虚电路服务的比较"><a href="#数据报服务和虚电路服务的比较" class="headerlink" title="数据报服务和虚电路服务的比较"></a>数据报服务和虚电路服务的比较</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161944781.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161944781.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161944781"><hr><h5 id="报文交换与分组交换的实践消耗比较"><a href="#报文交换与分组交换的实践消耗比较" class="headerlink" title="报文交换与分组交换的实践消耗比较"></a>报文交换与分组交换的实践消耗比较</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161956402.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109161956402.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109161956402"><hr><h5 id="电路交换、报文交换、分组交换的交换方式比较"><a href="#电路交换、报文交换、分组交换的交换方式比较" class="headerlink" title="电路交换、报文交换、分组交换的交换方式比较"></a>电路交换、报文交换、分组交换的交换方式比较</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162005619-1688130451430-272.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162005619-1688130451430-272.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109162005619"><hr><h3 id="第二节：路由算法与路由协议概述"><a href="#第二节：路由算法与路由协议概述" class="headerlink" title="第二节：路由算法与路由协议概述"></a>第二节：路由算法与路由协议概述</h3><h4 id="路由算法与路由协议概述-静态路由和动态路由、向量路由算法、链路状态路由算法、层次路由"><a href="#路由算法与路由协议概述-静态路由和动态路由、向量路由算法、链路状态路由算法、层次路由" class="headerlink" title="路由算法与路由协议概述(静态路由和动态路由、向量路由算法、链路状态路由算法、层次路由)"></a>路由算法与路由协议概述(静态路由和动态路由、向量路由算法、链路状态路由算法、层次路由)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162415864.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162415864.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109162415864"><hr><h5 id="路由算法分类与路由表"><a href="#路由算法分类与路由表" class="headerlink" title="路由算法分类与路由表"></a>路由算法分类与路由表</h5><ul><li><strong>路由器转发分组<code>是通过</code>路由表<code>转发的，而</code>路由表<code>是通过</code>各种算法<code>得到的。从能否随网络的通信量或拓扑自适应地进行调整变化来划分，</code>路由算法<code>可分为两大类：</code>静态路由与动态路由</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162456283.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162456283.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109162456283"><hr><h5 id="静态路由和动态路由"><a href="#静态路由和动态路由" class="headerlink" title="静态路由和动态路由"></a>静态路由和动态路由</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162504417.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162504417.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109162504417"><hr><h5 id="动态路由的两种算法：链路状态路由算法和距离向量路由算法"><a href="#动态路由的两种算法：链路状态路由算法和距离向量路由算法" class="headerlink" title="动态路由的两种算法：链路状态路由算法和距离向量路由算法"></a>动态路由的两种算法：链路状态路由算法和距离向量路由算法</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162511553.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162511553.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109162511553"><ul><li><strong>链路状态路由算法和距离向量路由算法的<code>比较</code></strong></li><li><strong><code>在距离-向量路由算法中</code>，每个结点仅与它的<code>直接邻居</code>交谈，它为它的邻居提供从自己到网络中所有其他结点的最低费用估计</strong></li><li><strong><code>在链路状态路由算法中</code>，每个结点通过<code>广播</code>的方式与所有<code>其他结点</code>交谈，但它仅告诉它们与它直接相连的链路的费用</strong></li><li><strong>相较之下，距离-向量路由算法有可能遇到路由环路等问题</strong></li></ul><hr><h5 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162606713.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162606713.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109162606713"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162616465-1688130570655-279.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109162616465-1688130570655-279.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109162616465"><hr><h3 id="第三节：IPv4"><a href="#第三节：IPv4" class="headerlink" title="第三节：IPv4"></a>第三节：IPv4</h3><h4 id="IPv4-IPv4分组、IPv4地址、NAT、子网划分与子网掩码、CIDR、ARP协议、DHCP、ICMP"><a href="#IPv4-IPv4分组、IPv4地址、NAT、子网划分与子网掩码、CIDR、ARP协议、DHCP、ICMP" class="headerlink" title="IPv4(IPv4分组、IPv4地址、NAT、子网划分与子网掩码、CIDR、ARP协议、DHCP、ICMP)"></a>IPv4(IPv4分组、IPv4地址、NAT、子网划分与子网掩码、CIDR、ARP协议、DHCP、ICMP)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/20200329192257281.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/20200329192257281.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20200329192257281"><hr><h5 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h5><p><strong>&#x3D;&#x3D;首先我们了解一下IP在TCP&#x2F;IP中的位置&#x3D;&#x3D;</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163149982.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163149982.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163149982"><hr><h5 id="IPv4分组"><a href="#IPv4分组" class="headerlink" title="IPv4分组"></a>IPv4分组</h5><ul><li><strong>网络层将传输层的数据打包后，如果数据很小，可以称为IP数据报，如果数据过大则进行分片，每一片称为IPv4分组。一般数据都比较多，大部分情况都是分组</strong></li></ul><h6 id="IPv4分组格式"><a href="#IPv4分组格式" class="headerlink" title="IPv4分组格式"></a>IPv4分组格式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163212652.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163212652.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163212652"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163225479.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163225479.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163225479"><p><strong>IP首部的部分重要字段含义如下:</strong></p><blockquote><ul><li><strong><code>版本。占4位</code>。指IP的版本，目前广泛使用的版本号为4</strong></li><li><strong><code>首部长度。占4位</code>。以4B为单位，最大值为60B (15*4B)。最常用的首部长度是20B,此时不使用任何选项(即可选字段)</strong></li><li><strong><code>总长度。占16位</code>。指首部和数据之和的长度，单位为B，因此数据报的最大长度为216-1&#x3D; 65535B。以太网帧的最大传送单元(MTU)为1500B，因此当一个IP数据报封装成帧时，数据报的总长度(首部加数据) 一定不能超过下面数据链路层的MTU值</strong></li><li><strong><code>标识。占16位</code>。它是一个计数器，每产生一个数据报就加1,并赋值给标识字段。但它并不是“序号”(因为IP是无连接服务)。当一个数据报的长度超过网络的MTU时，必须分片，此时每个数据报片都复制一次标识号， 以便能正确重装成原来的数据报</strong></li><li><strong><code>标志。占3位</code>。标志字段的最低位为MF, MF&#x3D; 1表示后面还有分片，MF&#x3D; 0表示最后一个分片。” 标志字段中间的一位是DF,只有当DF &#x3D;0时才允许分片</strong></li><li><strong><code>片偏移</code>。占13位。它指出较长的分组在分片后，某片在原分组中的相对位置。片偏移以8个字节为偏移单位,8B，即每个分片的长度一定是8B (64 位)的整数倍</strong></li><li><strong><code>首部校验和</code>。占16位。IP数据报的首部校验和只校验分组的首部，而不校验数据部分</strong></li><li><strong><code>生存时间(TTL)</code>。占8位。数据报在网络中可通过的路由器数的最大值，标识分组在网络中的寿命，以确保分组不会永远在网络中循环。路由器在转发分组前，先把TTL减1。若TTL被减为0，则该分组必须丢弃</strong></li><li><strong><code>协议</code>。占8位。指出此分组携带的数据使用何种协议，即分组的数据部分应交给哪个传输层协议，如TCP、UDP等。其中值为6表示TCP,值为17表示UDP</strong></li><li><strong><code>源地址字段</code>。占4B，标识发送方的IP地址</strong></li><li><strong><code>目的地址字段</code>。占4B，标识接收方的IP地址</strong></li></ul></blockquote><hr><h6 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h6><ul><li><strong><code>一个链路层数据报能承载的最大数据量称为最大传送单元(MTU)</code>。因为IP数据报被封装在链路层数据报中，因此&#96;&#96;链路层的MTU严格地限制着IP数据报的长度，而且在IP数据报的源与目的地路径上的各段链路可能使用不同的链路层协议，有不同的MTU&#96;。例如，以太网的MTU为1500B，而许多广域网的MTU不超过576B。当IP数据报的总长度大于链路MTU时，就需要将IP数据报中的数据分装在两个或多个较小的IP数据报中，这些较小的数据报称为片</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163444457.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163444457.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163444457"><ul><li><strong>再回忆一下IP数据报格式的相关字段意义</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163502294.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163502294.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163502294"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163511769.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163511769.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163511769"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163518547.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163518547.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163518547"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163524613.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163524613.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163524613"><hr><h6 id="网络层转发分组的流程"><a href="#网络层转发分组的流程" class="headerlink" title="网络层转发分组的流程"></a>网络层转发分组的流程</h6><p><strong>网络层的路由器执行的分组转发算法如下:</strong></p><blockquote><ol><li><strong>从数据报的首部提取目的主机的IP地址D，得出目的网络地址N</strong></li><li><strong>若网络N与此路由器直接相连，则把数据报直接交付给目的主机D，这称为路由器的直接交付;否则是间接交付，执行步骤3</strong></li><li><strong>若路由表中有目的地址为D的特定主机路由(对特定的目的主机指明一个特定的路由，通常是为了控制或测试网络，或出于安全考虑才采用的)，则把数据报传送给路由表中所指明的下一跳路由器;否则，执行步骤4</strong></li><li><strong>若路由表中有到达网络N的路由，则把数据报传送给路由表指明的下一跳路由器;否则，执行步骤5</strong></li><li><strong>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否则，执行步骤6</strong></li><li><strong>报告转发分组出错</strong></li></ol></blockquote><p><strong>注意:得到下一跳路由器的IP 地址后并不是直接将该地址填入待发送的数据报，而是将该IP地址转换成MAC地址(通过ARP，见4.3.4节)，将其放到MAC帧首部中，然后根据这个MAC地址找到下一跳路由器。在不同网络中传送时，MAC帧中的源地址和目的地址要发生变化，但是网桥在转发帧时，不改变帧的源地址，请注意区分</strong></p><hr><h5 id="IPv4与NAT"><a href="#IPv4与NAT" class="headerlink" title="IPv4与NAT"></a>IPv4与NAT</h5><h6 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163736327.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163736327.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163736327"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163743478.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163743478.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163743478"><ul><li><p><strong>无论哪类IP地址，都由<code>网络号和主机号</code>两部分组成</strong></p></li><li><p><strong>即IP地址::&#x3D; {&lt;网络号&gt;, &lt;主机号&gt;}</strong></p></li><li><p><strong>其中<code>网络号</code>标志<code>主机(或路由器)</code>所连接到的<code>网络</code>。–个网络号在整个因特网范围内必须是唯一的</strong></p></li><li><p><strong><code>主机号</code>标志<code>该主机(或路由器)</code>。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的</strong></p></li><li><p><strong>由此可见，一个IP地址在整个因特网范围内是唯–的</strong></p></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163847153.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163847153.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163847153"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163921602.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163921602.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163921602"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163929091.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109163929091.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109163929091"><ul><li><strong><code>A类地址</code>可用的网络数为2<sup>7</sup>-2，减2的原因是:<code>第一</code>，网络号字段全为0的IP地址是保留地址，意思是“本网络”;<code>第二</code>，网络号为127的IP地址是环回测试地址</strong></li><li><strong><code>B类地址</code>的可用网络数为2<sup>14</sup>-1，减1的原因是128.0这个网络号是不可指派的</strong></li><li><strong><code>C类地址</code>的可用网络数为2<sup>21</sup>-1,减1的原因是网络号为192.0.0 的网络是不可指派的</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164057120.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164057120.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164057120"><hr><h6 id="网络地址转换—NAT"><a href="#网络地址转换—NAT" class="headerlink" title="网络地址转换—NAT"></a>网络地址转换—NAT</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164110079.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164110079.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164110079"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164117785.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164117785.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164117785"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164124540.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164124540.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164124540"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164135018.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164135018.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164135018"><ul><li><strong>使用NAT时需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址</strong></li><li><strong>使用本地地址的主机和外界通信时，·NAT路由器使用NAT转换表将本地地址转换成全球地址，或将全球地址转换成本地地址</strong></li><li><strong>NAT转换表中存放着{本地IP地址:端口}到{全球IP地址:端口}的映射</strong></li><li><strong>通过{ip地址:端口}这样的映射方式，可让多个私有IP地址映射到同一一个全球IP地址</strong></li></ul><hr><h5 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h5><h6 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164214772.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164214772.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164214772"><ul><li><strong>从1985年起，在IP地址中又增加了一个<code>“子网号字段”</code>，使两级IP地址变成了<code>三级IP地址</code>。这种做法称为<code>子网划分</code>。子网划分已成为因特网的正式标准协议</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164233085.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164233085.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164233085"><hr><h6 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164247049.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164247049.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164247049"><ul><li><strong>子网掩码是一个与IP地址相对应的、长32bit的二进制串,它由一串1和跟随的一串0组成</strong></li><li><strong>其中，<code>1对应于IP地址中的网络号及子网号，而0对应于主机号</code></strong></li><li><strong>计算机只需将<code>IP地址</code>和其对应的<code>子网掩码逐位“与”</code>(逻辑AND运算)，就可<code>得出相应子网的网络地址</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164307420.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164307420.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164307420"><ul><li><strong>现在的因特网标准规定:所有的网络都必须使用子网掩码。如果一个网络未划分子网，那么就采用默认子网掩码</strong></li><li><strong>A、B、C类地址的默认子网掩码分别为255.0.0.0、 255.255.0.0、255.255.255.0</strong></li><li><strong>例如，某主机的IP地址192.168.5.56，子网掩码为255.255.255.0,进行逐位“与”运算后，得出该主机所在子网的网络号为192.168.5.0</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164332073.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164332073.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164332073"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164337694.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164337694.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164337694"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164402416.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164402416.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164402416"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164409800.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164409800.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164409800"><hr><h6 id="无分类域间路由选择CIDR"><a href="#无分类域间路由选择CIDR" class="headerlink" title="无分类域间路由选择CIDR"></a>无分类域间路由选择CIDR</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164421339.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164421339.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164421339"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164428257.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164428257.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164428257"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164443388.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164443388.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164443388"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164459130.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164459130.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164459130"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164505198.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164505198.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164505198"><hr><h5 id="地址解析协议—ARP协议"><a href="#地址解析协议—ARP协议" class="headerlink" title="地址解析协议—ARP协议"></a>地址解析协议—ARP协议</h5><p><strong>首先我们得了解一下IP地址与硬件地址的概念</strong></p><ul><li><strong>IP地址是网络层使用的地址，它是分层次等级的</strong></li><li><strong>硬件地址是数据链路层使用的地址(如MAC地址)，它是平面式的</strong></li><li><strong>在网络层及网络层之.上使用IP地址，IP地址放在IP数据报的首部，而MAC地址放在MAC帧的首部</strong></li><li><strong>通过数据封装，把IP数据报分组封装为MAC帧后，数据链路层看不见数据报分组中的IP地址</strong></li></ul><p><strong>ARP协议引入：</strong></p><ul><li><strong>无论网络层使用什么协议，在实际网络的链路上传送数据帧时，最终必须使用硬件地址。所以需要一种方法来完成 IP地址到MAC地址的映射，这就是地址解析协议(Address ResolutionProtocol, ARP)。 每台主机都设有-一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表。使用ARP来动态维护此ARP表</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164606247.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164606247.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164606247"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164621491.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164621491.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164621491"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164628533.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164628533.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164628533"><hr><h5 id="动态主机配置协议—DHCP协议"><a href="#动态主机配置协议—DHCP协议" class="headerlink" title="动态主机配置协议—DHCP协议"></a>动态主机配置协议—DHCP协议</h5><ul><li><strong><code>动态主机配置协议</code>(Dynamic Host Configuration Protocol, <code>DHCP</code>)<code>常用于给主机动态地分配IP地址</code>，它提供了即插即用联网的机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与</strong></li><li><strong>DHCP是应用层协议，它是基于UDP的</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164704703.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164704703.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164704703"><hr><h5 id="网际控制报文协议—ICMP协议"><a href="#网际控制报文协议—ICMP协议" class="headerlink" title="网际控制报文协议—ICMP协议"></a>网际控制报文协议—ICMP协议</h5><ul><li><strong>为了提高IP数据报交付成功的机会，在网络层使用了<code>网际控制报文协议</code>(Internet Control Message Protocol, <code>ICMP</code>)来<code>让主机或路由器报告差错和异常情况</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164729469.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164729469.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164729469"><ul><li><strong>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。ICMP是IP层协议</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164743380.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164743380.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164743380"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164801071.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164801071.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164801071"><ul><li><strong>ICMP报文的种类有两种，即<code>ICMP差错报告报文</code>和<code>ICMP询问报文</code></strong></li></ul><hr><h6 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164823424.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164823424.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164823424"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164829373.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164829373.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164829373"><hr><h6 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164837119.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164837119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164837119"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164845063-1688130759218-323.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109164845063-1688130759218-323.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109164845063"><hr><h3 id="第四节：IPv6"><a href="#第四节：IPv6" class="headerlink" title="第四节：IPv6"></a>第四节：IPv6</h3><h3 id="IPv6-诞生原因、数据报格式、与IPv4的不同、地址表现形式、基本地址类型、IPv6与IPv4的过度策略"><a href="#IPv6-诞生原因、数据报格式、与IPv4的不同、地址表现形式、基本地址类型、IPv6与IPv4的过度策略" class="headerlink" title="IPv6(诞生原因、数据报格式、与IPv4的不同、地址表现形式、基本地址类型、IPv6与IPv4的过度策略)"></a>IPv6(诞生原因、数据报格式、与IPv4的不同、地址表现形式、基本地址类型、IPv6与IPv4的过度策略)</h3><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165135820.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165135820.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109165135820"><hr><h5 id="为什么要有IPv6？"><a href="#为什么要有IPv6？" class="headerlink" title="为什么要有IPv6？"></a>为什么要有IPv6？</h5><p><strong>解决IP地址耗尽问题的措施有以下三种:</strong></p><ul><li><strong>采用无类别编址CIDR，使IP地址的分配更加合理</strong></li><li><strong>采用网络地址转换(NAT)方法以节省全球IP地址</strong></li><li><strong>采用具有更大地址空间的新版本的IPv6</strong></li></ul><p><strong>其中前两种方法只是延长了IPv4 地址分配结束的时间，只有第三种方法从根本上<code>解决了IP地址的耗尽问题</code></strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165224552.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165224552.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109165224552"><hr><h5 id="IPv6的数据报格式"><a href="#IPv6的数据报格式" class="headerlink" title="IPv6的数据报格式"></a>IPv6的数据报格式</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165240937.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165240937.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109165240937"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165249995.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165249995.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109165249995"><hr><h5 id="IPv6与IPv4的比较"><a href="#IPv6与IPv4的比较" class="headerlink" title="IPv6与IPv4的比较"></a>IPv6与IPv4的比较</h5><ul><li><strong>虽然IPv6与IPv4不兼容，但总体而言它与所有其他的因特网协议兼容，包括TCP、UDP、ICMP、IGMP、OSPF、BGP和DNS，只是在少数地方做了必要的修改(大部分是为了处理长的地址)</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165306090.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165306090.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109165306090"><hr><h5 id="IPv6的地址表示形式"><a href="#IPv6的地址表示形式" class="headerlink" title="IPv6的地址表示形式"></a>IPv6的地址表示形式</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165314673.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165314673.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109165314673"><hr><h5 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h5><p><strong>IPv6数据报的目的地址可以是以下三种基本类型地址之一：</strong></p><ul><li><strong><code>单播</code>。单播就是传统的点对点通信</strong></li><li><strong><code>多播</code>。多播是一点对多点的通信，分组被交付到一-组计算机的每台计算机</strong></li><li><strong><code>任播</code>。这是IPv6增加的一-种类型。任播的目的站是-组计算机，但数据报在交付时只交付其中的一台计算机，通常是距离最近的一台计算机</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165355123.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165355123.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109165355123"><hr><h5 id="IPv6向IPv4过渡的策略"><a href="#IPv6向IPv4过渡的策略" class="headerlink" title="IPv6向IPv4过渡的策略"></a>IPv6向IPv4过渡的策略</h5><p><strong>IPv4向IPv6过渡可以采用<code>双协议栈</code>和<code>隧道技术</code>两种策略</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165413538-1688130828689-332.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109165413538-1688130828689-332.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109165413538"><hr><h3 id="第五节：路由协议"><a href="#第五节：路由协议" class="headerlink" title="第五节：路由协议"></a>第五节：路由协议</h3><h4 id="路由选择协议-自治系统AS、RIP、OSPF、BGP"><a href="#路由选择协议-自治系统AS、RIP、OSPF、BGP" class="headerlink" title="路由选择协议(自治系统AS、RIP、OSPF、BGP)"></a>路由选择协议(自治系统AS、RIP、OSPF、BGP)</h4><h5 id="路由选择协议的引入"><a href="#路由选择协议的引入" class="headerlink" title="路由选择协议的引入"></a>路由选择协议的引入</h5><ul><li><strong>&#x3D;&#x3D;为了解决自治系统内部和外部之间的通信问题而创建的协议&#x3D;&#x3D;</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170246086.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170246086.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170246086"><hr><h5 id="路由信息协议—RIP协议"><a href="#路由信息协议—RIP协议" class="headerlink" title="路由信息协议—RIP协议"></a>路由信息协议—RIP协议</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170255911.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170255911.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170255911"><hr><h6 id="协议概况"><a href="#协议概况" class="headerlink" title="协议概况"></a>协议概况</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170304989.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170304989.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170304989"><hr><h6 id="RIP协议和谁交换？交换什么？多久交换一次？"><a href="#RIP协议和谁交换？交换什么？多久交换一次？" class="headerlink" title="RIP协议和谁交换？交换什么？多久交换一次？"></a>RIP协议和谁交换？交换什么？多久交换一次？</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170313067.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170313067.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170313067"><hr><h6 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170322574.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170322574.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170322574"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170329274.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170329274.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170329274"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170340458.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170340458.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170340458"><hr><h6 id="RIP协议的报文格式"><a href="#RIP协议的报文格式" class="headerlink" title="RIP协议的报文格式"></a>RIP协议的报文格式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170354539.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170354539.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170354539"><hr><h6 id="RIP协议好消息传得快，坏消息传的慢"><a href="#RIP协议好消息传得快，坏消息传的慢" class="headerlink" title="RIP协议好消息传得快，坏消息传的慢"></a>RIP协议好消息传得快，坏消息传的慢</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170414736.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170414736.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170414736"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170433665.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170433665.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170433665"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170454455.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170454455.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170454455"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170507077.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170507077.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170507077"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170515609.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170515609.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170515609"><hr><p>#####开放最短路径优先协议—OSPF协议</p><h6 id="OSPF协议概述及其特点"><a href="#OSPF协议概述及其特点" class="headerlink" title="OSPF协议概述及其特点"></a>OSPF协议概述及其特点</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170525401.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170525401.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170525401"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170532644.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170532644.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170532644"><hr><h6 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170544605.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170544605.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170544605"><hr><h6 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170553431.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170553431.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170553431"><hr><h6 id="OSPF的分组"><a href="#OSPF的分组" class="headerlink" title="OSPF的分组"></a>OSPF的分组</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170611850.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170611850.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170611850"><hr><h5 id="什么称为用UDP传送？什么称为用IP数据报传送？"><a href="#什么称为用UDP传送？什么称为用IP数据报传送？" class="headerlink" title="什么称为用UDP传送？什么称为用IP数据报传送？"></a>什么称为用UDP传送？什么称为用IP数据报传送？</h5><ul><li><strong>用UDP传送是指将该信息作为UDP报文的数据部分</strong></li><li><strong>直接使用IP数据报传送是指将该信息直接作为IP 数据报的数据部分</strong></li><li><strong>RIP报文是作为UDP数据报的数据部分</strong></li><li><strong>OSPF协议直接使用IP数据报进行传递</strong></li></ul><hr><p>#####边界网关协议—BGP协议</p><h6 id="和谁交换？交换什么？多久交换一次？"><a href="#和谁交换？交换什么？多久交换一次？" class="headerlink" title="和谁交换？交换什么？多久交换一次？"></a>和谁交换？交换什么？多久交换一次？</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170637329.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170637329.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170637329"><hr><h6 id="交换信息的过程"><a href="#交换信息的过程" class="headerlink" title="交换信息的过程"></a>交换信息的过程</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170646389.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170646389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170646389"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170654780.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170654780.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170654780"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170701619.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170701619.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170701619"><hr><h6 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a>BGP协议报文格式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170711380.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170711380.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170711380"><hr><h6 id="BGP-4的四种报文"><a href="#BGP-4的四种报文" class="headerlink" title="BGP-4的四种报文"></a>BGP-4的四种报文</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170718321.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170718321.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170718321"><hr><h6 id="BGP协议特点"><a href="#BGP协议特点" class="headerlink" title="BGP协议特点"></a>BGP协议特点</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170725161.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170725161.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170725161"><hr><h5 id="RIP、OSPF、BGP协议比较"><a href="#RIP、OSPF、BGP协议比较" class="headerlink" title="RIP、OSPF、BGP协议比较"></a>RIP、OSPF、BGP协议比较</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170736149-1688130992765-359.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170736149-1688130992765-359.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170736149"><hr><h3 id="第六节：IP组播"><a href="#第六节：IP组播" class="headerlink" title="第六节：IP组播"></a>第六节：IP组播</h3><h4 id="IP组播-IGMP、组播路由选择协议、组播地址"><a href="#IP组播-IGMP、组播路由选择协议、组播地址" class="headerlink" title="IP组播(IGMP、组播路由选择协议、组播地址)"></a>IP组播(IGMP、组播路由选择协议、组播地址)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170951538.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170951538.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170951538"><hr><h5 id="IP数据报的三种传输方式"><a href="#IP数据报的三种传输方式" class="headerlink" title="IP数据报的三种传输方式"></a>IP数据报的三种传输方式</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170959184.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109170959184.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109170959184"><ul><li><strong>以用户看视频为例，进一步了解单播、广播和多播三种传输方式</strong></li><li><strong>为了能够支持像视频点播和视频会议这样的多媒体应用，网络必须实施某种有效的组播机制</strong></li><li><strong>使用多个单播传送来仿真组播总是可能的，但这会引起主机上大量的处理开销和网络上太多的交通量</strong></li><li><strong>人们所需要的组播机制是让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被它们正确接收</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171040955.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171040955.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171040955"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171050880.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171050880.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171050880"><hr><h5 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h5><p><strong>上文我们已经知道了<code>多播</code>，那么如何才能发给同一组主机相同的数据呢？这就需要了解一下IP组播地址，他就是干这个的：</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171111178.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171111178.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171111178"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171119091.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171119091.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171119091"><hr><h5 id="IGMP协议与组播路由选择协议"><a href="#IGMP协议与组播路由选择协议" class="headerlink" title="IGMP协议与组播路由选择协议"></a>IGMP协议与组播路由选择协议</h5><h6 id="网际组管理协议—IGMP"><a href="#网际组管理协议—IGMP" class="headerlink" title="网际组管理协议—IGMP"></a>网际组管理协议—IGMP</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171135170.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171135170.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171135170"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171143401.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171143401.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171143401"><hr><h6 id="IGMP工作的两个阶段"><a href="#IGMP工作的两个阶段" class="headerlink" title="IGMP工作的两个阶段"></a>IGMP工作的两个阶段</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171151955.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171151955.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171151955"><hr><h6 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a>组播路由选择协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171159465.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171159465.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171159465"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171207629.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171207629.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171207629"><hr><h6 id="组播路由选择协议常用的三种路由算法"><a href="#组播路由选择协议常用的三种路由算法" class="headerlink" title="组播路由选择协议常用的三种路由算法"></a>组播路由选择协议常用的三种路由算法</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171215960-1688131076364-372.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171215960-1688131076364-372.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171215960"><hr><h3 id="第七节：移动IP"><a href="#第七节：移动IP" class="headerlink" title="第七节：移动IP"></a>第七节：移动IP</h3><h4 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h4><h5 id="什么是移动IP？"><a href="#什么是移动IP？" class="headerlink" title="什么是移动IP？"></a>什么是移动IP？</h5><ul><li><strong>支持移动性的因特网体系结构与协议共称为移动IP,它是为了满足移动结点(计算机、服务、网段等)在移动中保持其连接性而设计的</strong></li><li><strong>更确切地说，移动IP技术是指<code>移动结点以固定的网络IP地址实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变</code></strong></li><li><strong>移动IP的目标是把分组自动地投递给移动结点。一个移动结点是把其连接点从一个网络或子网改变到另-一个网络或子网的主机</strong></li><li><strong>使用移动IP，<code>一个移动结点可以在不改变其IP地址的情况下改变其驻留位置</code></strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171339127.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171339127.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171339127"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171345723.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171345723.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171345723"><hr><h5 id="移动IP相关术语"><a href="#移动IP相关术语" class="headerlink" title="移动IP相关术语"></a>移动IP相关术语</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171354815.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171354815.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171354815"><hr><h5 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171404057.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171404057.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171404057"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171411164-1688131135145-378.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171411164-1688131135145-378.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171411164"><hr><p>第八节：路由器</p><h4 id="设备路由器"><a href="#设备路由器" class="headerlink" title="设备路由器"></a>设备路由器</h4><h5 id="路由器概念"><a href="#路由器概念" class="headerlink" title="路由器概念"></a>路由器概念</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171508122.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171508122.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171508122"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171530764.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171530764.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171530764"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171537443.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171537443.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171537443"><hr><h5 id="三个设备之间的区别"><a href="#三个设备之间的区别" class="headerlink" title="三个设备之间的区别"></a>三个设备之间的区别</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171547054.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171547054.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171547054"><hr><h5 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171607816-1688131204517-384.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171607816-1688131204517-384.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171607816"><hr><h2 id="第五章：传输层"><a href="#第五章：传输层" class="headerlink" title="第五章：传输层"></a>第五章：传输层</h2><h3 id="第一节：传输层提供的服务"><a href="#第一节：传输层提供的服务" class="headerlink" title="第一节：传输层提供的服务"></a>第一节：传输层提供的服务</h3><h4 id="传输层提供的服务及功能概述、端口、套接字Socket、无连接UDP和面向连接TCP服务"><a href="#传输层提供的服务及功能概述、端口、套接字Socket、无连接UDP和面向连接TCP服务" class="headerlink" title="传输层提供的服务及功能概述、端口、套接字Socket、无连接UDP和面向连接TCP服务"></a>传输层提供的服务及功能概述、端口、套接字Socket、无连接UDP和面向连接TCP服务</h4><h5 id="传输层提供的服务及功能概述"><a href="#传输层提供的服务及功能概述" class="headerlink" title="传输层提供的服务及功能概述"></a>传输层提供的服务及功能概述</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171946332.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109171946332.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109171946332"><p><strong>传输层的功能如下:</strong></p><ol><li><p><strong>传输层提供应用进程之间的逻辑通信(即端到端的通信)</strong></p><blockquote><ul><li><p><strong>与网络层的区别是，网络层提供的是主机之间的逻辑通信</strong></p></li><li><p><strong>从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的IP地址</strong></p></li><li><p><strong>但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信，应用进程之间的通信又称端到端的逻辑通信</strong></p></li><li><p><strong>这里“逻辑通信”的意思是:传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间并没有–条水平方向的物理连接</strong></p></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172058536.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172058536.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172058536"></blockquote></li><li><p><strong>复用和分用</strong></p><blockquote><ul><li><strong>复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据;</strong></li><li><strong>分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程</strong></li></ul><p><strong>注意：</strong></p><ul><li><strong>传输层的复用分用功能与网络层的复用分用功能不同</strong></li><li><strong>网络层的<code>复用</code>是指发送方不同协议的数据都可以封装成IP数据报发送出去</strong></li><li><strong>网络层的<code>分用</code>是指接收方的网络层在剥去首部后把数据交付给相应的协议</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172139649.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172139649.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172139649"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172149729.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172149729.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172149729"></blockquote></li><li><p><strong>传输层还要对收到的报文进行差错检测(首部和数据部分)</strong></p><blockquote><ul><li><strong>网络层只检查IP数据报的首部，不检验数据部分是否出错</strong></li></ul></blockquote></li><li><p><strong>提供两种不同的传输协议，即面向连接的TCP和无连接的UDP</strong></p><blockquote><ul><li><strong>网络层无法同时实现两种协议(即在网络层要么只提供面向连接的服务，如虚电路;要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式)</strong></li></ul></blockquote></li></ol><hr><h5 id="传输层的寻址和端口"><a href="#传输层的寻址和端口" class="headerlink" title="传输层的寻址和端口"></a>传输层的寻址和端口</h5><h6 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172232017.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172232017.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172232017"><hr><h6 id="端口号的分类"><a href="#端口号的分类" class="headerlink" title="端口号的分类"></a>端口号的分类</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172241392.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172241392.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172241392"><hr><h6 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172255983.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172255983.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172255983"><hr><h5 id="无连接UDP和面向连接TCP服务"><a href="#无连接UDP和面向连接TCP服务" class="headerlink" title="无连接UDP和面向连接TCP服务"></a>无连接UDP和面向连接TCP服务</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172303411.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172303411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172303411"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172309697-1688131336409-394.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172309697-1688131336409-394.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172309697"><hr><h3 id="第二节：UDP协议"><a href="#第二节：UDP协议" class="headerlink" title="第二节：UDP协议"></a>第二节：UDP协议</h3><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><h5 id="用户数据报协议UDP概述及特点优势"><a href="#用户数据报协议UDP概述及特点优势" class="headerlink" title="用户数据报协议UDP概述及特点优势"></a>用户数据报协议UDP概述及特点优势</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172504502.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172504502.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172504502"><p><strong>为什么应用开发人员宁愿在UDP之上构建应用，也不选择TCP?既然TCP提供可靠的服务，而UDP不提供，那么TCP总是首选吗?答案是否定的，因为有很多应用更适合用UDP，主要是因为UDP具有如下优点:</strong></p><blockquote><ol><li><strong>UDP无须建立连接</strong><ul><li><strong>UDP不会引入建立连接的时延</strong></li><li><strong>试想如果DNS运行在TCP而非UDP.上，那么DNS的<code>速度</code>会慢很多</strong></li><li><strong>HTTP使用TCP而非UDP，是因为对于基于文本数据的Web网页来说，<code>可靠性</code>是至关重要的</strong></li></ul></li><li><strong>无连接状态</strong><ul><li><strong>TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数</strong></li><li><strong>而UDP不维护连接状态，也不跟踪这些参数</strong></li><li><strong>因此，<code>某些专用应用服务器使用UDP</code>时，<code>一般都能支持更多的活动客户机</code></strong></li></ul></li><li><strong>分组首部开销小</strong><ul><li><strong><code>TCP</code>有<code>20B</code>的<code>首部</code>开销，而<code>UDP</code>仅有<code>8B</code>的开销</strong></li></ul></li><li><strong>应用层能更好地控制要发送的数据和发送时间</strong><ul><li><strong>UDP没有拥塞控制，因此网络中的拥塞<code>不会影响主机的发送效率</code></strong></li><li><strong><code>某些实时应用要求以稳定的速度发送</code>，能容忍一些数据的丢失，但<code>不允许有较大的时延</code>，而UDP正好满足这些应用的需求</strong></li></ul></li><li><strong>UDP常用于一次性传输较少数据的网络应用</strong><ul><li><strong>如DNS、SNMP等，因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销</strong></li><li><strong>UDP也常用于多媒体应用(如IP电话、实时视频会议、流媒体等)，显然，可靠数据传输对这些应用来说并不是最重要的，但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的</strong></li></ul></li><li><strong>UDP提供尽最大努力的交付，即不保证可靠交付</strong><ul><li><strong>但这并不意味着应用对数据的要求是不可靠的，因此所有维护传输可靠性的工作需要用户在应用层来完成</strong></li><li><strong><code>应用实体可以根据应用的需求来灵活设计自己的可靠性机制</code></strong></li></ul></li><li><strong>UDP是面向报文的</strong><ul><li><strong>发送方UDP对<code>应用层交下来的报文</code>，在添加首部后就向下交付给IP层，<code>既不合并，也不拆分</code>，而是保留这些报文的边界</strong></li><li><strong>接收方UDP对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文</strong></li><li><strong>因此<code>报文不可分割，是UDP数据报处理的最小单位</code></strong></li></ul></li></ol></blockquote><hr><h5 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172746052.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172746052.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172746052"><p><strong>各字段意义如下：</strong></p><ul><li><strong>源端口。源端口号。在需要对方回信时选用，不需要时可用全0</strong></li><li><strong>目的端口。目的端口号。这在终点交付报文时必须使用到</strong></li><li><strong>长度。UDP数据报的长度(包括首部和数据)，其最小值是8 (仅有首部)</strong></li><li><strong>校验和。检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0</strong></li></ul><hr><h5 id="当传输层从IP层收到UDP数据报时"><a href="#当传输层从IP层收到UDP数据报时" class="headerlink" title="当传输层从IP层收到UDP数据报时"></a>当传输层从IP层收到UDP数据报时</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172841845.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172841845.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172841845"><hr><h5 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172912810.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109172912810.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109172912810"><ul><li><strong>&#x3D;&#x3D;伪首部和全0字节是不发送的，仅供校验使用&#x3D;&#x3D;</strong></li></ul><hr><h3 id="第三节：TCP协议"><a href="#第三节：TCP协议" class="headerlink" title="第三节：TCP协议"></a>第三节：TCP协议</h3><h4 id="1-TCP协议-TCP协议特点、TCP协议报文段首部格式、TCP连接管理-三次握手、TCP连接释放-四次挥手"><a href="#1-TCP协议-TCP协议特点、TCP协议报文段首部格式、TCP连接管理-三次握手、TCP连接释放-四次挥手" class="headerlink" title="1.TCP协议(TCP协议特点、TCP协议报文段首部格式、TCP连接管理-三次握手、TCP连接释放-四次挥手)"></a>1.TCP协议(TCP协议特点、TCP协议报文段首部格式、TCP连接管理-三次握手、TCP连接释放-四次挥手)</h4><h5 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a>TCP协议特点</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173211963.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173211963.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173211963"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173219385.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173219385.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173219385"><hr><h5 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h5><ul><li><strong><code>TCP传送的数据单元称为报文段</code>。一个TCP报文段分为TCP首部和TCP数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中</strong></li><li><strong>其首部的前20B是固定的。TCP报文段的首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度为4B的整数倍</strong></li><li><strong>TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173250826.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173250826.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173250826"><blockquote><ul><li><strong><code>源端口和目的端口字段</code>。各占2B。端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口实现</strong></li><li><strong><code>序号字段</code>。占4B。TCP是面向字节流的(即TCP传送时是逐个字节传送的)，所以TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173344292.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173344292.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173344292"><ul><li><strong><code>确认号字段</code>。占4B,是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表明到序号N- 1为止的所有数据都已正确收到</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173401686.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173401686.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173401686"><ul><li><strong><code>数据偏移(即首部长度)</code>。占4位，这里不是IP数据报分片的那个数据偏移，而是表示首部长度，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位是32位(以4B为计算单位)。因此当此字段的值为15时，达到TCP首部的最大长度60B</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173425267.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173425267.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173425267"><ul><li><strong><code>保留字段</code>。占6位，保留为今后使用，但目前应置为0，该字段可以忽略不计</strong></li><li><strong>紧急位URG<code>。URG= 1时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。但</code>URG需要和紧急指针配套使用<code>，即</code>数据从第一个字节到紧急指针所指字节<code>就是</code>紧急数据</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173505455.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173505455.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173505455"><ul><li><strong><code>确认位ACK</code>。只有当ACK&#x3D; 1时确认号字段才有效。当ACK&#x3D;0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1</strong></li><li><strong><code>推送位PSH (Push)</code>。 接收TCP收到PSH&#x3D; 1的报文段，就尽快地交付给接收应用进程而不再等到整个缓存都填满后再向上交付</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173545232.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173545232.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173545232"><ul><li><strong><code>复位位RST (Reset)</code>。RST&#x3D;1时，表明TCP连接中出现严重差错(如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</strong></li><li><strong><code>同步位SYN</code>。同步SYN&#x3D; 1表示这是一个<code>连接请求或连接接收报文</code>。当<code>SYN=1, ACK=0</code>时，表明这是一个<code>连接请求</code>报文，对方若同意建立连接，则在响应报文中使用<code>SYN=1, ACK=1</code>。即SYN&#x3D; 1表示这是一个连接请求或连接接收报文</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173617725.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173617725.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173617725"><ul><li><strong><code>终止位FIN (Finish)</code>。用来释放一个连接。FIN&#x3D; 1表明此报文段的发送方的数据已发送完毕，并要求释放传输连接</strong></li><li><code>**窗口字段</code>。占2B。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节**</li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173702593.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173702593.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173702593"><ul><li><strong><code>校验和</code>。占2B。校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和UDP一样，要在TCP报文段的前面加上12B的伪首部(只需将UDP伪首部的第4个字段，即协议字段的17改成6，其他的和UDP一样)</strong></li><li><strong><code>紧急指针字段</code>。占16 位，指出在本报文段中紧急数据共有多少字节(紧急数据放在本报文段数据的最前面)</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173733820.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173733820.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173733820"><ul><li><strong><code>选项字段</code>。长度可变。TCP最初只规定了一种选项，即最大报文段长度(Maximum SegmentSize，MSS)。MSS是TCP报文段中的数据字段的最大长度。窗口扩大、时间戳、选择确认</strong></li><li><strong><code>填充字段</code>。这是为了使整个首部长度是4B的整数倍。填充0</strong></li></ul></blockquote><hr><h5 id="TCP连接管理—三次握手"><a href="#TCP连接管理—三次握手" class="headerlink" title="TCP连接管理—三次握手"></a>TCP连接管理—三次握手</h5><ul><li><strong>TCP是面向连接的协议，因此每个TCP连接都有三个阶段:连接建立、数据传送和连接释放。</strong></li><li><strong>TCP连接的管理就是使运输连接的建立和释放都能正常进行。</strong></li></ul><p><strong>在TCP连接建立的过程中，要解决以下三个问题:</strong></p><ol><li><strong>要使每一方都能够确知对方的存在</strong></li><li><strong>要允许双方协商一些参数(如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等)</strong></li><li><strong>能够对运输实体资源( 如缓存大小、连接表中的项目等)进行分配</strong></li></ol><ul><li><strong>每条TCP连接通过通信两端的两个端点( 即两个套接字)确定</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173918294.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173918294.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173918294"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173925491.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109173925491.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109173925491"><blockquote><p><strong>第一步:客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号 seq&#x3D; x(连接请求报文不携带数据，但要消耗一个序号)</strong></p><p><strong>第二步:服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1,确认号字段的值为x+ 1, 并且服务器随机产生起始序号seq &#x3D; y(确认报文不携带数据,但也要消耗-一个序号)。确认报文段同样不包含应用层数据</strong></p><p><strong>第三步:当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置1,序号字段为x+1,确认号字段ack&#x3D;y+ 1。该报文段可以携带数据，若不携带数据则不消耗序号</strong></p><ul><li><p><strong>&#x3D;&#x3D;成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据&#x3D;&#x3D;</strong></p></li><li><p><strong>TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据</strong></p></li><li><p><strong>服务器端的资源是在完成第二次握手时分配的</strong></p></li><li><p><strong>而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击</strong></p></li></ul></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174032298.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174032298.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174032298"><hr><h5 id="TCP连接释放—四次握手"><a href="#TCP连接释放—四次握手" class="headerlink" title="TCP连接释放—四次握手"></a>TCP连接释放—四次握手</h5><ul><li><strong>天下没有不散的筵席，TCP同样如此。参与TCP连接的两个进程中的任何- 一个都能终止该连接。TCP连接释放的过程通常称为四次握手</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174052402.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174052402.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174052402"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174103917.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174103917.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174103917"><blockquote><p><strong>第一步:客户机打算关闭连接时，向其TCP发送一个连接释放报文段， 并停止发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1, <code>seq=u, 它等于前面已传送过的数据的最后一个字节的序号加1</code> (FIN报文段即使不携带数据，也要消耗一个序号)。TCP 是全双工的，即可以想象为一条TCP连接上有两条数据通路。发送FIN报文时，发送FIN的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据</strong></p><p><strong>第二步:服务器收到连接释放报文段后即发出确认，<code>确认号是ack=u+ 1,而这个报文段自己的序号是v,等于它前面已传送过的数据的最后一个字节的序号加1</code>。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即<code>从服务器到客户机这个方向的连接并未关闭</code></strong></p><p><strong>第三步:若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其<code>发出FIN= 1的连接释放报文段</code></strong></p><p><strong>第四步:<code>客户机收到连接释放报文段后，必须发出确认</code>。在确认报文段中，ACK字段被置为1，确认号ack&#x3D;w+1,序号seq&#x3D;u+1.此时TCP连接还未释放，<code>必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态</code></strong></p></blockquote><hr><h5 id="TCP连接建立和释放的总结如下"><a href="#TCP连接建立和释放的总结如下" class="headerlink" title="TCP连接建立和释放的总结如下"></a>TCP连接建立和释放的总结如下</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174305825-1688131506140-416.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174305825-1688131506140-416.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174305825"><hr><h4 id="2-TCP可靠传输"><a href="#2-TCP可靠传输" class="headerlink" title="2.TCP可靠传输"></a>2.TCP可靠传输</h4><h5 id="TCP可靠传输简介"><a href="#TCP可靠传输简介" class="headerlink" title="TCP可靠传输简介"></a>TCP可靠传输简介</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174354987.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174354987.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174354987"><hr><h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174402878.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174402878.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174402878"><hr><h5 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174410198.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174410198.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174410198"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174415563.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174415563.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174415563"><hr><h5 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174429291-1688131566998-422.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174429291-1688131566998-422.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174429291"><hr><h4 id="3-TCP流量控制"><a href="#3-TCP流量控制" class="headerlink" title="3.TCP流量控制"></a>3.TCP流量控制</h4><ul><li>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为<code>接收窗口rwnd</code>, 即<code>调整TCP报文段首部中的“窗口”字段值</code>，来限制发送方向网络注入报文的速率</li><li>同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为<code>拥塞窗口cwnd</code>，其大小与网络的带宽和时延密切相关</li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174517565.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174517565.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174517565"><ul><li><strong>例如，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可以通过设置确认报文段首部的窗口字段来将rwnd通知给A</strong></li><li><strong>rwnd 即接收方允许连续接收的最大能力，单位是字节</strong></li><li><strong>发送方A总是根据最新收到的rwnd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内，保证A不会使B的接收缓存溢出</strong></li><li><strong>当然，A的发送窗口的实际大小取rwnd和cwnd中的最小值</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174551437.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174551437.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174551437"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174558336.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174558336.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174558336"><p><strong>&#x3D;&#x3D;传输层和数据链路层的流量控制的区别是:&#x3D;&#x3D;</strong></p><ul><li><strong>传输层定义<code>端到端</code>用户之间的流量控制，数据链路层定义<code>两个中间的相邻结点</code>的流量控制</strong></li><li><strong>另外，<code>数据链路层</code>的滑动窗口协议的<code>窗口</code>大小<code>不能动态变化</code>，<code>传输层</code>的则可以<code>动态变化</code></strong></li></ul><hr><h4 id="4-TCP拥塞控制-慢开始与拥塞避免、快重传与快恢复"><a href="#4-TCP拥塞控制-慢开始与拥塞避免、快重传与快恢复" class="headerlink" title="4.TCP拥塞控制(慢开始与拥塞避免、快重传与快恢复)"></a>4.TCP拥塞控制(慢开始与拥塞避免、快重传与快恢复)</h4><h5 id="什么是拥塞控制？"><a href="#什么是拥塞控制？" class="headerlink" title="什么是拥塞控制？"></a>什么是拥塞控制？</h5><ul><li><strong>所谓<code>拥塞控制，是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</code>。出现拥塞时，端点并不了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果</strong></li></ul><hr><h5 id="拥塞控制与流量控制的区别"><a href="#拥塞控制与流量控制的区别" class="headerlink" title="拥塞控制与流量控制的区别"></a>拥塞控制与流量控制的区别</h5><ul><li><strong><code>拥塞控制</code>是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素</strong></li><li><strong><code>流量控制</code>往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174835276.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174835276.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174835276"><p><strong>例如：</strong></p><ul><li><strong>某个链路的传输速率为10Gb&#x2F;s,某巨型机向一台PC以1Gb&#x2F;s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制</strong></li><li><strong>但若有100万台PC在此链路上以1Mb&#x2F;s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据</strong></li></ul><p><strong>为了更好地对传输层进行拥塞控制，因特网建议标准定义了以下4种算法:<code>慢开始、拥塞避免、快重传、快恢复</code></strong></p><hr><h5 id="拥塞控制的四种算法"><a href="#拥塞控制的四种算法" class="headerlink" title="拥塞控制的四种算法"></a>拥塞控制的四种算法</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174914670.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174914670.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174914670"><hr><h6 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174928155.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174928155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174928155"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174941015.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174941015.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174941015"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174947150.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174947150.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174947150"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174954396.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109174954396.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109174954396"><hr><h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><p><strong>&#x3D;&#x3D;快重传和快恢复算法是对慢开始和拥塞避免算法的改进&#x3D;&#x3D;</strong></p><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175014534.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175014534.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175014534"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175021984.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175021984.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175021984"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175027511-1688131760601-435.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175027511-1688131760601-435.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175027511"><hr><h2 id="第六章：应用层"><a href="#第六章：应用层" class="headerlink" title="第六章：应用层"></a>第六章：应用层</h2><h3 id="第一节：网络应用模型"><a href="#第一节：网络应用模型" class="headerlink" title="第一节：网络应用模型"></a>第一节：网络应用模型</h3><h4 id="应用层概述-C-x2F-S模型与P2P模式"><a href="#应用层概述-C-x2F-S模型与P2P模式" class="headerlink" title="应用层概述(C&#x2F;S模型与P2P模式)"></a>应用层概述(C&#x2F;S模型与P2P模式)</h4><h5 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175321626.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175321626.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175321626"><hr><h5 id="网路应用模型"><a href="#网路应用模型" class="headerlink" title="网路应用模型"></a>网路应用模型</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175333719.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175333719.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175333719"><hr><h6 id="客户-x2F-服务器模型-C-x2F-S"><a href="#客户-x2F-服务器模型-C-x2F-S" class="headerlink" title="客户&#x2F;服务器模型(C&#x2F;S)"></a>客户&#x2F;服务器模型(C&#x2F;S)</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175343042.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175343042.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175343042"><hr><h6 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175350839.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175350839.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175350839"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175403793-1688131961618-441.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175403793-1688131961618-441.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175403793"><hr><h3 id="第二节：域名系统DNS"><a href="#第二节：域名系统DNS" class="headerlink" title="第二节：域名系统DNS"></a>第二节：域名系统DNS</h3><h4 id="详解DNS域名解析系统-域名、域名服务器、域名解析过程"><a href="#详解DNS域名解析系统-域名、域名服务器、域名解析过程" class="headerlink" title="详解DNS域名解析系统(域名、域名服务器、域名解析过程)"></a>详解DNS域名解析系统(域名、域名服务器、域名解析过程)</h4><h5 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h5><ul><li><p><strong><code>域名系统(Domain Name System, DNS)</code>是因特网使用的命名系统，用来<code>把便于人们记忆的具有特定含义的主机名(如www.baidu.com)转换为便于机器处理的IP地址</code></strong></p></li><li><p><strong>相对于IP地址，人们更喜欢使用具有特定含义的字符串来标识因特网上的计算机</strong></p></li><li><p><strong>DNS系统采用客户&#x2F;服务器模型，其协议运行在<code>UDP</code>之上，使用<code>53号端口</code></strong></p></li><li><p><strong>从概念上可将DNS分为3部分:<code>层次域名空间、域名服务器和解析器</code></strong></p></li><li><p><strong>某台主机访问网站<a href="http://www.baidu.cn网站为例,dns的大致流程/">www.baidu.cn网站为例，DNS的大致流程</a></strong></p></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175951892.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109175951892.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109175951892"><hr><h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><ul><li><strong><code>因特网采用层次树状结构的命名方法</code>。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名(Domain Name)</strong></li><li><strong><code>域(Domain)</code>是名字空间中一个可被管理的划分</strong></li><li><strong>域还可以划分为子域，而子域还可以继续划分为子域的子域，这样就形成了顶级域、二级域、三级域等</strong></li></ul><p><strong>在域名系统中，每个域分别由不同的组织进行管理。每个组织都可以将它的域再分成一定数目的子域，并将这些子域委托给其他组织去管理</strong></p><ul><li><strong>例如，管理CN域的中国将EDU.CN子域授权给中国教育和科研计算机网(CERNET)来管理</strong></li><li><strong>比如百度域名baidu.cn是一个二级域名，我可以任意分配三级域名，比如1001.baidu.cn和1002.baidu.cn，这两个网址是可以访问的</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180148492.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180148492.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180148492"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180256516.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180256516.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180256516"><p><strong>关于域名中的标号有以下几点需要注意:</strong></p><blockquote><ul><li><strong>标号中的英文<code>不区分大小写</code></strong></li><li><strong>标号中除连字符(-) 外不能使用其他的标点符号</strong></li><li><strong>每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符</strong></li><li><strong>级别最低的域名写在最左边，级别最高的顶级域名写在最右边</strong></li></ul></blockquote><p><strong><code>顶级域名(Top Level Domain, TLD)</code>分为如下三大类:</strong></p><blockquote><ul><li><strong>国家顶级域名(nTLD)。国家和某些地区的域名，如“.cn”表示中国，“.us”表示美国，.uk”表示英国</strong></li><li><strong>通用顶级域名(gTLD)。 常见的有“.com” (公司)、“.net” (网络服务机构)、“.org”(非营利性组织)和“.gov” (国家或政府部门)等</strong></li><li><strong>基础结构域名。这种顶级域名只有一个，即arpa,用于反向域名解析，因此又称反向域名。反向域名解析与通常的正向域名解析相反，提供IP地址到域名的对应，反向域名格式如：X.X.X.in-addr.arpa。很多网络服务提供商要求访问的IP地址具有反向域名解析的结果，否则不提供服务</strong></li></ul><p><strong>&#x3D;&#x3D;国家顶级域名下注册的二级域名均由该国家自行确定&#x3D;&#x3D;</strong></p></blockquote><hr><h5 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h5><blockquote><ul><li><p><strong>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户&#x2F;服务器模型</strong></p></li><li><p><strong>域名到IP地址的解析是由运行在域名服务器上的程序完成的，一个服务器所负责管辖的(或有权限的)范围称为区(不以“域”为单位)，各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有结点必须是能够连通的，每个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射</strong></p></li><li><p><strong>每个域名服务器不但能够进行一些域名到IP地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到IP地址的转换时，能够知道到什么地方去找其他域名服务器</strong></p></li><li><p><strong>DNS使用了大量的域名服务器，它们以层次方式组织。没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的DNS上</strong></p></li><li><p><strong>采用分布式设计的DNS，是一个在因特网上实现分布式数据库的精彩范例。主要有4种类型的域名服务器</strong></p></li></ul></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180426749.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180426749.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180426749"><hr><h6 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180440791.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180440791.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180440791"><hr><h6 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180446414.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180446414.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180446414"><hr><h6 id="授权域名服务器-权限域名服务器"><a href="#授权域名服务器-权限域名服务器" class="headerlink" title="授权域名服务器(权限域名服务器)"></a>授权域名服务器(权限域名服务器)</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180452629.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180452629.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180452629"><hr><h6 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180459186.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180459186.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180459186"><hr><h5 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h5><ul><li><strong><code>域名解析是指把域名映射成为IP地址或把IP地址映射成域名的过程。前者称为正向解析，后者称为反向解析</code></strong></li><li><strong>当客户端需要域名解析时，通过本机的DNS客户端构造一个<code>DNS请求报文</code>，以<code>UDP数据报</code>方式发往<code>本地域名服务器</code></strong></li><li><strong>域名解析有两种方式:<code>递归查询</code>和<code>递归与迭代</code>相结合的查询</strong></li></ul><hr><h6 id="递归查询方式"><a href="#递归查询方式" class="headerlink" title="递归查询方式"></a>递归查询方式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180524307.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180524307.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180524307"><hr><h6 id="常用递归与递归相结合的查询方式"><a href="#常用递归与递归相结合的查询方式" class="headerlink" title="常用递归与递归相结合的查询方式"></a>常用递归与递归相结合的查询方式</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180532329.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180532329.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180532329"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180545176.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180545176.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180545176"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180550784.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180550784.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180550784"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180555778.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180555778.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180555778"><blockquote><ul><li><strong>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存</strong></li><li><strong>当一个DNS服务器接收到DNS查询结果时，它能将该DNS信息缓存在高速缓存中。这样，当另一个相同的域名查询到达该DNS服务器时，该服务器就能够直接提供所要求的IP地址，而不需要再去向其他DNS服务器询问</strong></li><li><strong>因为主机名和IP地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息</strong></li></ul></blockquote><hr><h3 id="第三节：FTP协议"><a href="#第三节：FTP协议" class="headerlink" title="第三节：FTP协议"></a>第三节：FTP协议</h3><h4 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h4><h5 id="FTP协议的功能"><a href="#FTP协议的功能" class="headerlink" title="FTP协议的功能"></a>FTP协议的功能</h5><ul><li><strong>文件传输协议( File Transfer Protocol, FTP)是因特网上使用得最广泛的<code>文件传输协议</code></strong></li><li><strong>FTP提供<code>交互式的访问</code>，允许客户指明文件的类型与格式，并允许文件具有<code>存取权限</code></strong></li><li><strong>它屏蔽了各计算机系统的细节，因而适合于在异构网络中的<code>任意计算机之间传送文件</code></strong></li></ul><p><strong>FTP提供以下功能:</strong></p><ul><li><strong>提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力</strong></li><li><strong>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</strong></li><li><strong>以<code>匿名FTP</code>的方式提供<code>公用文件共享</code>的能力</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180738237.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180738237.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180738237"><hr><h5 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h5><ul><li><p><strong>FTP采用客户&#x2F;服务器（C&#x2F;S）的工作方式，它使用TCP可靠的传输服务</strong></p></li><li><p><strong>一个FTP服务器进程可同时为多个客户进程提供服务</strong></p></li><li><p><strong>依照FTP协议提供服务，进行文件传送的计算机就是<code>FTP服务器</code></strong></p></li><li><p><strong>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是<code>FTP客户端</code></strong></p></li><li><p><strong><code>FTP的服务器进程</code>由两大部分组成:</strong></p></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180824712.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180824712.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180824712"><blockquote><p><strong><code>一个主进程，负责接收新的请求;若干从属进程，负责处理单个请求</code></strong></p></blockquote><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180917868.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180917868.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180917868"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180929570.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180929570.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180929570"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180941275.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180941275.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180941275"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180947639-1688132082331-461.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109180947639-1688132082331-461.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109180947639"><hr><h3 id="第四节：电子邮件系统的组成和结构"><a href="#第四节：电子邮件系统的组成和结构" class="headerlink" title="第四节：电子邮件系统的组成和结构"></a>第四节：电子邮件系统的组成和结构</h3><h4 id="电子邮件系统的组成和结构-STMP、POP3、IMAP、MIME"><a href="#电子邮件系统的组成和结构-STMP、POP3、IMAP、MIME" class="headerlink" title="电子邮件系统的组成和结构(STMP、POP3、IMAP、MIME)"></a>电子邮件系统的组成和结构(STMP、POP3、IMAP、MIME)</h4><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181202593.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181202593.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181202593"><hr><h5 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h5><ul><li><strong>一个电子邮件分为<code>信封和内容</code>两大部分，邮件<code>内容</code>又分为<code>首部和主体两部分</code></strong></li><li><strong>RFC 822规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写</strong></li><li><strong>用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息</strong></li><li><strong><code>邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成</code>。有些关键字是必需的，有些则是可选的。最重要的关键字是To:和Subject</strong></li><li><strong>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。电子邮件地址的规定格式为:收件人邮箱名@邮箱所在主机的域名，如<a href="mailto:&#97;&#98;&#99;&#64;&#99;&#x73;&#x6b;&#97;&#x6f;&#x79;&#x61;&#110;&#x2e;&#99;&#x6f;&#109;">&#97;&#98;&#99;&#64;&#99;&#x73;&#x6b;&#97;&#x6f;&#x79;&#x61;&#110;&#x2e;&#99;&#x6f;&#109;</a>,其中收信人邮箱名即用户名，abc在cskaoyan.com这个邮件服务器上必须是唯一的 。这也就保证了<a href="mailto:&#x61;&#x62;&#99;&#x40;&#99;&#115;&#x6b;&#x61;&#111;&#121;&#x61;&#x6e;&#46;&#x63;&#x6f;&#109;">&#x61;&#x62;&#99;&#x40;&#99;&#115;&#x6b;&#x61;&#111;&#121;&#x61;&#x6e;&#46;&#x63;&#x6f;&#109;</a> 这个邮件地址在整个因特网上是唯一的</strong></li><li><strong>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容</strong></li><li><strong>还有一个必填的关键字是From,但它通常由邮件系统自动填入</strong></li><li><strong>首部与主体之间用一个空行进行分割。典型的邮件内容如下:</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181330607.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181330607.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181330607"><hr><h5 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181344476.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181344476.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181344476"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181359051.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181359051.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181359051"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181406251.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181406251.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181406251"><hr><p>#####电子邮件协议</p><h6 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181418750.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181418750.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181418750"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181510586.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181510586.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181510586"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181535448.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181535448.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181535448"><hr><h6 id="MIME协议"><a href="#MIME协议" class="headerlink" title="MIME协议"></a>MIME协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181546396.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181546396.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181546396"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181551360.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181551360.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181551360"><hr><h6 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181608948.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181608948.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181608948"><ul><li><strong>邮局协议( Post Office Protocol, POP) 是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第3个版本POP3</strong></li><li><strong>POP3 采用的是“拉”(Pull)的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件</strong></li><li><strong>POP也使用客户&#x2F;服务器的工作方式，在传输层使用TCP,端口号为110。接收方的用户代理上必须运行POP客户程序，而接收方的邮件服务器上则运行POP服务器程序</strong></li><li><strong>POP有两种工作方式:<code>“下载并保留”和“下载并删除”</code></strong></li><li><strong>在<code>“下载并保留”</code>方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件;使用<code>“下载并删除”</code>方式时，邮件一旦被读取，就被从邮件服务器上删除，用户不能再次从服务器上读取</strong></li></ul><hr><h6 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181716997.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181716997.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181716997"><hr><h6 id="万维网的电子邮件"><a href="#万维网的电子邮件" class="headerlink" title="万维网的电子邮件"></a>万维网的电子邮件</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181736471-1688132172701-475.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109181736471-1688132172701-475.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109181736471"><hr><h3 id="第五节：万维网和HTTP"><a href="#第五节：万维网和HTTP" class="headerlink" title="第五节：万维网和HTTP"></a>第五节：万维网和HTTP</h3><h4 id="万维网和HTPP协议"><a href="#万维网和HTPP协议" class="headerlink" title="万维网和HTPP协议"></a>万维网和HTPP协议</h4><h5 id="www万维网"><a href="#www万维网" class="headerlink" title="www万维网"></a>www万维网</h5><h6 id="什么是万维网"><a href="#什么是万维网" class="headerlink" title="什么是万维网"></a>什么是万维网</h6><ul><li><strong><code>万维网(World Wide Web, WWW)是一个资料空间，在这个空间中:一样有用的事物称为一样“资源”,并由一个全域“统一资源定位符”(URL)标识。这些资源通过超文本传输协议(HTTP)传送给使用者，通过单击链接来获取资源</code></strong></li><li><strong>万维网使用链接的方法能让用户非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息</strong></li><li><strong>超文本标记语言(HyperText Markup Language，HTML)使得万维网页面的设计者可以很方便地用一个超链接从本页面的某处链接到因特网上的任何一个万维网页面，并能够在自己的计算机屏幕上显示这些页面</strong></li></ul><hr><h6 id="万维网的组成"><a href="#万维网的组成" class="headerlink" title="万维网的组成"></a>万维网的组成</h6><p><strong>万维网的内核部分是由三个标准构成的:</strong></p><ul><li><strong>统一资源定位符(URL)。 负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符URL</strong></li><li><strong>超文本传输协议(HTTP)。 一个应用层协议，它使用TCP连接进行可靠的传输，HTTP是万维网客户程序和服务器程序之间交互所必须严格遵守的协议</strong></li><li><strong>超文本标记语言(HTML)。 一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息(包括文字、声音、图像、视频等)、格式进行描述</strong></li></ul><hr><h6 id="URL—统一资源定位符"><a href="#URL—统一资源定位符" class="headerlink" title="URL—统一资源定位符"></a>URL—统一资源定位符</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182127222.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182127222.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182127222"><ul><li><strong>URL是对可以从因特网上得到的资源的位置和访问方法的一种简洁表示。URL相当于一个文件名在网络范围的扩展</strong></li><li><strong>URL的一般形式是: &lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;。常见的&lt;协议&gt;有http、ftp 等。&lt; (主机&gt;是存放资源的主机在因特网中的域名，也可以是IP地址。&lt;端口&gt;和&lt;路径&gt;有时可以省略</strong></li><li><strong><code>在URL中不区分大小写</code></strong></li></ul><hr><h6 id="万维网工作流程"><a href="#万维网工作流程" class="headerlink" title="万维网工作流程"></a>万维网工作流程</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182248170.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182248170.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182248170"><hr><h5 id="HTTP—超文本传输协议"><a href="#HTTP—超文本传输协议" class="headerlink" title="HTTP—超文本传输协议"></a>HTTP—超文本传输协议</h5><ul><li><strong>HTTP定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</strong></li><li><strong>从层次的角度看，HTTP是面向事务的(Transaction-oriented) 应用层协议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件(包括文本、声音、图像等各种多媒体文件)的重要基础</strong></li></ul><hr><h6 id="HTTP操作过程"><a href="#HTTP操作过程" class="headerlink" title="HTTP操作过程"></a>HTTP操作过程</h6><blockquote><ul><li><strong>在浏览器和服务器之间的请求与响应的交互，必须遵循规定的格式和规则，这些格式和规则就是HTTP</strong></li><li><strong>因此HTTP有两类报文:</strong><ul><li><strong><code>请求报文</code>(从Web客户端向Web服务器发送服务请求)</strong></li><li><strong><code>响应报文</code>(从Web服务器对Web客户端请求的回答)</strong></li></ul></li></ul></blockquote><ul><li><strong>从协议执行过程来说，浏览器要访问WWW服务器时，首先要完成对www服务器的<code>域名解析</code></strong></li><li><strong>一旦获得了服务器的IP地址，<code>浏览器</code>就通过TCP向服务器<code>发送连接建立请求</code>。万维网的大致工作过程如图所示</strong></li></ul><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182425585.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182425585.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182425585"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182434081.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182434081.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182434081"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182444508.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182444508.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182444508"><hr><h6 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182500492.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182500492.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182500492"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182508252.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182508252.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182508252"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182515064.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182515064.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182515064"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182520089.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182520089.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182520089"><hr><h6 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182529393.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182529393.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182529393"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182539242.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182539242.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182539242"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182549003.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182549003.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182549003"><hr><h6 id="WireShark捕获HTTP报文实例"><a href="#WireShark捕获HTTP报文实例" class="headerlink" title="WireShark捕获HTTP报文实例"></a>WireShark捕获HTTP报文实例</h6><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182556542.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182556542.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182556542"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182603368.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182603368.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182603368"><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182609617.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182609617.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182609617"><hr><h5 id="常用应用程序的协议及端口号"><a href="#常用应用程序的协议及端口号" class="headerlink" title="常用应用程序的协议及端口号"></a>常用应用程序的协议及端口号</h5><img src="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182622178-1688132395237-492.png" class="lazyload placeholder" data-srcset="/2023/04/20/zhuan-ye-he-xin-ji-chu-li-lun-ji-suan-ji-wang-luo/image-20230109182622178-1688132395237-492.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230109182622178">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;专业核心理论基础：计算机网络&quot;&gt;&lt;a href=&quot;#专业核心理论基础：计算机网络&quot; class=&quot;headerlink&quot; title=&quot;专业核心理论基础：计算机网络&quot;&gt;&lt;/a&gt;专业核心理论基础：计算机网络&lt;/h1&gt;&lt;h2 id=&quot;第一章：计算机网络体系结构&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="专业核心基础理论(九大件)" scheme="https://not-go.github.io/categories/%E4%B8%93%E4%B8%9A%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-%E4%B9%9D%E5%A4%A7%E4%BB%B6/"/>
    
    
    <category term="专业核心基础理论" scheme="https://not-go.github.io/tags/%E4%B8%93%E4%B8%9A%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>低谷期成长日志</title>
    <link href="https://not-go.github.io/2023/04/08/wo-de-linux-ri-zhi/"/>
    <id>https://not-go.github.io/2023/04/08/wo-de-linux-ri-zhi/</id>
    <published>2023-04-08T04:20:00.000Z</published>
    <updated>2023-06-27T03:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="低谷期成长日志"><a href="#低谷期成长日志" class="headerlink" title="低谷期成长日志"></a>低谷期成长日志</h1><blockquote><p><font color=red><strong>很长一段时间没有写技术博客了，这段时间一直把自己沉没在DIY一个ArchLinux系统，其实主要还是受了些求职打击，无所事事，就想做些自己感兴趣的东西来度过这段糟糕的时间。当我写下这篇博客的时候，我大抵是走出低谷期了，这段时间很放纵，但我的心态也确实变好了。后续的时间准备去考研了，放一放技术，有时候不得不承认，学历真的决定很多！</strong></font></p></blockquote><p><font color=red><strong>简单介绍一下我自己吧，我目前是一名大三下的双非本科C++方向程序员，从大二开始学习C++一直到大三上，去两个小公司实习过一段时间，目前投递简历已无人看，所以才想自己瞎折腾下ArchLinux，算是给自己找点乐子，目前这套系统已经被我压入U盘内了，所有编码环境都已内置，即插即用，方便未来使用</strong></font></p><img src="/2023/04/08/wo-de-linux-ri-zhi/image-20230602102410446.png" class="lazyload placeholder" data-srcset="/2023/04/08/wo-de-linux-ri-zhi/image-20230602102410446.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230602102410446"><ul><li><strong>ISO文件网盘地址：<a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://pan.baidu.com/s/18DVvWwdCJBg3Hwl9kf-IPg?pwd=jian">建波的ArchLinux</a></strong></li><li><strong>密码：jian</strong></li><li><strong>安装后请看以下网页进行主题选择(建议看下官网craftwiki)：<a href="https://archcraft.io/gallery.html">https://archcraft.io/gallery.html</a></strong></li><li><strong>安装主题命令：sudo pacman -S archcraft-主题名 或 yay -S archcraft-主题名。例如：sudo pacman -S archcraft-Hypland</strong></li><li><strong><font color=red>注意：先玩过基本的Linux，在来玩Arch，我这里也不提及基本的换源、中文输入法配置问题，懂得都懂。我也是从Ubantu-&gt;CentOs-&gt;Manjaro-&gt;ArchLinux过来的，过程异常折磨与心酸</font></strong></li><li><strong>一点小心思：上面的系统只是镜像，我当然没有把配置好的镜像直接给你们，因为它可以DIY，每个人想要的形状不一样，所以我写了一份配置笔记，感兴趣的自己去看吧</strong></li><li><strong>配置笔记：<a href="https://gitee.com/Not_Go/arch-linux_i3wm/tree/master/.config">我的ArchLinux配置笔记</a>，配置文件比较多，可以直接cp进行.config替换</strong></li></ul><img src="/2023/04/08/wo-de-linux-ri-zhi/image-20230602105605319.png" class="lazyload placeholder" data-srcset="/2023/04/08/wo-de-linux-ri-zhi/image-20230602105605319.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230602105605319"><img src="/2023/04/08/wo-de-linux-ri-zhi/image-20230602105619013.png" class="lazyload placeholder" data-srcset="/2023/04/08/wo-de-linux-ri-zhi/image-20230602105619013.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230602105619013"><blockquote><p><strong><mark>以下是一些参考的外网文档和官方文档，这些文档是全英文，涉及语言有C、C++、Rust、Go、Python、PHP以及配置文件，大约20w+源码，我都看完了，推荐大家可以看看：</mark></strong></p><ol><li><strong><a href="https://wiki.archlinux.org/">ArchWiki(ArchLinux官方文档，所有问题都能在上面找到答案)</a></strong></li><li><strong><a href="https://i3wm.org/docs/userguide.html">I3wm-UserGuide(i3wm的官方文档，解释i3wm的所有技术实现和功能)</a></strong></li><li><strong><a href="https://aur.archlinux.org/">AUR软件仓库(下载各种最先软件的仓库地址)</a></strong></li></ol><p><strong>推荐的UP：<a href="https://space.bilibili.com/13081489/?spm_id_from=333.999.0.0">TheCW</a>，这是一个究极大佬，初中就玩Linux，目前在美国Adobe上班，我也是从他哪里重获的信心</strong></p></blockquote><p><font color=green><strong>下面是我折腾完的页面效果，我使用的是窗口管理器，也就是大家常说的I3WM、DWM、Hypland这些：</strong></font></p><blockquote><p><strong>简单向大家介绍一下窗口管理器吧：窗口管理器简单来说就是可以把所有的界面都平铺到桌面上，<mark>可以不在使用鼠标</mark>，而是使用快捷键进行各个窗口的放大、缩小、全屏、浮动、切换等功能，当然这些需要深入更改代码和配置文件，这算是一个技能难点！窗口管理器如果你是编程老手你会非常喜欢，因为他省略了鼠标操作，让所有操作都可以自行设置和通过键盘实现，所以使用窗口管理器的人大多都是喜欢<mark>高效编码环境</mark>的人</strong></p></blockquote><img src="/2023/04/08/wo-de-linux-ri-zhi/hypr_catppuccin_3.png" class="lazyload placeholder" data-srcset="/2023/04/08/wo-de-linux-ri-zhi/hypr_catppuccin_3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="hypr_catppuccin_3"><img src="/2023/04/08/wo-de-linux-ri-zhi/5.png" class="lazyload placeholder" data-srcset="/2023/04/08/wo-de-linux-ri-zhi/5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="5"><img src="/2023/04/08/wo-de-linux-ri-zhi/8.png" class="lazyload placeholder" data-srcset="/2023/04/08/wo-de-linux-ri-zhi/8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="8"><img src="/2023/04/08/wo-de-linux-ri-zhi/hypr_dark_4.png" class="lazyload placeholder" data-srcset="/2023/04/08/wo-de-linux-ri-zhi/hypr_dark_4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="hypr_dark_4"><img src="/2023/04/08/wo-de-linux-ri-zhi/hypr_catppuccin_5.png" class="lazyload placeholder" data-srcset="/2023/04/08/wo-de-linux-ri-zhi/hypr_catppuccin_5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="hypr_catppuccin_5">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;低谷期成长日志&quot;&gt;&lt;a href=&quot;#低谷期成长日志&quot; class=&quot;headerlink&quot; title=&quot;低谷期成长日志&quot;&gt;&lt;/a&gt;低谷期成长日志&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;font color=red&gt;&lt;strong&gt;很长一段时间没有写技术博客</summary>
      
    
    
    
    <category term="低谷期成长日志" scheme="https://not-go.github.io/categories/%E4%BD%8E%E8%B0%B7%E6%9C%9F%E6%88%90%E9%95%BF%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="低谷期成长" scheme="https://not-go.github.io/tags/%E4%BD%8E%E8%B0%B7%E6%9C%9F%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络基础概念</title>
    <link href="https://not-go.github.io/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/"/>
    <id>https://not-go.github.io/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/</id>
    <published>2023-03-20T04:20:00.000Z</published>
    <updated>2023-06-23T18:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux网络基础概念"><a href="#Linux网络基础概念" class="headerlink" title="Linux网络基础概念"></a>Linux网络基础概念</h1><h2 id="计算机网络的发展过程"><a href="#计算机网络的发展过程" class="headerlink" title="计算机网络的发展过程"></a>计算机网络的发展过程</h2><h3 id="独立模式"><a href="#独立模式" class="headerlink" title="独立模式"></a>独立模式</h3><blockquote><p><strong><font color=red>独立模式: 计算机之间相互独立</font></strong></p></blockquote><p><strong><font color=green>在早期的时候，计算机之间是相互独立的，此时如果多个计算机要协同完成某种业务，那么就只能等一台计算机处理完后再将数据传递给下一台计算机，然后下一台计算机再进行相应的业务处理，效率非常低下</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206220244913.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206220244913.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206220244913"><hr><h3 id="网络互联模式"><a href="#网络互联模式" class="headerlink" title="网络互联模式"></a>网络互联模式</h3><blockquote><p><strong><font color=red>网络互联: 多台计算机连接在一起, 完成数据共享</font></strong></p></blockquote><p><strong><font color=green>独立模式太麻烦了，这时就有人设法将这些计算机连接在一起，当某个业务需要多台计算机协同完成时，就可以将共享的数据放到服务器中进行集中管理，此时各个计算机就都能获取到这些共享的数据，所以各个业务在处理就能随时进行切换了</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206220626542.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206220626542.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206220626542"><hr><h3 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网 LAN"></a>局域网 LAN</h3><blockquote><p><strong><font color=red>局域网LAN: 计算机数量更多了, 通过交换机和路由器连接在一起</font></strong></p></blockquote><p><strong><font color=green>后来这样的网络雏形逐渐发展，连入这个网络中的机器变得越来越多，于是就出现了局域网的概念，在局域网中有一种设备叫做交换机，交换机主要完成局域网内数据的转发工作，也就是在局域网内将数据从一台主机转发给另一台主机。各个局域网之间通过路由器连接起来，路由器主要完成数据的路由转发工作</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206220831173.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206220831173.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206220831173"><hr><h3 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网 WAN"></a>广域网 WAN</h3><blockquote><p><strong><font color=red>广域网WAN: 将远隔千里的计算机都连在一起</font></strong></p></blockquote><p><strong><font color=green>各个局域网之间通过路由器相互连接在一起，便组成了一个更大的网络结构，我们将其称之为广域网。实际局域网和广域网是一种相对的概念，我们也可以将广域网看作一个比较大的局域网</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206221033271.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206221033271.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206221033271"><hr><h2 id="计算机网络协议"><a href="#计算机网络协议" class="headerlink" title="计算机网络协议"></a>计算机网络协议</h2><h3 id="协议的概念"><a href="#协议的概念" class="headerlink" title="协议的概念"></a>协议的概念</h3><blockquote><ul><li><strong><mark>“协议”本质就是一种约定，通信双方只要曾经做过某种约定，之后就可以使用这种约定来完成某种事情。而网络协议是通信计算机双方必须共同遵从的一组约定，因此我们一定要将这种约定用计算机语言表达出来，此时双方计算机才能识别约定的相关内容</mark></strong></li><li><strong><font color=red>协议是双方约定同一种语言，进行沟通，计算机之间的传输媒介是光信号和电信号。通过 “频率” 和 “强弱” 来表示 0 和 1 这样的信息.，要想传递各种不同的信息，就需要约定好双方的数据格式</font></strong></li><li><strong><font color=blue>协议总是指某一层的协议。准确地说，它是在同等层之间的实体通信时，有关通信规则和约定的集合就是该层协议，例如物理层协议、传输层协议、应用层协议</font></strong></li></ul></blockquote><hr><h3 id="什么是网络协议"><a href="#什么是网络协议" class="headerlink" title="什么是网络协议"></a>什么是网络协议</h3><blockquote><ul><li><strong><mark>计算机生产厂商有很多，计算机操作系统, 也有很多，计算机网络硬件设备, 还是有很多，如何让这些不同厂商之间生产的计算机能够相互顺畅的通信呢?</mark></strong></li><li><strong><code>这就需要有人站出来, 约定一个共同的标准,大家都来遵守, 这就是网络协议</code></strong></li><li><strong><font color=red>网络协议是通信双方，进行网络通信时，约定通信所使用的数据格式</font></strong></li></ul></blockquote><hr><h3 id="什么是网络协议簇"><a href="#什么是网络协议簇" class="headerlink" title="什么是网络协议簇"></a>什么是网络协议簇</h3><p><strong><mark>网络协议簇：指的是由很多网络协议组成的簇群，称之为协议簇</mark></strong></p><hr><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><blockquote><ul><li><strong><font color=red>OSI（Open System Interconnection，开放系统互联）七层网络模型称为<code>开方式系统互联参考模型</code>，是一个逻辑上的定义和规范</font></strong></li><li><strong><font color=red>OSI 把网络从逻辑上分为了七层，每一层都有相关的、相对应的物理设备，比如路由器，交换机</font></strong></li><li><strong><font color=red>OSI 七层模型是一种框架性的设计方法，其<mark>最主要的功能就是帮助不同类型的主机实现数据传输</mark>，比如手机和电视之间数据的传输</font></strong></li><li><strong><font color=red>OSI 七层模型<mark>最大的优点是将服务、接口和协议这三个概念明确的区分开来</mark>，概念清楚，理论也比较完整，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯</font></strong></li><li><strong><font color=red>但是，OSI七层模型既复杂又不实用，所以后来在具体实现的时候就对其进行了调整，于是就有了我们现在知道的的TCP&#x2F;IP四层协议</font></strong></li></ul><p><strong><mark>如下图：</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206223143150.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206223143150.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206223143150"></blockquote><p><strong><code>OSI七层模型图：</code></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206222957268.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206222957268.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206222957268"><hr><h3 id="TCP-x2F-IP-五层模型"><a href="#TCP-x2F-IP-五层模型" class="headerlink" title="TCP&#x2F;IP 五层模型"></a>TCP&#x2F;IP 五层模型</h3><p><strong><font color=red>TCP&#x2F;IP是一组协议的代名词，它还包括许多协议，共同组成了TCP&#x2F;IP协议簇。TCP&#x2F;IP通讯协议采用了五层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求</font></strong></p><blockquote><p><strong><font color=red>由于一些历史问题，我们有时候说<code>TCP/IP协议簇是四层也可以是五层</code>，因为规定了<mark>网络接口层&#x3D;数据链路层+物理层</mark>，我们一般还是说五层，方便与OSI一起记忆，如下图：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206223909340.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206223909340.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206223909340"></blockquote><p><strong><mark>各层的作用：</mark></strong></p><blockquote><ul><li><strong>物理层：</strong> 负责光&#x2F;电信号的传递方式。比如现在以太网通用的网线（双绞线）、早期以太网采用的同轴电缆（现在主要用于有线电视）、光纤，现在的WiFi无线网使用的电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等。集线器（Hub）就是工作在物理层的</li><li><strong>数据链路层：</strong> 负责设备之间的数据帧的传送和识别。例如网卡设备的驱动、帧同步、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。数据链路层底层的网络通信标准有很多，如以太网、令牌环网、无线LAN等。交换机（Switch）就是工作在数据链路层的</li><li><strong>网络层：</strong> 负责地址管理和路由选择。例如在IP协议中，通过IP地址来标识一台主机，并通过路由表的方式规划出两台主机之间数据传输的线路（路由）。路由器（Router）就是工作在网络层的</li><li><strong>传输层：</strong> 负责两台主机之间的数据传输。例如传输控制协议（TCP），能够确保数据可靠的从源主机发送到目标主机</li><li><strong>应用层：</strong> 负责应用程序间沟通。比如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。我们的网络编程主要就是针对应用层的</li></ul></blockquote><p><strong><mark>与OSI七层模型各层的对应关系：</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206224216308.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206224216308.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206224216308"><hr><h2 id="网络传输基本流程"><a href="#网络传输基本流程" class="headerlink" title="网络传输基本流程"></a>网络传输基本流程</h2><h3 id="同局域网内的两台主机通信"><a href="#同局域网内的两台主机通信" class="headerlink" title="同局域网内的两台主机通信"></a>同局域网内的两台主机通信</h3><p><strong><font color=red>首先需要明确的是，同一个局域网内的主机是能够直接进行通信的，因为最初局域网设计的目的，就是为了让局域网内的主机能够进行通信</font></strong></p><ul><li><strong><mark>网络数据的转发需要先经历自己的网络协议栈，进而通过网络将数据转化为光电信号，传输到对端机器，对端机器收到数据之后，需要经历自己的机器网络协议栈的层层向上提交，一直将数据提交到应用层的应用程序当中，如下图：</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206224654913.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206224654913.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206224654913"><blockquote><p><strong><font color=red>当用户要将文件传输给另一台主机前，该文件数据需要先通过网络协议栈进行封装：(FTP客户 -&gt; 以太网驱动程序 )</font></strong></p><ul><li><strong><mark>文件数据先交给应用层，应用层添加上对应应用层协议的报头信息后，将数据再交给传输层</mark></strong></li><li><strong><mark>传输层收到数据后，再添加上对应传输层协议的报头信息，并将数据继续向下进行交付</mark></strong></li><li><strong><mark>网络层收到数据后，再添加上对应网络层协议的报头信息，接着将数据再交给链路层</mark></strong></li><li><strong><mark>链路层收到数据后，最后再添加上对应链路层协议的报头信息，至此数据封装完毕</mark></strong></li></ul><hr><p><strong><font color=red>数据封装完毕后就可以通过局域网将其发送给对端主机了，而当对端主机收到数据后，对应也需要通过网络协议栈对该数据进行解包与分用：(以太网驱动程序 -&gt; FTP客户)</font></strong></p><ul><li><strong><mark>链路层收到数据后，先将数据中对应链路层协议的报头信息提取出来，然后将剩下的数据交给网络层</mark></strong></li><li><strong><mark>网络层收到该数据后，再将数据中对应网络层协议的报头信息提取出来，然后将剩下的数据继续向上进行交付</mark></strong></li><li><strong><mark>传输层收到该数据后，再将数据中对应传输层协议的报头信息提取出来，然后将剩下的数据再交付给应用层</mark></strong></li><li><strong><mark>应用层收到数据后，最后将数据中对应应用层协议的报头信息提取出来，至此便完成了数据的解包与分用</mark></strong></li></ul></blockquote><p><strong><code>也就是说，任何一台主机在发送数据之前，该数据都要先自顶向下贯穿协议栈来完成数据的封装，在这个过程中，每一层协议都会添加上对应的报头信息；而任何一台主机收到数据后，都要先自底向上贯穿协议栈来完成数据的解包和分用，在这个过程中，每一层协议都会将对应的报头信息提取出来</code></strong></p><p><strong><font color=red>一些概念的补充：</font></strong></p><blockquote><p><strong><code>概念一：数据包封装和分用</code></strong></p><ul><li><strong><font color=red>不同协议层对数据包有不同的称谓</font>，在<code>传输层叫做段（segment）</code>，在<code>网络层叫做数据报（datagram）</code>，在<code>链路层叫做帧（frame）</code></strong></li><li><strong><mark>应用层数据通过协议栈发到网络上，每层协议都要加上一个数据首部（header），称为封装（Encapsulation）</mark></strong></li><li><strong><mark>首部信息中包含了一些类似于首部有多长，载荷（payload）有多长，上层协议是什么等信息</mark></strong></li></ul><p><strong><font color=green>下图为数据封装的过程：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206230729126.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206230729126.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206230729126"><p><strong><font color=green>下图为数据分用的过程：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206230824022.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206230824022.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206230824022"><hr><p><strong><code>概念二：什么是报头</code></strong></p><ul><li><strong><font color=red>报头本质也是一种数据，报头一般是通过位段实现的，因此协议栈的每一层都有一个对应的位段来表示当前层的报头</font></strong></li></ul><p><strong><mark>数据的封装与解包：</mark></strong></p><ul><li><strong><code>数据封装</code>，实际就是不断给数据加上各种对应的报头，这些报头里面填充的就是对应的各种协议细节</strong></li><li><strong><code>数据解包</code>，实际就是不断从数据中提取对应的报头，并对提取出来的报头进行数据分析</strong></li></ul><hr><p><strong><code>概念三：报头与有效载荷</code></strong></p><ul><li><strong><font color=red>当对端主机收到数据后，需要自底向上贯穿协议栈，依次进行数据的解包与分用。在这个解包的过程中，每一层的协议只需要提取出数据中对应的报头，然后对该报头进行分析处理，而剩下的数据则直接交付给上层就行了</font></strong></li><li><strong><font color=red>因为每一层的协议实际上只关心数据中与当前层对应的报头信息，而剩下信息的具体内容根本不必关心，我们将数据中除当前层的报头以外的数据叫做“有效载荷”</font></strong></li><li><strong><font color=red>需要注意的是，上层协议在数据封装时添加的报头信息，在下层协议进行数据解包时看来就是有效载荷。比如数据封装时应用层添加的报头信息，在对端主机进行数据解包时，在对端主机的传输层、网络层以及链路层看来，该应用层曾经添加的报头信息就是有效载荷</font></strong></li></ul><p><strong><font color=blue>那我们如何将报头与有效载荷进行分离呢？</font></strong></p><ul><li><strong><mark>协议栈的每一层都要从数据中提取对应的报头信息，而要将数据中的报头提取出来，首先就需要明确报头与有效载荷之间的界限，这样才能将它们进行分离。而每一层添加报头时都是将报头添加到数据的首部的，因此我们只要知道了报头的大小，就能够讲报头和有效载荷进行分离</mark></strong></li></ul><p><strong><mark>获取报头大小的方法通常有两种：</mark></strong></p><ul><li><strong><mark>定长报头</mark>。顾名思义就是报头的大小是固定的</strong></li><li><strong><mark>自描述字段</mark>。报头当中提供了一个字段，用来表示报头的长度</strong></li><li><strong>实际上每个协议都要提供一种方法，让我们获取到报头的大小，这样我们才能在解包时将报头与有效载荷进行分离</strong></li></ul><p><strong><mark>当前层如何知道应该将有效载荷交付给上层的哪个协议？</mark></strong></p><ul><li><strong>实际在每种协议的报头当中，几乎都会包含一个字段，表明我们应该把分离出来的有效载荷交付给上层的哪个协议，这就是分用的过程</strong></li></ul><hr><p><strong><code>概念四：协议共性</code></strong></p><ul><li><strong><mark>提供一个将报头与有效载荷分离的方法</mark></strong></li><li><strong><mark>协议当中必须包含一个字段，表明应该将有效载荷交付给上层的哪个协议</mark></strong></li><li><strong>实际当我们要学习一种协议的时候，首先就应该明确这两点，因为当我们在解包的时候必须将报头与有效载荷分离，而当我们在分用的时候必须知道应该将有效载荷交付给上层的哪个协议</strong></li></ul><hr><p><strong><code>概念五：什么是碰撞</code></strong></p><ul><li><p><strong><mark>当主机A在向主机B发送数据时，其他主机彼此之间可能也正在进行通信，甚至主机A在和主机B通信的同时也在和其他主机进行通信</mark></strong></p></li><li><p><strong><mark>但同一局域网中的所有主机在通信时，使用的都是一个共同的通信信道，因此如果局域网内的多台主机同时进行通信，此时这些数据之间就可能会相互干扰</mark></strong></p></li><li><p><strong><mark>每一个局域网都可以看作是一个碰撞域，如果某个主机发送出去的数据与其他主机发送的数据之间产生了干扰，我们就称这两台主机在该碰撞域中发生了碰撞</mark></strong></p></li></ul><p><strong>如何判断发送出去的数据是否发生了碰撞？</strong></p><ul><li><strong>因为发送到局域网当中的数据是所有主机都能够收到的，因此当一个主机将数据发送出去后，该主机本身也是能够收到这个数据的。当该主机收到该数据后就可以将其与之前发送出去的数据进行对比，如果发现收到的数据与之前发送出去的数据不相同，则说明在发送过程中发生了碰撞，也就是说，主机实际是能够通过某种方式，知道曾经发送出去的数据是否发生了碰撞的</strong></li></ul><p><strong>发生碰撞后是如何处理的？</strong></p><ul><li><strong>当一个主机发现自己发送出去的数据产生了碰撞，此时该主机就要执行“碰撞避免”算法。“碰撞避免”算法实际很简单：当一个主机发送出去的数据产生了碰撞，那么该主机可以选择等一段时间后，再重新发送该数据。这就像现实生活中的两个人同时想要说话，此时对方就都会说“你先说吧”，这实际上就是一种碰撞避免</strong></li></ul></blockquote><hr><h3 id="跨网络的两台主机通信"><a href="#跨网络的两台主机通信" class="headerlink" title="跨网络的两台主机通信"></a>跨网络的两台主机通信</h3><p><strong><mark>上面说的都是同一局域网内的主机之间的通信，那跨局域网的两台主机之间是如何进行通信的呢？</mark></strong></p><blockquote><ul><li><strong><font color=red>局域网之间都是通过路由器连接起来的，因此一个路由器至少能够横跨两个局域网。而这些被路由器级联局域网都认为，该路由器就是本局域网内的一台主机，因此路由器可以和这些局域网内的任意一台主机进行直接通信</font></strong></li><li><strong><font color=red>比如局域网1当中的主机A想要和局域网2当中的主机H进行通信，那么主机A可以先将数据发送给路由器，然后路由器再将数据转发给局域网2当中的主机H</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206230046290.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221206230046290.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221206230046290"></blockquote><blockquote><p><strong>如果采用不同通信标准的两个局域网内的主机通信呢？</strong></p></blockquote><p><strong><font color=red>如果路由器级联的两个局域网采用的是相同的通信标准，那么通信过程大致就是上述那样。但被路由器级联的局域网可能采用的是不同的通信标准，比如局域网1采用的是以太网，而局域网2采用的却是令牌环网</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207111352565.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207111352565.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221207111352565"><blockquote><ul><li><strong><mark>由于以太网和令牌环网是不同的通信标准，它们给数据添加的报头也是不一样的，因此令牌环网当中的主机无法对以太网当中的数据帧进行解包</mark></strong></li><li><strong><mark>这种情况实际是由路由器来处理的，路由器是工作在网络层的一个设备，我们可以认为路由器当中的协议栈是下面这样的：</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207111420173.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207111420173.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221207111420173"><ul><li><strong><font color=red>此时当数据要从局域网1发送到局域网2时，路由器收到局域网1的数据后，会先将以太网对应的报头进行解包，然后将剩下的数据向上交付给网络层，在网络层进行一系列数据分析后，再将数据向下交付给链路层，此时在链路层当中就会给该数据添加上令牌环对应的报头信息，然后再将该数据发送到局域网2当中，此时该数据就能够在令牌环网当中传输了</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207111445155.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207111445155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221207111445155"></blockquote><hr><h2 id="各层间的通讯"><a href="#各层间的通讯" class="headerlink" title="各层间的通讯"></a>各层间的通讯</h2><p><strong><code>发送方与接收方各层之间必须采用相同的协议才能建立连接，实现正常的通信</code></strong></p><blockquote><ul><li><strong><font color=red>应用层之间必须采用<code>相同的编码解码规则</code>，才能保证用户信息传输的正确性</font></strong></li><li><strong><font color=red>传输层之间必须采用<code>相同的端口号与协议关系</code>，才能保证上层应用进程间的通信</font></strong></li><li><strong><font color=red>网络层之间必须采用<code>相同的逻辑寻址过程</code>才能保证数据不会传输到错误的目的地</font></strong></li><li><strong><font color=red>数据链路层之间<code>如果协议不同</code>，接收方无法“理解”数据的内容</font></strong></li><li><strong><font color=red>物理层之间必须<code>硬件接口规格相同</code>，否则接收不到信号</font></strong></li></ul></blockquote><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207112339146.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207112339146.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221207112339146"><p><strong><mark>在实际的网络环境中，发送方和接受方之间会有很多的硬件设备起到中转的作用，在下图中假设了一种通信结构，在两台计算机之间增加了两台交换机和路由器，发送主机的数据会通过以下中间设备到达接受主机</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207112407356.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-ji-chu-gai-nian/image-20221207112407356.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221207112407356"><p><strong><code>步骤解析：</code></strong></p><blockquote><ul><li><strong>发送主机按照前面讲解的内容进行数据封装</strong></li><li><strong>从发送主机物理网卡发出的电信号通过网线到达交换机，交换机将电信号转换成二进制数据送往交换机的数据链路层。交换机根据数据帧头部的MAC地址将数据智能转发到对应的路由器设备，在转发前要重新将二进制数据转换成物理的电信号</strong></li><li><strong>路由器接受到数据后，会拆掉数据链路层的MAC头部信息，将数据包送往网络层，路由器将检测数据包头部的目标IP地址信息，并根据该信息进行路由转发，将数据报文转发到下一路由器上，在转发前要重新封装新的MAC头部信息，并将数据转换成二进制</strong></li><li><strong>之后的过程与前面大同小异。简单来说就是路由器接受电信号，将电信号转换成二进制数据发往网络层，然后根据MAC地址和IP地址进行重新封装转换为电信号进行转发，然后对应的交换机接受电信号，然后根据MAC地址传送到接收主机的网卡中</strong></li></ul></blockquote><hr><h2 id="认识IP地址"><a href="#认识IP地址" class="headerlink" title="认识IP地址"></a>认识IP地址</h2><p><strong><font color=red>IP协议有两个版本, IPv4和IPv6. 整个的课程, 凡是提到IP协议, 没有特殊说明的, 默认都是指IPv4</font></strong></p><ul><li><strong><code>IP地址是在IP协议中, 用来标识网络中不同主机的地址</code></strong></li><li><strong><code>对于IPv4来说, IP地址是一个4字节, 32位的整数</code></strong></li><li><strong><code>我们通常也使用 “点分十进制” 的字符串表示IP地址, 例如 192.168.0.1 ; 用点分割的每一个数字表示一个字节, 范围是 0 - 255</code></strong></li></ul><p> <strong><font color=red>IP地址的作用：可以在网络当中唯一标识一台主机，一个公网IP地址只能被一台机器所占有，一个机器可以拥有多个IP地址</font></strong></p><hr><h2 id="认识MAC地址"><a href="#认识MAC地址" class="headerlink" title="认识MAC地址"></a>认识MAC地址</h2><p><strong><font color=red>MAC地址用来识别数据链路层中相连的节点</font></strong></p><ul><li><strong><mark>长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19）</mark></strong></li><li><strong><mark>长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19）</mark></strong></li></ul><p><strong><font color=green>对于接收方而言，所有的网络数据都是需要经历网络协议栈的，但是，怎么区分网络数据到底属于哪一个应用程序的呢？</font></strong></p><blockquote><p><strong><code>通过端口进行区分</code></strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux网络基础概念&quot;&gt;&lt;a href=&quot;#Linux网络基础概念&quot; class=&quot;headerlink&quot; title=&quot;Linux网络基础概念&quot;&gt;&lt;/a&gt;Linux网络基础概念&lt;/h1&gt;&lt;h2 id=&quot;计算机网络的发展过程&quot;&gt;&lt;a href=&quot;#计算机网络的发</summary>
      
    
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络协议之HTPP协议(应用层)</title>
    <link href="https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/"/>
    <id>https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/</id>
    <published>2023-03-20T04:19:00.000Z</published>
    <updated>2023-06-23T18:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux网络协议之HTTP协议-应用层"><a href="#Linux网络协议之HTTP协议-应用层" class="headerlink" title="Linux网络协议之HTTP协议(应用层)"></a>Linux网络协议之HTTP协议(应用层)</h1><h2 id="HTTP协议的概念"><a href="#HTTP协议的概念" class="headerlink" title="HTTP协议的概念"></a>HTTP协议的概念</h2><blockquote><ul><li><strong><code>HTTP（HyperText Transfer Protocol）：</code><font color=red>超⽂本传输协议</font></strong></li><li><strong><font color=red>HTTP是⽆连接， ⽆状态， ⼯作在应⽤层的协议</font></strong></li><li><strong>TCP在传输数据的时候，是需要建立连接的</strong></li><li><strong>⽆连接理解为： HTTP协议本身是没有维护连接信息的， HTTP的数据会交给⽹络协议栈传输层的TCP协议， ⽽TCP是⾯向连接的</strong></li><li><strong>⽆状态理解为： HTTP协议⾃身不对请求和响应之间的通信状态进⾏保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理</strong></li></ul></blockquote><p><strong><font color=red>一点小思考：HTTP是无连接的，不会维护连接信息，那么它是否是可靠数据？</font></strong></p><ul><li><strong><font color=red>HTTP是可靠传输的，虽然HTTP无连接，自身不会维护连接信息，但是，它的数据最终会交给传输层的TCP协议，而TCP协议是可靠传输的，因此HTTP协议是可靠传输的</font></strong></li></ul><hr><h2 id="HTTP协议中URL的理解"><a href="#HTTP协议中URL的理解" class="headerlink" title="HTTP协议中URL的理解"></a>HTTP协议中URL的理解</h2><p><strong><code>URL（Uniform Resource Location）：</code><font color=red>统一资源定位符，其实就是我们说的”网址”</font></strong></p><p><strong><font color=green>比如下图我们对URL的组成部分划分：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217212536362.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217212536362.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217212536362"><blockquote><ul><li><strong><font color=red>http：明文传输，默认端口为80端口</font></strong></li><li><strong><font color=red>https：加密传输，默认端口是443端口(一般用ssl非对称加密方式,会对http双方发送的数据进行加密，公钥：客户端所持有，私钥：服务端所持有)</font></strong></li></ul></blockquote><p><strong><font color=green>在URL的组成中，我们要注意一些字符被当作特殊意义来理解，比如下面：</font></strong></p><ul><li><strong><code>比如， / ? : 等这样的字符, 已经被url当做特殊意义理解了。因此这些字符不能随意出现。比如, 某个参数中需要带有这些特殊字符, 就必须先对特殊字符进行转义</code></strong></li></ul><p><strong><font color=red>转义字符规则如下：</font></strong></p><blockquote><ul><li><strong><code>将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY格式</code></strong></li><li><strong><code>urlencode：将字符转换成为16进制</code></strong></li><li><strong><code>urlecode：将16进制数据转换成字符</code></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217214058045.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217214058045.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217214058045"><ul><li><strong><mark>比如这里我们看到我们搜索c++，这里的+就被替换成了%2B，这里的&amp;是分隔符的意思，分割key_value键值对</mark></strong></li></ul></blockquote><p><strong><font color=red>最后我们来自己看看URL的组成结构，如下图：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217214518734.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217214518734.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217214518734"><blockquote><ul><li><strong><font color=red>使⽤ http: 或 https: 等协议⽅案名获取访问资源时要指定协议类型。不区分字⺟⼤⼩写，最后附⼀个冒号（:）</font></strong></li><li><strong><font color=red>登录信息（认证） 指定⽤户名和密码作为从服务器端获取资源时必要的登录信息（身份 认证）。</font><mark>此项为可选项</mark></strong></li><li><strong><font color=red>服务器地址 ，必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是192.168.1.1 这类 IPv4 地址 名，还可以是 [0:0:0:0:0:0:0:1] 这样⽤⽅括号括起来的 IPv6 地址名</font></strong></li><li><strong><font color=red>服务器端⼝号 指定服务器连接的⽹络端⼝号。</font><mark>此项也是可选项，若⽤户省略则⾃动 使⽤默认端⼝号</mark></strong></li><li><strong><font color=red>带层次的⽂件路径 指定服务器上的⽂件路径来定位特指的资源</font></strong></li><li><strong><font color=red>查询字符串针对已指定的⽂件路径内的资源，可以使⽤查询字符串传⼊任意参数。</font><mark>此项为可选项</mark></strong></li><li><strong><font color=red>⽚段标识符 使⽤⽚段标识符通常可标记出已获取资源中的⼦资源（⽂档内的某个位置）。</font><mark>该项为可选项</mark></strong></li></ul></blockquote><hr><h2 id="HTTP协议的数据流"><a href="#HTTP协议的数据流" class="headerlink" title="HTTP协议的数据流"></a>HTTP协议的数据流</h2><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217215317772.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217215317772.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217215317772"><hr><h2 id="HTTP协议的格式"><a href="#HTTP协议的格式" class="headerlink" title="HTTP协议的格式"></a>HTTP协议的格式</h2><h3 id="HTTP请求格式"><a href="#HTTP请求格式" class="headerlink" title="HTTP请求格式"></a>HTTP请求格式</h3><p><strong><mark>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建⽴通信的，服务器端在没有接收到请求之前不会发送响应</mark></strong></p><p><strong><font color=red>请求格式如下：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217220740722.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217220740722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217220740722"><blockquote><p><strong><font color=red>我们来验证一下这个请求格式：</font></strong></p><ul><li><strong><mark>假如我们在百度搜索C++，然后按F12打开开发者工具，此时我们会看到如下界面</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217221019569.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217221019569.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217221019569"><ul><li><strong><mark>此时打开的开发者工具框什么都没有，是因为内容已经加载过了，才打开的开发者工具，只需要刷新页面即可看到如下图所示界面：</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217221219083.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217221219083.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217221219083"><ul><li><strong><mark>打开NetWork,在然后随便点开一个请求资源名称，如下图所示：</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217221612123.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217221612123.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217221612123"><p><strong><font color=red>HTTP请求格式总结，如下图：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217222132109.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217222132109.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217222132109"><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217223417764.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217223417764.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217223417764"><p><strong><font color=red>HTTP请求格式总结：</font></strong></p><blockquote><ul><li><strong><mark>请求行：[请求方法]+[url]+[http版本]</mark></strong></li><li><strong><mark>请求报头：请求的属性，这些属性都是以key: value的形式按行陈列的</mark></strong></li><li><strong><mark>空行：遇到空行表示请求报头结束</mark></strong></li><li><strong><mark>请求正文：请求正文允许为空字符串，如果请求正文存在，则在请求报头中会有一个Content-Length属性来标识请求正文的长度</mark></strong></li></ul></blockquote></blockquote><hr><h3 id="HTTP响应格式"><a href="#HTTP响应格式" class="headerlink" title="HTTP响应格式"></a>HTTP响应格式</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217222354516.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217222354516.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217222354516"><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217223438040.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217223438040.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217223438040"><p><strong><font color=red>HTTP响应格式总结：</font></strong></p><blockquote><ul><li><strong><mark>状态行：[http版本]+[状态码]+[状态码描述]</mark></strong></li><li><strong><mark>响应报头：响应的属性，这些属性都是以key: value的形式按行陈列的</mark></strong></li><li><strong><mark>空行：遇到空行表示响应报头结束</mark></strong></li><li><strong><mark>响应正文：响应正文允许为空字符串，如果响应正文存在，则响应报头中会有一个Content-Length属性来标识响应正文的长度。比如服务器返回了一个html页面，那么这个html页面的内容就是在响应正文当中的</mark></strong></li></ul></blockquote><hr><h2 id="HTTP协议格式图解"><a href="#HTTP协议格式图解" class="headerlink" title="HTTP协议格式图解"></a>HTTP协议格式图解</h2><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218105936866.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218105936866.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218105936866"><hr><h2 id="HTTP协议版本"><a href="#HTTP协议版本" class="headerlink" title="HTTP协议版本"></a>HTTP协议版本</h2><p><strong><font color=red>HTTP协议版本到目前位置一共有四个版本</font></strong></p><ol><li><p><strong><code>HTTP/0.9(不常用)</code></strong></p><blockquote><p><strong><font color=red>HTTP&#x2F;0.9 HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被称为 HTTP&#x2F;0.9</font></strong></p></blockquote></li><li><p><strong><code>HTTP/1.0(常用)</code></strong></p><blockquote><p><strong><font color=red>HTTP&#x2F;1.0 HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为 HTTP&#x2F;1.0，并记载于 RFC1945。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端</font></strong></p></blockquote></li><li><p><strong><code>HTTP/1.1(常用)</code></strong></p><blockquote><p><strong><font color=red>HTTP&#x2F;1.1 1997 年 1 月公布的 HTTP&#x2F;1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 RFC2616 就是当前的最新版本</font></strong></p></blockquote></li><li><p><strong><code>HTTP/2.0(不常用)</code></strong></p><blockquote><p><strong><font color=red>HTTP&#x2F;2.0 新一代 HTTP&#x2F;2.0 正在制订中，但要达到较高的使用覆盖率，仍需假以时日</font></strong></p></blockquote></li></ol><hr><h2 id="HTTP协议请求方法"><a href="#HTTP协议请求方法" class="headerlink" title="HTTP协议请求方法"></a>HTTP协议请求方法</h2><h3 id="GET方法：获取资源"><a href="#GET方法：获取资源" class="headerlink" title="GET方法：获取资源"></a>GET方法：获取资源</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218110939485.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218110939485.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218110939485"><ul><li><strong>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回</strong></li><li><strong><font color=red>GET既能从服务器中去获取数据，也能向服务器中提交少量数据，提交的数据在URL中</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218111219889.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218111219889.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218111219889"><hr><h3 id="POST方法：传输实体主体"><a href="#POST方法：传输实体主体" class="headerlink" title="POST方法：传输实体主体"></a>POST方法：传输实体主体</h3><ul><li><strong><mark>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法</mark>。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容</strong></li><li><strong><font color=red>POST：给服务器提交某些数据，提交的数据在正文中</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218111425624.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218111425624.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218111425624"><p><strong><font color=green>我们来举个例子：假设我们要在某个网页进行登录，使用POST请求就会将我们的账号，密码放在请求正文中进行提交</font></strong></p><blockquote><p><strong><font color=red>如下图所示我们可以看到POST请求，且在请求正文中可以看到刚才输入的账号密码和验证码：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218111707330.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218111707330.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218111707330"><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218111735389.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218111735389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218111735389"></blockquote><hr><h3 id="PUT方法：传输文件"><a href="#PUT方法：传输文件" class="headerlink" title="PUT方法：传输文件"></a>PUT方法：传输文件</h3><ul><li><strong>PUT⽅法⽤来传输⽂件。就像 FTP 协议的⽂件上传⼀样，要求在请求报⽂的主体中包含⽂件内容，然后保存到请求 URI 指定的位置</strong></li><li><strong><font color=red>但是，鉴于 HTTP&#x2F;1.1 的 PUT ⽅法⾃身不带验证机制，任何⼈都可以上传⽂件 , 存在安全性问题，因此⼀般的 Web ⽹站不使⽤该⽅法</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218112043613.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218112043613.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218112043613"><hr><h3 id="HEAD方法：获得报文首部"><a href="#HEAD方法：获得报文首部" class="headerlink" title="HEAD方法：获得报文首部"></a>HEAD方法：获得报文首部</h3><ul><li><strong><font color=red>HEAD方法和GET方法一样，只是不返回报文主体部分，用来确认资源的有效性</font></strong></li><li><strong><font color=red>HEAD方法是不需要服务端返回响应正文的，使用HEAD方法，服务器只会返回响应首行、响应报头、空行</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218112522926.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218112522926.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218112522926"><hr><h3 id="DELETE方法：删除文件"><a href="#DELETE方法：删除文件" class="headerlink" title="DELETE方法：删除文件"></a>DELETE方法：删除文件</h3><ul><li><p><strong><font color=red>DELETE ⽅法⽤来删除⽂件，是与 PUT 相反的⽅法</font></strong></p></li><li><p><strong><font color=red>但是， HTTP&#x2F;1.1 的 DELETE ⽅法本身和 PUT ⽅法⼀样不带验证机制，所以⼀般的 Web ⽹站也不使⽤ DELETE ⽅法</font></strong></p></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218112802647.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218112802647.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218112802647"><hr><h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><ul><li><p><strong><font color=red>OPTIONS方法用来查询针对请求URL指定的资源支持的方法</font></strong></p></li><li><p><strong><font color=red>即客户端询问当前服务器都支持哪些方法</font></strong></p></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218113144321.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218113144321.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218113144321"><hr><h2 id="HTTP协议请求方法总结"><a href="#HTTP协议请求方法总结" class="headerlink" title="HTTP协议请求方法总结"></a>HTTP协议请求方法总结</h2><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218113408096.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218113408096.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218113408096"><hr><h2 id="HTTP状态码理解"><a href="#HTTP状态码理解" class="headerlink" title="HTTP状态码理解"></a>HTTP状态码理解</h2><h3 id="HTTP状态码类别"><a href="#HTTP状态码类别" class="headerlink" title="HTTP状态码类别"></a>HTTP状态码类别</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218113527609.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218113527609.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218113527609"><hr><h3 id="常见成功状态码-2XX"><a href="#常见成功状态码-2XX" class="headerlink" title="常见成功状态码(2XX)"></a>常见成功状态码(2XX)</h3><blockquote><p><strong><font color=red>2XX 的响应结果表明请求被正常处理了</font></strong></p></blockquote><p><strong><code>常见的三种成功状态码：200、204、206</code></strong></p><ol><li><p><strong><font color=red>200(OK)状态码</font></strong></p><blockquote><ul><li><strong><font color=green>表示从客户端发来的请求在服务器端被正常处理了</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218113929430.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218113929430.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218113929430"></blockquote></li><li><p><strong><font color=red>204(No Content)状态码</font></strong></p><blockquote><ul><li><strong><font color=green>请求处理成功了，但没有资源要返回(没有正文)</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218114106209.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218114106209.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218114106209"></blockquote></li><li><p><strong><font color=red>206(Partial Content)状态码</font></strong></p></li></ol><blockquote><ul><li><strong><font color=green>客户端进行了范围请求，服务器成功执行这一请求</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218114440585.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218114440585.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218114440585"></blockquote><hr><h3 id="常见重定向状态码-3XX"><a href="#常见重定向状态码-3XX" class="headerlink" title="常见重定向状态码(3XX)"></a>常见重定向状态码(3XX)</h3><blockquote><p><strong><font color=red>3XX响应结果表明浏览器需要进行附加操作以完成请求</font></strong></p></blockquote><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218114643522.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218114643522.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218114643522"><p><strong><code>常见的三种重定向状态码：301、302、303</code></strong></p><ol><li><p><strong><font color=red>301(Moved Permanently) 永久性重定向</font></strong></p><blockquote><ul><li><strong><font color=green>告诉服务器某一资源已被永久放在另一个URL中，以后访问需访问新的URL</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218115056842.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218115056842.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218115056842"></blockquote></li><li><p><strong><font color=red>302(Found) 临时性重定向</font></strong></p><blockquote><ul><li><strong><font color=green>客户端要请求的资源临时被放到新的服务器中，以后访问此资源还是访问这个旧服务器</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218115159479.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218115159479.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218115159479"></blockquote></li><li><p><strong><font color=red>303(See Other)</font></strong></p><blockquote><ul><li><strong><font color=green>要访问的资源已经更新了</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218115304903.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218115304903.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218115304903"></blockquote></li></ol><hr><h3 id="常见客户端错误状态码-4XX"><a href="#常见客户端错误状态码-4XX" class="headerlink" title="常见客户端错误状态码(4XX)"></a>常见客户端错误状态码(4XX)</h3><blockquote><p><strong><font color=red>4XX的响应结果表明客户端发生错误</font></strong></p></blockquote><p><strong><code>常见四种客户端错误状态码：400、401、403、404</code></strong></p><ol><li><p><strong><font color=red>400(Bad Request)</font></strong></p><blockquote><ul><li><strong><font color=green>服务端无法理解客户端发送的请求:请求格式错误</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218115947848.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218115947848.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218115947848"></blockquote></li><li><p><strong><font color=red>401(Unauthorized)</font></strong></p><blockquote><ul><li><strong><font color=green>认证失败</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218120114275.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218120114275.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218120114275"></blockquote></li><li><p><strong><font color=red>403(Forbidden)</font></strong></p><blockquote><ul><li><strong><font color=green>客户端请求访问某一资源被服务器拒绝了，即没有资格(权限)访问某一资源</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218120218034.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218120218034.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218120218034"></blockquote></li><li><p><strong><font color=red>404(Not Found)</font></strong></p><blockquote><ul><li><strong><font color=green>服务器无法找到客户端请求的资源</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218120311470.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218120311470.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218120311470"></blockquote></li></ol><hr><h3 id="常见的服务器错误状态码-5XX"><a href="#常见的服务器错误状态码-5XX" class="headerlink" title="常见的服务器错误状态码(5XX)"></a>常见的服务器错误状态码(5XX)</h3><blockquote><p><strong><font color=red>5XX的响应结果表明服务器处理请求出错</font></strong></p></blockquote><p><strong><code>常见的两种服务器错误状态码：500、503</code></strong></p><ol><li><p><strong><font color=red>500(Internal Server Error)</font></strong></p><blockquote><ul><li><strong><font color=red>该状态码表明服务器端在执行请求时发生错误，也有可能是Web应用存在的bug或某些临时的故障</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218120918877.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218120918877.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218120918877"></blockquote></li><li><p><strong><font color=red>503(Service Unavailable)</font></strong></p><blockquote><ul><li><strong><font color=red>服务器繁忙</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218121011377.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218121011377.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218121011377"></blockquote></li></ol><hr><h2 id="HTTP常见Header"><a href="#HTTP常见Header" class="headerlink" title="HTTP常见Header"></a>HTTP常见Header</h2><p><strong><font color=red>HTTP常见的Header如下：</font></strong></p><blockquote><ul><li><strong><code>Content-Type：数据类型（text/html等）</code></strong></li><li><strong><code>Content-Length：正文的长度</code></strong></li><li><strong><code>Host：客户端告知服务器，所请求的资源是在哪个主机的哪个端口上</code></strong></li><li><strong><code>User-Agent：声明用户的操作系统和浏览器的版本信息</code></strong></li><li><strong><code>Referer：当前页面是哪个页面跳转过来的</code></strong></li><li><strong><code>Location：搭配3XX状态码使用，告诉客户端接下来要去哪里访问</code></strong></li><li><strong><code>Cookie：用于在客户端存储少量信息，通常用于实现会话（session）的功能</code></strong></li></ul></blockquote><p><strong><font color=red>其中：cookie和session都是用来跟踪浏览器用户身份的会话方式</font></strong></p><blockquote><p><strong><mark>Cookie的工作原理：</mark></strong></p><ul><li><strong><font color=blue>浏览器端第一次发送请求到服务器端</font></strong></li><li><strong><font color=blue>服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端</font></strong></li><li><strong><font color=blue>浏览器端再次访问服务器端时会携带服务器端创建的Cookie</font></strong></li><li><strong><font color=blue>服务器端通过Cookie中携带的数据区分不同的用户</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218125508336.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218125508336.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218125508336"><hr><p><strong><mark>Session的工作原理：</mark></strong></p><ul><li><strong>浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端</strong></li><li><strong>浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象</strong></li><li><strong>服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。name为JSESSIONID的Cookie不存在（关闭或更换浏览器），返回1中重新去创建Session与特殊的Cookiename为JSESSIONID的Cookie存在，根据value中的SessionId去寻找session对象value为SessionId不存在（Session对象默认存活30分钟），返回1中重新去创建Session与特殊的Cookievalue为SessionId存在，返回session对象</strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218125707578.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218125707578.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218125707578"><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218125952935.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218125952935.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218125952935"></blockquote><p><strong><font color=red>Cookie和Session的区别对比：</font></strong></p><blockquote><ul><li><strong><code>cookie数据存放在客户的浏览器上，session数据放在服务器上</code></strong></li><li><strong><code>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session</code></strong></li><li><strong><code>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE</code></strong></li><li><strong><code>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K</code></strong></li><li><strong><code>所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</code></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218130301590.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218130301590.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218130301590"></blockquote><hr><h2 id="HTTP协议与浏览器的交互"><a href="#HTTP协议与浏览器的交互" class="headerlink" title="HTTP协议与浏览器的交互"></a>HTTP协议与浏览器的交互</h2><p><strong><mark>我们用一个代码来演示：比如实现一个最简单的HTTP服务器, 只在网页上输出 “hello world”; 只要我们按照HTTP协议的要求构造数据, 就很容易能做到</mark></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/socket.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;errno.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;netinet/in.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sstream></span></span>using namespace std<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sockfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>     <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> addr<span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr<span class="token operator">=</span><span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"172.16.0.9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"bind"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"listen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> cli_addr<span class="token punctuation">;</span> <span class="token comment">//客户端的协议栈</span>    <span class="token class-name">socklen_t</span> cli_addrlen<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cli_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> newsockfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>cli_addr<span class="token punctuation">,</span><span class="token operator">&amp;</span>cli_addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>newsockfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"accept"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"accept new connect form client:"</span><span class="token operator">&lt;&lt;</span><span class="token function">inet_ntoa</span><span class="token punctuation">(</span>cli_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token function">ntohs</span><span class="token punctuation">(</span>cli_addr<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token class-name">ssize_t</span> recv_size<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>newsockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>recv_size<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>          <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"recv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>recv_size<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>              cout<span class="token operator">&lt;&lt;</span><span class="token string">"peer close connect!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>           <span class="token function">close</span><span class="token punctuation">(</span>newsockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"buf:"</span><span class="token operator">&lt;&lt;</span>buf<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          string body<span class="token operator">=</span><span class="token string">"&lt;html>&lt;h1>hello world&lt;/h1>&lt;/html>"</span><span class="token punctuation">;</span>      stringstream ss<span class="token punctuation">;</span>      ss<span class="token operator">&lt;&lt;</span><span class="token string">"HTTP/1.1 200 OK\r\n"</span><span class="token punctuation">;</span>      ss<span class="token operator">&lt;&lt;</span><span class="token string">"Content-Type: text/html\r\n"</span><span class="token punctuation">;</span>      ss<span class="token operator">&lt;&lt;</span><span class="token string">"Content-length: "</span><span class="token operator">&lt;&lt;</span>body<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"\r\n"</span><span class="token punctuation">;</span>               <span class="token comment">// ss&lt;&lt;"HTTP/1.1 302 Found\r\n";</span>      <span class="token comment">// ss&lt;&lt;"Location: https://www.baidu.com/\r\n";</span>      ss<span class="token operator">&lt;&lt;</span><span class="token string">"\r\n"</span><span class="token punctuation">;</span>          <span class="token function">send</span><span class="token punctuation">(</span>newsockfd<span class="token punctuation">,</span>ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">send</span><span class="token punctuation">(</span>newsockfd<span class="token punctuation">,</span>body<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>body<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><font color=red>编译, 启动服务. 在浏览器中输入 http:&#x2F;&#x2F;[ip]:[port], 就能看到显示的结果 “Hello World”</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218130729123.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218130729123.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218130729123"><p><strong><font color=red>此处我们使用 9090 端口号启动了HTTP服务器. 虽然HTTP服务器一般使用80端口,但这只是一个通用的习惯. 并不是说HTTP服务器就不能使用其他的端口号</font></strong></p><p><strong><mark>把返回的状态码改成303等, 看浏览器上分别会出现什么样的效果</mark></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//修改上面的代码77-79行如下：</span>ss<span class="token operator">&lt;&lt;</span><span class="token string">"HTTP/1.1 302 Found\r\n"</span><span class="token punctuation">;</span>ss<span class="token operator">&lt;&lt;</span><span class="token string">"Location: https://www.baidu.com/\r\n"</span><span class="token punctuation">;</span>ss<span class="token operator">&lt;&lt;</span><span class="token string">"\r\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218130943044.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221218130943044.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218130943044"><p><strong><font color=red>这里jiu发生了重定向的结果！</font></strong></p><hr><h2 id="补充：HTTP与HTTPS协议的区别"><a href="#补充：HTTP与HTTPS协议的区别" class="headerlink" title="补充：HTTP与HTTPS协议的区别"></a>补充：HTTP与HTTPS协议的区别</h2><blockquote><ul><li><strong><font color=red>早期很多公司刚起步的时候，使用的应用层协议都是HTTP，而HTTP无论是用GET方法还是POST方法传参，都是没有经过任何加密的，因此早期很多的信息都是可以通过抓包工具抓到的，也就体现了HTTP的不安全性</font></strong></li><li><strong><font color=red>为了解决这个问题，于是出现了HTTPS协议，HTTPS实际就是在应用层和传输层协议之间加了一层加密层（SSL与TLS），这层加密层本身也是属于应用层的，它会对用户的个人信息进行各种程度的加密。HTTPS在交付数据时先把数据交给加密层，由加密层对数据加密后再交给传输层</font></strong></li><li><strong><font color=red>当然，通信双方使用的应用层协议必须是一样的，因此对端的应用层也必须使用HTTPS，当对端的传输层收到数据后，会先将数据交给加密层，由加密层对数据进行解密后再将数据交给应用层</font></strong></li></ul></blockquote><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217203925098.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-http-xie-yi-ying-yong-ceng/image-20221217203925098.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221217203925098"><ul><li><strong><font color=green>此时数据只有在用户层（应用层）是没有被加密的，而在应用层往下以及网络当中都是加密的，这就叫做HTTPS</font></strong></li></ul><hr><h2 id="扩展：对称加密与非对称加密"><a href="#扩展：对称加密与非对称加密" class="headerlink" title="扩展：对称加密与非对称加密"></a>扩展：对称加密与非对称加密</h2><p><strong><mark>加密的方式可以分为对称加密和非对称加密：</mark></strong> </p><blockquote><ul><li><strong><code>对称加密</code>：采用单钥密码系统的加密方法，<mark>同一个密钥可以同时用作信息的加密和解密</mark></strong></li><li><strong><code>非对称加密</code>：采用<mark>公钥和私钥来进行加密和解密</mark>，用其中一个密钥进行加密就必须用另一个密钥进行解密</strong></li><li><strong><mark>一般而言，对称加密的效率比非对称加密的效率高，少用一个密钥嘛</mark></strong></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux网络协议之HTTP协议-应用层&quot;&gt;&lt;a href=&quot;#Linux网络协议之HTTP协议-应用层&quot; class=&quot;headerlink&quot; title=&quot;Linux网络协议之HTTP协议(应用层)&quot;&gt;&lt;/a&gt;Linux网络协议之HTTP协议(应用层)&lt;/h1</summary>
      
    
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络协议之UDP协议(传输层)</title>
    <link href="https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/"/>
    <id>https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/</id>
    <published>2023-03-20T04:18:00.000Z</published>
    <updated>2023-06-23T18:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux网络协议之UDP协议-传输层"><a href="#Linux网络协议之UDP协议-传输层" class="headerlink" title="Linux网络协议之UDP协议(传输层)"></a>Linux网络协议之UDP协议(传输层)</h1><h2 id="深入理解传输层"><a href="#深入理解传输层" class="headerlink" title="深入理解传输层"></a>深入理解传输层</h2><h3 id="对于端口号的理解"><a href="#对于端口号的理解" class="headerlink" title="对于端口号的理解"></a>对于端口号的理解</h3><blockquote><p><strong><font color=red>传输层是负责端对端之间的传输，<code>端指的是端口(port)</code>；TCP协议和UDP协议都是传输层的协议</font></strong></p></blockquote><ul><li><strong><mark>端口（Port）标识一个主机上进行网络通信的不同的应用程序</mark>。当主机从网络中获取到数据后，需要自底向上进行数据的交付，而这个数据最终应该交给上层的哪个应用处理程序，就是由该数据当中的目的端口号来决定的</strong></li><li><strong>从网络中获取的数据在进行向上交付时，在传输层就会提取出该数据对应的目的端口号，进而确定该数据应该交付给当前主机上的哪一个服务进程</strong></li><li><strong><font color=red>端口号如何找到进程？内核实现通过哈希算法，端口号对应进程PID</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218171817013.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218171817013.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218171817013"><p><strong><font color=red>在TCP&#x2F;IP协议中, 用 <code>“源IP地址”,  “目标IP地址”, “协议号”, “源端口号”,&quot;目标端口号&quot;</code> 这样一个五元组来标识一个通信(可以通过netstat -n查看)</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218172047808.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218172047808.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218172047808"><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218172712773.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218172712773.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218172712773"><blockquote><ul><li><strong><mark>源IP地址：发送数据的主机IP</mark></strong></li><li><strong><mark>目标IP地址：最终接收数据主机IP</mark></strong></li><li><strong><mark>源端口号：发送数据主机中发送数据的进程</mark></strong></li><li><strong><mark>目标端口号：最终接收数据主机中要接收数据的进程</mark></strong></li></ul></blockquote><hr><h3 id="端口号范围"><a href="#端口号范围" class="headerlink" title="端口号范围"></a>端口号范围</h3><blockquote><ul><li><strong><font color=red>0 - 1023: 知名端口号, HTTP, FTP, SSH等这些广为使用的应用层协议, 他们的端口号都是固定的</font></strong></li><li><strong><font color=red>1024 - 65535: 操作系统动态分配的端口号。客户端程序的端口号, 就是由操作系统从这个范围分配的</font></strong></li></ul></blockquote><hr><h3 id="常用的知名端口号"><a href="#常用的知名端口号" class="headerlink" title="常用的知名端口号"></a>常用的知名端口号</h3><blockquote><p><strong><font color=red>有些服务器是非常常用的, 为了使用方便, 人们约定一些常用的服务器, 都是用以下这些固定的端口号</font></strong></p></blockquote><ul><li><strong><code>SSH服务器：使用22端口号</code></strong></li><li><strong><code>FTP服务器：使用21端口号</code></strong></li><li><strong><code>Telnet服务器：使用23端口号</code></strong></li><li><strong><code>HTTP服务器：使用80端口号</code></strong></li><li><strong><code>HTTPS服务器：使用443端口号</code></strong></li></ul><p><strong><font color=red>使用命令 cat &#x2F;etc&#x2F;services 可以查看指明端口号</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218173325754.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218173325754.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218173325754"><p><strong>说明一下：</strong> 文件中的每一行对应一种服务，它由4个字段组成，每个字段之间用TAB或空格分隔，分别表示“服务名称”、“使用端口”、“协议名称”以及“别名”</p><p><strong><font color=green>一点提醒：一个进程可以绑定多个端口号，一个端口号只能绑定一个进程</font></strong></p><hr><h3 id="进程和端口号的两个问题"><a href="#进程和端口号的两个问题" class="headerlink" title="进程和端口号的两个问题"></a>进程和端口号的两个问题</h3><p><strong><font color=red>第一个问题：一个端口号是否可以被多个进程绑定？</font></strong></p><blockquote><ul><li><strong><font color=green>一个端口号绝对不能被多个进程绑定，因为端口号的作用就是唯一标识一个进程，如果绑定一个已经被绑定的端口号，就会出现绑定失败的问题</font></strong></li></ul></blockquote><p><strong><font color=red>第二个问题：一个进程是否可以绑定多个端口号？</font></strong></p><blockquote><ul><li><strong><font color=green>一个进程是可以绑定多个端口号的，这与“端口号必须唯一标识一个进程”是不冲突的，只不过现在这多个端口唯一标识的是同一个进程罢了</font></strong></li><li><strong><font color=green>我们限制的是从端口号到进程的唯一性，而没有要求从进程到端口号也必须满足唯一性，因此一个进程是可以绑定多个端口号的</font></strong></li></ul></blockquote><p><strong><code>总结：一个进程可以绑定多个端口号，一个端口号只能绑定一个进程</code></strong></p><hr><h3 id="查看网络状态命令-netstat"><a href="#查看网络状态命令-netstat" class="headerlink" title="查看网络状态命令(netstat)"></a>查看网络状态命令(netstat)</h3><p><strong><font color=red><code>netstat</code>是一个用来查看网络状态的重要工具</font></strong></p><p><strong><font color=red>其常见的选项如下：</font></strong></p><blockquote><ul><li><strong><mark>n 拒绝显示别名，能显示数字的全部转化成数字</mark></strong></li><li><strong><mark>l 仅列出有在 Listen (监听) 的服務状态</mark></strong></li><li><strong><mark>p 显示建立相关链接的程序名</mark></strong></li><li><strong><mark>a (all)显示所有选项，默认不显示LISTEN相关</mark></strong></li><li><strong><mark>u (udp)仅显示udp相关选项</mark></strong></li><li><strong><mark>t (tcp)仅显示tcp相关选项</mark></strong></li></ul></blockquote><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218174737431.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218174737431.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218174737431"><p><strong><font color=red>一些其他命令补充：</font></strong></p><blockquote><p><strong><code>iostat</code>命令：主要用于输出磁盘IO和CPU的统计信息</strong></p><p><strong><mark>其常见的选项如下：</mark></strong></p><ul><li><strong>c：显示CPU的使用情况</strong></li><li><strong>d：显示磁盘的使用情况</strong></li><li><strong>N：显示磁盘列阵（LVM）信息</strong></li><li><strong>n：显示NFS使用情况</strong></li><li><strong>k：以KB为单位显示</strong></li><li><strong>m：以M为单位显示</strong></li><li><strong>t：报告每秒向终端读取和写入的字符数和CPU的信息</strong></li><li><strong>V：显示版本信息</strong></li><li><strong>x：显示详细信息</strong></li><li><strong>p：显示磁盘分区的情况</strong></li></ul><p><strong><font color=red>我们来试下这个命令，比如我们要查看磁盘IO和CPU的详细信息</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218175107204.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218175107204.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218175107204"><p><strong><font color=red>CPU属性值说明：</font></strong></p><ul><li><strong>%user：CPU处在用户模式下的时间百分比</strong></li><li><strong>%nice：CPU处在带NICE值的用户模式下的时间百分比</strong></li><li><strong>%system：CPU处在系统模式下的时间百分比</strong></li><li><strong>%iowait：CPU等待输入输出完成时间的百分比</strong></li><li><strong>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比</strong></li><li><strong>%idle：CPU空闲时间百分比</strong></li></ul><hr><p><strong><code>pidof</code>命令：可以通过进程名，查看进程id</strong></p><p><strong>例如，我们用<code>pidof</code>命令查看我们自己编写的一个死循环进程：</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218175352824.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218175352824.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218175352824"><p><strong><code>pidof</code>命令可以配合<code>kill</code>命令快速杀死一个进程</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218175427205.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218175427205.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218175427205"><hr><p><strong><code>ipconfig</code>命令：用于显示或者设置网络设备</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218175753397.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218175753397.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218175753397"><p><strong><font color=red>一点解释：</font></strong></p><ul><li><strong>inet：IP地址</strong></li><li><strong>netmask：子网掩码</strong></li><li><strong>vroadcast：广播</strong></li><li><strong>ether：以太网</strong></li></ul></blockquote><hr><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP协议格式"><a href="#UDP协议格式" class="headerlink" title="UDP协议格式"></a>UDP协议格式</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218180016988.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218180016988.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218180016988"><p><strong><mark>内核中的UDP报头结构定义：</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218180801289.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218180801289.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218180801289"><blockquote><ul><li><strong><font color=red>16位源端口：数据从哪一个端口发出来的，也就是数据从哪一个进程发送出来的</font></strong></li><li><strong><font color=red>16位目的端口：数据想要到哪一个端口去，也就是数据想要去往哪一个进程</font></strong></li><li><strong><font color=red>16位UDP长度：表示整个数据报(UDP头部+UDP数据)的最大长度</font></strong></li><li><strong><font color=red>16位的UDP校验和：校验数据在传输过程中是否失真，数据在传输的过程中需要经过很多链路设备，如果在转发过程中有某个字节损坏，就相当于整个这个数据失真了，如果UDP接收方校验和出错，就会直接将数据丢弃掉，且不会通知发送方</font></strong></li><li><strong><font color=red>如果校验和出错, 就会直接丢弃</font></strong></li></ul><p><strong><mark>16位能够表示的数据最大位长度位2^16&#x3D;65536—&gt;指的是UDP数据的最大长度</mark></strong></p></blockquote><p> <strong><code>网络每一层主要都要解决两个问题：</code></strong></p><blockquote><p><strong><font color=red>第一个问题：如何做到数据和报头的有效分离？</font></strong></p><ul><li><strong><mark>UDP报头是定长的8字节，可以将报头分离。报头的16位UDP长度减去8字节，就是数据长度</mark></strong></li></ul><p><strong><font color=red>第二个问题：如何做到向上交付给什么谁？</font></strong></p><ul><li><strong><mark>传输层向上交付，交付给应用层，实际是交付给应用层的某个进程，目的端口号确认交付给哪个进程</mark></strong></li></ul></blockquote><hr><h3 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h3><blockquote><p><strong><font color=red>UDP传输的过程类似于寄信，其特点如下：</font></strong></p></blockquote><ul><li><strong><code>无连接</code>: <mark>知道对端的IP和端口号就直接进行传输, 不需要建立连接</mark></strong></li><li><strong><code>不可靠</code>: <mark>没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息</mark></strong></li><li><strong><code>面向数据报</code>: <mark>不能够灵活的控制读写数据的次数和数量</mark></strong></li></ul><p><strong><font color=green>注意：报文在网络中进行路由转发时，并不是每一个报文选择的路由路径都是一样的，因此报文发送的顺序和接收的顺序可能是不同的</font></strong></p><hr><h3 id="面向数据报"><a href="#面向数据报" class="headerlink" title="面向数据报"></a>面向数据报</h3><p><strong><font color=red>应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并</font></strong></p><ul><li><strong><code>用UDP传输100个字节的数据：</code><font color=green>如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个字节; 而不能循环调用10次recvfrom, 每次接收10个字节</font></strong></li></ul><hr><h3 id="UDP的缓冲区"><a href="#UDP的缓冲区" class="headerlink" title="UDP的缓冲区"></a>UDP的缓冲区</h3><p><strong><font color=red>UDP的socket既能读, 也能写, 这个概念叫做全双工</font></strong></p><blockquote><p><strong><code>UDP缓冲区：</code></strong></p><ul><li><strong><mark>发送缓冲区：将应用层提交给传输层的应用数据打上UDP报头之后就提交给网络层继续传输</mark></strong></li><li><strong><mark>接收缓冲区：去掉UDP报头之后，将数据递交给应用层，UDP并不保证数据的可靠，以及有序</mark></strong></li></ul></blockquote><p><strong><font color=red>对于UDP的理解：</font></strong></p><blockquote><ul><li><strong><mark>UDP没有真正意义上的 发送缓冲区。调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后续的传输动作</mark></strong></li><li><strong><mark>发送缓冲区：将应用层数据打上UDP报头后直接递交给网络层</mark></strong></li><li><strong><mark>UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致; 如果缓冲区满了, 再到达的UDP数据就会被丢弃</mark></strong></li><li><strong><mark>接收缓冲区：去掉UDP报头后将数据递交给应用层</mark></strong></li><li><strong><mark>UDP协议并不保证数据的有序到达</mark></strong></li></ul></blockquote><hr><h3 id="基于UDP协议的应用层协议"><a href="#基于UDP协议的应用层协议" class="headerlink" title="基于UDP协议的应用层协议"></a>基于UDP协议的应用层协议</h3><blockquote><ul><li><strong><font color=red>NSF：网络文件系统</font></strong></li><li><strong><font color=red>TFTP：简单文件传输协议</font></strong></li><li><strong><font color=red>DHCP：动态主机配置协议</font></strong></li><li><strong><font color=red>BOOTP：启动协议(用于无盘设备启动)</font></strong></li><li><strong><font color=red>DNS：域名解析协议</font></strong></li><li><strong>也包括自己写UDP程序时自定义的应用层协议</strong></li></ul></blockquote><hr><h3 id="UDP使用注意事项"><a href="#UDP使用注意事项" class="headerlink" title="UDP使用注意事项"></a>UDP使用注意事项</h3><blockquote><ul><li><p><strong><font color=red>UDP包头中UDP最大长度只有16位，说明UDP能够传输的数据最大的长度是64k(包括报头)</font></strong></p></li><li><p><strong><font color=red>如果我们需要传输的数据超过64k，就需要在应用层手动进行分包，多次发送，并且在接收端手动拼装</font></strong></p></li></ul></blockquote><hr><h3 id="UDP在内核中的实现"><a href="#UDP在内核中的实现" class="headerlink" title="UDP在内核中的实现"></a>UDP在内核中的实现</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218185012463.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218185012463.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218185012463"><blockquote><p><strong><font color=red>如何进行数据拼接？只需要用udphdr定义变量，在和数据进行拼接即可。(比如memcopy)</font></strong></p></blockquote><hr><h3 id="16位的UDP校验原理"><a href="#16位的UDP校验原理" class="headerlink" title="16位的UDP校验原理"></a>16位的UDP校验原理</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218185251604.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218185251604.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218185251604"><blockquote><p><strong><font color=red>结论：发送方进行填充，接收方进行校验</font></strong></p><p><strong><font color=red>对接收方：进行校验</font></strong></p><ul><li><strong><code>如果校验成功(对所有16个比特位相加和全为1)，会将数据交给应用层</code></strong></li><li><strong><code>如果校验失败，即使数据已经到达了接收方传输层的UDP协议，也会被丢弃，有可能在传输的过程中失真</code></strong></li></ul><p><strong><font color=red>对发送方：发送填充</font></strong></p><ul><li><strong><mark>将除了校验的16位比特位，其余的按照16个比特位相加，在相加的过程中如果出现比特位超过16位的情况需要进行回卷</mark></strong></li><li><strong><mark>回卷的策略：最高位+低16位 计算出来的新值</mark></strong></li><li><strong><mark>加完的结果进行反码运算</mark></strong></li><li><strong><mark>将反码运算的结果放到16位的校验和当中</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218185523164.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-udp-xie-yi-chuan-shu-ceng/image-20221218185523164.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218185523164"></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux网络协议之UDP协议-传输层&quot;&gt;&lt;a href=&quot;#Linux网络协议之UDP协议-传输层&quot; class=&quot;headerlink&quot; title=&quot;Linux网络协议之UDP协议(传输层)&quot;&gt;&lt;/a&gt;Linux网络协议之UDP协议(传输层)&lt;/h1&gt;&lt;h2</summary>
      
    
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络协议之TCP协议(传输层)</title>
    <link href="https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/"/>
    <id>https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/</id>
    <published>2023-03-20T04:17:00.000Z</published>
    <updated>2023-06-27T03:20:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux网络协议之TCP协议-传输层"><a href="#Linux网络协议之TCP协议-传输层" class="headerlink" title="Linux网络协议之TCP协议(传输层)"></a>Linux网络协议之TCP协议(传输层)</h1><h2 id="理解TCP协议"><a href="#理解TCP协议" class="headerlink" title="理解TCP协议"></a>理解TCP协议</h2><p><strong><font color=red>TCP全称为“传输控制协议（Transmission Control Protocol）”，TCP协议是当今互联网当中使用最为广泛的传输层协议，没有之一</font></strong></p><p><strong><font color=red>TCP协议被广泛应用，其根本原因就是提供了详尽的可靠性保证，基于TCP的上层应用非常多，比如HTTP、HTTPS、FTP、SSH等，甚至MySQL底层使用的也是TCP</font></strong></p><hr><h2 id="谈谈可靠性问题"><a href="#谈谈可靠性问题" class="headerlink" title="谈谈可靠性问题"></a>谈谈可靠性问题</h2><blockquote><p><strong><font color=red>我们需要思考一个问题：为什么网络中会存在不可靠？</font></strong></p><ul><li><strong><mark>现代的计算机大部分都是基于冯诺依曼体系结构的</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218211648810.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218211648810.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218211648810"><ul><li><strong><font color=red>虽然这里的输入设备、输出设备、内存、CPU都在一台机器上，但这几个硬件设备是彼此独立的。如果它们之间要进行数据交互，就必须要想办法进行通信，因此这几个设备实际是用“线”连接起来的，其中连接内存和外设之间的“线”叫做IO总线，而连接内存和CPU之间的“线”叫做系统总线。由于这几个硬件设备都是在一台机器上的，因此这里传输数据的“线”是很短的，传输数据时出现错误的概率也非常低</font></strong></li><li><strong><font color=blue>但如果要进行通信的各个设备相隔千里，那么连接各个设备的“线”就会变得非常长，传输数据时出现错误的概率也会大大增高，此时要保证传输到对端的数据无误，就必须引入可靠性</font></strong></li><li><strong><font color=green>总之，网络中存在不可靠的根本原因就是，长距离数据传输所用的“线”太长了，数据在长距离传输过程中就可能会出现各种各样的问题，而TCP就是在此背景下诞生的，TCP就是一种保证可靠性的协议</font></strong></li></ul></blockquote><p><strong><mark>我们之前提到过UDP是一种不可靠的传输协议，那么让我们来思考下为什么还会存在UDP这种传输协议呢？</mark></strong></p><blockquote><ul><li><strong><font color=red>TCP协议是可靠的协议，也就意味着TCP协议需要做更多的工作来保证传输数据的可靠，并且引起不可靠的因素越多，保证可靠的成本（时间+空间）就越高</font></strong></li><li><strong><font color=red>比如数据在传输过程中出现了丢包、乱序、检验和失败等，这些都是不可靠的情况</font></strong></li><li><strong><font color=red>由于TCP要想办法解决数据传输不可靠的问题，因此TCP使用起来一定比UDP复杂，并且维护成本特别高</font></strong></li><li><strong><font color=red>UDP协议是不可靠的协议，也就意味着UDP协议不需要考虑数据传输时可能出现的问题，因此UDP无论是使用还是维护都足够简单</font></strong></li><li><strong><font color=red>需要注意的是，虽然TCP复杂，但TCP的效率不一定比UDP低，TCP当中不仅有保证可靠性的机制，还有保证传输效率的各种机制</font></strong></li></ul></blockquote><p><strong><mark>UDP和TCP没有谁最好，只有谁最合适，网络通信时具体采用TCP还是UDP完全取决于上层的应用场景。如果应用场景严格要求数据在传输过程中的可靠性，那么就必须采用TCP协议，如果应用场景允许数据传输出现少量丢包，那么肯定优先选择UDP协议，因为UDP协议足够简单</mark></strong></p><hr><h2 id="TCP协议格式"><a href="#TCP协议格式" class="headerlink" title="TCP协议格式"></a>TCP协议格式</h2><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218212940999.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218212940999.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218212940999"><p><strong><font color=red>TCP报头当中各个字段的含义如下：</font></strong></p><blockquote><ul><li><strong><mark>源&#x2F;目的端口号：表示数据是从哪个进程来，到发送到对端主机上的哪个进程</mark></strong></li><li><strong><mark>32位序号&#x2F;32位确认序号：分别代表TCP报文当中每个字节数据的编号以及对对方的确认，是TCP保证可靠性的重要字段</mark></strong></li><li><strong><mark>4位TCP报头长度：表示该TCP报头的长度，以4字节为单位</mark></strong></li><li><strong><mark>6位保留字段：TCP报头中暂时未使用的6个比特位</mark></strong></li><li><strong><mark>16位窗口大小：保证TCP可靠性机制和效率提升机制的重要字段</mark></strong></li><li><strong><mark>16位检验和：由发送端填充，采用CRC校验。接收端校验不通过，则认为接收到的数据有问题。（检验和包含TCP首部+TCP数据部分）</mark></strong></li><li><strong><mark>16位紧急指针：标识紧急数据在报文中的偏移量，需要配合标志字段当中的URG字段统一使用</mark></strong></li><li><strong><mark>选项字段：TCP报头当中允许携带额外的选项字段，最多40字节</mark></strong></li></ul></blockquote><p><strong><font color=red>TCP报头当中的6位标志位：</font></strong></p><blockquote><ul><li><strong><mark>URG：紧急指针是否有效</mark></strong></li><li><strong><mark>ACK：确认序号是否有效</mark></strong></li><li><strong><mark>PSH：提示接收端应用程序立刻将TCP接收缓冲区当中的数据读走</mark></strong></li><li><strong><mark>RST：表示要求对方重新建立连接。我们把携带RST标识的报文称为复位报文段</mark></strong></li><li><strong><mark>SYN：表示请求与对方建立连接。我们把携带SYN标识的报文称为同步报文段</mark></strong></li><li><strong><mark>FIN：通知对方，本端要关闭了。我们把携带FIN标识的报文称为结束报文段</mark></strong></li></ul></blockquote><p><strong><font color=red>TCP报头在内核当中本质就是一个位段类型，给数据封装TCP报头时，实际上就是用该位段类型定义一个变量，然后填充TCP报头当中的各个属性字段，最后将这个TCP报头拷贝到数据的首部，至此便完成了TCP报头的封装</font></strong></p><hr><h2 id="关于TCP的两个问题"><a href="#关于TCP的两个问题" class="headerlink" title="关于TCP的两个问题"></a>关于TCP的两个问题</h2><p><strong><font color=red>第一个问题：TCP如何将报头与有效载荷进行分离？</font></strong></p><blockquote><ul><li><strong>当TCP从底层获取到一个报文后，虽然TCP不知道报头的具体长度，但报文的前20个字节是TCP的基本报头，并且这20字节当中涵盖了4位的首部长度</strong></li></ul><p><strong><mark>因此TCP是这样分离报头与有效载荷的：</mark></strong></p><ul><li><strong>当TCP获取到一个报文后，首先读取报文的前20个字节，并从中提取出4位的首部长度，此时便获得了TCP报头的大小size</strong></li><li><strong>如果size的值大于20字节，则需要继续从报文当中读取size-20字节的数据，这部分数据就是TCP报头当中的选项字段</strong></li><li><strong>读取完TCP的基本报头和选项字段后，剩下的就是有效载荷了</strong></li></ul><p><strong><mark>需要注意的是，TCP报头当中的4位首部长度描述的基本单位是4字节，这也恰好是报文的宽度。4位首部长度的取值范围是0000 ~ 1111，因此TCP报头最大长度为15 × 4 &#x3D; 60字节，因为基本报头的长度是20字节，所以报头中选项字段的长度最多是40字节</mark></strong></p><p><strong><mark>如果TCP报头当中不携带选项字段，那么TCP报头的长度就是20字节，此时报头当中的4位首部长度的值就为20 ÷ 4 &#x3D; 5，也就是0101</mark></strong></p></blockquote><p><strong><font color=red>第二个问题：TCP如何决定将有效载荷交付给上层的哪一个协议？</font></strong></p><blockquote><p><strong><font color=red>应用层的每一个网络进程都必须绑定一个端口号</font></strong></p><ul><li><strong>服务端进程必须显示绑定一个端口号</strong></li><li><strong>客户端进程由系统动态绑定一个端口号</strong></li></ul><p><strong><mark>而TCP的报头中涵盖了目的端口号，因此TCP可以提取出报头中的目的端口号，找到对应的应用层进程，进而将有效载荷交给对应的应用层进程进行处理</mark></strong></p><p><strong><font color=red>说明一下： 内核中用哈希的方式维护了端口号与进程ID之间的映射关系，因此传输层可以通过端口号快速找到其对应的进程ID，进而找到对应的应用层进程</font></strong></p></blockquote><hr><h2 id="TCP序号与确认序号"><a href="#TCP序号与确认序号" class="headerlink" title="TCP序号与确认序号"></a>TCP序号与确认序号</h2><blockquote><p><strong><font color=red>我们来思考一个问题：什么是真正的可靠？</font></strong></p></blockquote><p><strong><font color=red>在进行网络通信时，一方发出的数据后，它不能保证该数据能够成功被对端收到，因为数据在传输过程中可能会出现各种各样的错误，只有当收到对端主机发来的响应消息后，该主机才能保证上一次发送的数据被对端可靠的收到了，这就叫做真正的可靠</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218220641322.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218220641322.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218220641322"><p><strong><mark>注：实线表示该数据能够被对方可靠的收到，虚线则不能保证</mark></strong></p><p><strong><font color=red>但TCP要保证的是双方通信的可靠性，虽然此时主机A能够保证自己上一次发送的数据被主机B可靠的收到了，但主机B也需要保证自己发送给主机A的响应数据被主机A可靠的收到了。因此主机A在收到了主机B的响应消息后，还需要对该响应数据进行响应，但此时又需要保证主机A发送的响应数据的可靠性…，这样就陷入了一个死循环</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218220757447.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218220757447.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218220757447"><p><strong><mark>因为只有当一端收到对方的响应消息后，才能保证自己上一次发送的数据被对端可靠的收到了，但双方通信时总会有最新的一条消息，因此无法百分之百保证可靠性</mark></strong></p><p><strong><font color=red>所以严格意义上来说，互联网通信当中是不存在百分之百的可靠性的，因为双方通信时总有最新的一条消息得不到响应。但实际没有必要保证所有消息的可靠性，我们只要保证双方通信时发送的每一个核心数据都有对应的响应就可以了。而对于一些无关紧要的数据（比如响应数据），我们没有必要保证它的可靠性。因为对端如果没有收到这个响应数据，会判定上一次发送的报文丢失了，此时对端可以将上一次发送的数据进行重传</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218220925360.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218220925360.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218220925360"><p><strong><font color=red>这种策略在TCP当中就叫做确认应答机制。需要注意的是，确认应答机制不是保证双方通信的全部消息的可靠性，而是只要一方收到了另一方的应答消息，就说明它上一次发送的数据被另一方可靠的收到了</font></strong></p><p><strong><font color=red>下面我们来理解下序号与确认序号：</font></strong></p><blockquote><p><strong><mark>首先我们来理解下，32位序号：</mark></strong></p><ul><li><strong>如果双方在进行数据通信时，只有收到了上一次发送数据的响应才能发下一个数据，那么此时双方的通信过程就是串行的，效率可想而知</strong></li><li><strong>因此双方在进行网络通信时，允许一方 向另一方连续发送多个报文数据，只要保证发送的每个报文都有对应的响应消息就行了，此时也就能保证这些报文被对方收到了</strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218221555663.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218221555663.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218221555663"><ul><li><strong>但在连续发送多个报文时，由于各个报文在进行网络传输时选择的路径可能是不一样的，因此这些报文到达对端主机的先后顺序也就可能和发送报文的顺序是不同的。但报文有序也是可靠性的一种，<mark>因此TCP报头中的32位序号的作用之一实际就是用来保证报文的有序性的</mark></strong></li></ul><p><strong><font color=red>TCP将发送出去的每个字节数据都进行了编号，这个编号叫做序列号</font></strong></p><ul><li><strong><font color=red>比如现在发送端要发送3000字节的数据，如果发送端每次发送1000字节，那么就需要用三个TCP报文来发送这3000字节的数据</font></strong></li><li><strong><font color=red>此时这三个TCP报文当中的32位序号填的就是发送数据中首个字节的序列号，因此分别填的是1、1001和2001</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218221916456.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218221916456.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218221916456"><p><strong><font color=red>此时接收端收到了这三个TCP报文后，就可以根据TCP报头当中的32位序列号对这三个报文进行顺序重排（该动作在传输层进行），重排后将其放到TCP的接收缓冲区当中，此时接收端这里报文的顺序就和发送端发送报文的顺序是一样的了</font></strong></p><ul><li><strong>接收端在进行报文重排时，可以根据当前报文的32位序号与其有效载荷的字节数，进而确定下一个报文对应的序号</strong></li></ul><hr><p><strong><mark>让我们再来看一下，32位确认序号：</mark></strong></p><p><strong>TCP报头当中的32位确认序号是告诉对端，我当前已经收到了哪些数据，你的数据下一次应该从哪里开始发</strong></p><p><strong>以刚才的例子为例，当主机B收到主机A发送过来的32位序号为1的报文时，由于该报文当中包含1000字节的数据，因此主机B已经收到序列号为1-1000的字节数据，于是主机B发给主机A的响应数据的报头当中的32位确认序号的值就会填成1001</strong></p><ul><li><strong>一方面是告诉主机A，序列号在1001之前的字节数据我已经收到了</strong></li><li><strong>另一方面是告诉主机A，下次向我发送数据时应该从序列号为1001的字节数据开始进行发送</strong></li></ul><p><strong>之后主机B对主机A发来的其他报文进行响应时，发给主机A的响应当中的32为确认序号的填法也是类似的道理</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218222140898.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218222140898.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218222140898"><p><strong>注意：响应数据与其他数据一样，也是一个完整的TCP报文，尽管该报文可能不携带有效载荷，但至少是一个TCP报头</strong></p><hr><p><strong><mark>一点小思考：报文丢失怎么办？</mark></strong></p><p><strong>还是以刚才的例子为例，主机A发送了三个报文给主机B，其中每个报文的有效载荷都是1000字节，这三个报文的32位序号分别是1、1001、2001</strong></p><p><strong>如果这三个报文在网络传输过程中出现了丢包，最终只有序号为1和2001的报文被主机B收到了，那么当主机B在对报文进行顺序重排的时候，就会发现只收到了1-1000和2001-3000的字节数据。此时主机B在对主机A进行响应时，其响应报头当中的32位确认序号填的就是1001，告诉主机A下次向我发送数据时应该从序列号为1001的字节数据开始进行发送</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218222235779.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218222235779.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218222235779"><p><strong>注意：</strong></p><ul><li><strong>此时主机B在给主机A响应时，其32位确认序号不能填3001，因为1001-2000是在3001之前的，如果直接给主机A响应3001，就说明序列号在3001之前的字节数据全都收到了</strong></li><li><strong>因此主机B只能给主机A响应1001，当主机A收到该确认序号后就会判定序号为1001的报文丢包了，此时主机A就可以选择进行数据重传</strong></li></ul><p><strong>因此发送端可以根据对端发来的确认序号，来判断是否某个报文可能在传输过程中丢失了</strong></p><hr><p><strong><mark>一点小思考：为什么要用两套序号机制？</mark></strong></p><p><strong>如果通信双方只是一端发送数据，另一端接收数据，那么只用一套序号就可以了</strong></p><ul><li><strong>发送端在发送数据时，将该序号看作是32位序号</strong></li><li><strong>接收端在对发送端发来的数据进行响应时，将该序号看作是32位确认序号</strong></li></ul><p><strong>但实际TCP却没有这么做，根本原因就是因为TCP是全双工的，双方可能同时想给对方发送消息</strong></p><ul><li><strong>双方发出的报文当中，不仅需要填充32位序号来表明自己当前发送数据的序号</strong></li><li><strong>还需要填充32位确认序号，对对方上一次发送的数据进行确认，告诉对方下一次应该从哪一字节序号开始进行发送</strong></li></ul><p><strong>因此在进行TCP通信时，双方都需要有确认应答机制，此时一套序号就无法满足需求了，因此需要TCP报头当中出现了两套序号</strong></p></blockquote><p><strong><font color=red>最后我们总结一下：</font></strong></p><blockquote><ul><li><strong><mark>32位序号的作用是，保证数据的按序到达，同时这个序号也是作为对端发送报文时填充32位确认序号的根据</mark></strong></li><li><strong><mark>32位确认序号的作用是，告诉对端当前已经收到的字节数据有哪些，对端下一次发送数据时应该从哪一字节序号开始进行发送</mark></strong></li><li><strong><mark>序号和确认序号是确认应答机制的数据化表示，确认应答机制就是由序号和确认序号来保证的</mark></strong></li><li><strong><mark>此外，通过序号和确认序号还可以判断某个报文是否丢失</mark></strong></li></ul></blockquote><hr><h2 id="TCP缓冲区"><a href="#TCP缓冲区" class="headerlink" title="TCP缓冲区"></a>TCP缓冲区</h2><blockquote><p><strong><font color=red>TCP的缓冲区分为：接收缓冲区和发送缓冲区</font></strong></p></blockquote><p><strong><mark>TCP本身是具有接收缓冲区和发送缓冲区的：</mark></strong></p><blockquote><ul><li><strong><code>接收缓冲区用来暂时保存接收到的数据</code></strong></li><li><strong><code>发送缓冲区用来暂时保存还未发送的数据</code></strong></li><li><strong><code>这两个缓冲区都是在TCP传输层内部实现的</code></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218224636634.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218224636634.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218224636634"></blockquote><blockquote><ul><li><strong><mark>TCP发送缓冲区当中的数据由上层应用应用层进行写入。当上层调用write&#x2F;send这样的系统调用接口时，实际不是将数据直接发送到了网络当中，而是将数据从应用层拷贝到了TCP的发送缓冲区当中</mark></strong></li><li><strong><mark>TCP接收缓冲区当中的数据最终也是由应用层来读取的。当上层调用read&#x2F;recv这样的系统调用接口时，实际也不是直接从网络当中读取数据，而是将数据从TCP的接收缓冲区拷贝到了应用层而已</mark></strong></li><li><strong><mark>就好比调用read和write进行文件读写时，并不是直接从磁盘读取数据，也不是直接将数据写入到磁盘上，而对文件缓冲区进行的读写操作</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218224702644.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218224702644.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218224702644"></blockquote><blockquote><ul><li><strong><mark>当数据写入到TCP的发送缓冲区后，对应的write&#x2F;send函数就可以返回了，至于发送缓冲区当中的数据具体什么时候发，怎么发等问题实际都是由TCP决定的</mark></strong></li><li><strong><mark>我们之所以称TCP为传输层控制协议，就是因为最终数据的发送和接收方式，以及传输数据时遇到的各种问题应该如何解决，都是由TCP自己决定的，用户只需要将数据拷贝到TCP的发送缓冲区，以及从TCP的接收缓冲区当中读取数据即可</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218224941263.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218224941263.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218224941263"><ul><li><strong><mark>需要注意的是，通信双方的TCP层都是一样的，因此通信双方的TCP层都是既有发送缓冲区又有接收缓冲区</mark></strong></li></ul></blockquote><p><strong><font color=red>最后让我们来思考一个问题：TCP的发送缓冲区和接收缓冲区存在的意义</font></strong></p><blockquote><p><strong>发送缓冲区和接收缓冲区的作用：</strong></p><ul><li><strong>数据在网络中传输时可能会出现某些错误，此时就可能要求发送端进行数据重传，因此TCP必须提供一个发送缓冲区来暂时保存发送出去的数据，以免需要进行数据重传。只有当发出去的数据被对端可靠的收到后，发送缓冲区中的这部分数据才可以被覆盖掉</strong></li><li><strong>接收端处理数据的速度是有限的，为了保证没来得及处理的数据不会被迫丢弃，因此TCP必须提供一个接收缓冲区来暂时保存未被处理的数据，因为数据传输是需要耗费资源的，我们不能随意丢弃正确的报文。此外，TCP的数据重排也是在接收缓冲区当中进行的</strong></li></ul><hr><p><strong>经典的生产者消费者模型：</strong></p><ul><li><strong>对于发送缓冲区来说，上层应用不断往发送缓冲区当中放入数据，下层网络层不断从发送缓冲区当中拿出数据准备进一步封装。此时上层应用扮演的就是生产者的角色，下层网络层扮演的就是消费者的角色，而发送缓冲区对应的就是“交易场所”</strong></li><li><strong>对于接收缓冲区来说，上层应用不断从接收缓冲区当中拿出数据进行处理，下层网络层不断往接收缓冲区当中放入数据。此时上层应用扮演的就是消费者的角色，下层网络层扮演的就是生产者的角色，而接收缓冲区对应的就是“交易场所”</strong></li><li><strong>因此引入发送缓冲区和接收缓冲区相当于引入了两个生产者消费者模型，该生产者消费者模型将上层应用与底层通信细节进行了解耦，此外，生产者消费者模型的引入同时也支持了并发和忙闲不均</strong></li></ul></blockquote><hr><h2 id="TCP窗口大小"><a href="#TCP窗口大小" class="headerlink" title="TCP窗口大小"></a>TCP窗口大小</h2><blockquote><p><strong><mark>当发送端要将数据发送给对端时，本质是把自己发送缓冲区当中的数据发送到对端的接收缓冲区当中。但缓冲区是有大小的，如果接收端处理数据的速度小于发送端发送数据的速度，那么总有一个时刻接收端的接收缓冲区会被打满，这时发送端再发送数据过来就会造成数据丢包，进而引起丢包重传等一系列的连锁反应</mark></strong></p><ul><li><strong><code>因此TCP报头当中就有了16位的窗口大小，这个16位窗口大小当中填的是自身接收缓冲区中剩余空间的大小，也就是当前主机接收数据的能力</code></strong></li></ul><p><strong><font color=red>接收端在对发送端发来的数据进行响应时，就可以通过16位窗口大小告知发送端自己当前接收缓冲区剩余空间的大小，此时发送端就可以根据这个窗口大小字段来调整自己发送数据的速度</font></strong></p><ul><li><strong>窗口大小字段越大，说明接收端接收数据的能力越强，此时发送端可以提高发送数据的速度</strong></li><li><strong>窗口大小字段越小，说明接收端接收数据的能力越弱，此时发送端可以减小发送数据的速度</strong></li><li><strong>如果窗口大小的值为0，说明接收端接收缓冲区已经被打满了，此时发送端就不应该再发送数据了</strong></li></ul><p><strong>让我们来理解一些现象：</strong></p><ul><li><strong>在编写TCP套接字时，我们调用read&#x2F;recv函数从套接字当中读取数据时，可能会因为套接字当中没有数据而被阻塞住，本质是因为TCP的接收缓冲区当中没有数据了，我们实际是阻塞在接收缓冲区当中了</strong></li><li><strong>而我们调用write&#x2F;send函数往套接字中写入数据时，可能会因为套接字已经写满而被阻塞住，本质是因为TCP的发送缓冲区已经被写满了，我们实际是阻塞在发送缓冲区当中了</strong></li><li><strong>在生产者消费者模型当中，如果生产者生产数据时被阻塞，或消费者消费数据时被阻塞，那么一定是因为某些条件不就绪而被阻塞</strong></li></ul></blockquote><hr><h2 id="TCP的六个标志位"><a href="#TCP的六个标志位" class="headerlink" title="TCP的六个标志位"></a>TCP的六个标志位</h2><blockquote><p><strong><font color=red>为什么会存在标志位？</font></strong></p><ul><li><strong><code>TCP报文的种类多种多样，除了正常通信时发送的普通报文，还有建立连接时发送的请求建立连接的报文，以及断开连接时发送的断开连接的报文等等</code></strong></li><li><strong><code>收到不同种类的报文时完美需要对应执行动作，比如正常通信的报文需要放到接收缓冲区当中等待上层应用进行读取，而建立和断开连接的报文本质不是交给用户处理的，而是需要让操作系统在TCP层执行对应的握手和挥手动作</code></strong></li><li><strong><code>也就是说不同种类的报文对应的是不同的处理逻辑，所以我们要能够区分报文的种类。而TCP就是使用报头当中的六个标志字段来进行区分的，这六个标志位都只占用一个比特位，为0表示假，为1表示真</code></strong></li></ul></blockquote><p><strong><mark>TCP中的六个标志位分别是：SYN、ACK、FIN、URG、PSH、RST</mark></strong></p><blockquote><p><strong><code>对于SYN：</code></strong></p><ul><li><strong>报文当中的SYN被设置为1，表明该报文是一个连接建立的请求报文</strong></li><li><strong>只有在连接建立阶段，SYN才被设置，正常通信时SYN不会被设置</strong></li></ul><hr><p><strong><code>对于ACK：</code></strong></p><ul><li><strong>报文当中的ACK被设置为1，表明该报文可以对收到的报文进行确认</strong></li><li><strong>一般除了第一个请求报文没有设置ACK以外，其余报文基本都会设置ACK，因为发送出去的数据本身就对对方发送过来的数据具有一定的确认能力，因此双方在进行数据通信时，可以顺便对对方上一次发送的数据进行响应</strong></li></ul><hr><p><strong><code>对于FIN：</code></strong></p><ul><li><strong>报文当中的FIN被设置为1，表明该报文是一个连接断开的请求报文</strong></li><li><strong>只有在断开连接阶段，FIN才被设置，正常通信时FIN不会被设置</strong></li></ul><hr><p><strong><code>对于URG：</code></strong></p><ul><li><strong>双方在进行网络通信的时候，由于TCP是保证数据按序到达的，即便发送端将要发送的数据分成了若干个TCP报文进行发送，最终到达接收端时这些数据也都是有序的，因为TCP可以通过序号来对这些TCP报文进行顺序重排，最终就能保证数据到达对端接收缓冲区中时是有序的</strong></li><li><strong>TCP按序到达本身也是我们的目的，此时对端上层在从接收缓冲区读取数据时也必须是按顺序读取的。但是有时候发送端可能发送了一些“紧急数据”，这些数据需要让对方上层提取进行读取，此时应该怎么办呢？</strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218230223495.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218230223495.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218230223495"><p><strong>此时就需要用到URG标志位，以及TCP报头当中的16位紧急指针</strong></p><ul><li><strong>当URG标志位被设置为１时，需要通过TCP报头当中的16位紧急指针来找到紧急数据，否则一般情况下不需要关注TCP报头当中的16位紧急指针</strong></li><li><strong>16位紧急指针代表的就是紧急数据在报文中的偏移量</strong></li><li><strong>因为紧急指针只有一个，它只能标识数据段中的一个位置，因此紧急数据只能发送一个字节，而至于这一个字节的具体含义这里就不展开讨论了</strong></li></ul><p><strong>recv函数的第四个参数flags有一个叫做MSG_OOB的选项可供设置，其中OOB是带外数据（out-of-band）的简称，带外数据就是一些比较重要的数据，因此上层如果想读取紧急数据，就可以在使用recv函数进行读取，并设置MSG_OOB选项</strong></p><p><img src="/image-20221218230350725.png" class="lazyload placeholder" data-srcset="/image-20221218230350725.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20221218230350725"></p><p><strong>与之对应的send函数的第四个参数flags也提供了一个叫做MSG_OOB的选项，上层如果想发送紧急数据，就可以使用send函数进行写入，并设置MSG_OOB选项</strong></p><p><img src="/image-20221218230433763.png" class="lazyload placeholder" data-srcset="/image-20221218230433763.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20221218230433763"></p><hr><p><strong><code>对于PSH：</code></strong></p><ul><li><strong>报文当中的PSH被设置为1，是在告诉对方尽快将你的接收缓冲区当中的数据交付给上层</strong></li><li><strong>我们一般认为：当使用read&#x2F;recv从缓冲区当中读取数据时，如果缓冲区当中有数据read&#x2F;recv函数就能够读到数据进行返回，而如果缓冲区当中没有数据，那么此时read&#x2F;recv函数就会阻塞住，直到当缓冲区当中有数据时才会读取到数据进行返回</strong></li><li><strong>实际这种说法是不太准确的，其实接收缓冲区和发送缓冲区都有一个水位线的概念</strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218230542025.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221218230542025.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221218230542025"><ul><li><strong>比如我们假设TCP接收缓冲区的水位线是100字节，那么只有当接收缓冲区当中有100字节时才让read&#x2F;recv函数读取这100字节的数据进行返回</strong></li><li><strong>如果接收缓冲区当中有一点数据就让read&#x2F;recv函数读取返回了，此时read&#x2F;recv就会频繁的进行读取和返回，进而影响读取数据的效率（在内核态和用户态之间切换也是有成本的）</strong></li><li><strong>因此不是说接收缓冲区当中只要有数据，调用read&#x2F;recv函数时就能读取到数据进行返回，而是当缓冲区当中的数据量达到一定量时才能进行读取</strong></li></ul><p><strong>当报文当中的PSH被设置为1时，实际就是在告知对方操作系统，尽快将接收缓冲区当中的数据交付给上层，尽管接收缓冲区当中的数据还没到达所指定的水位线。这也就是为什么我们使用read&#x2F;recv函数读取数据时，期望读取的字节数和实际读取的字节数是不一定吻合的</strong></p><hr><p><strong><code>对于RST：</code></strong></p><ul><li><strong>报文当中的RST被设置为1，表示需要让对方重新建立连接。</strong></li><li><strong>在通信双方在连接未建立好的情况下，一方向另一方发数据，此时另一方发送的响应报文当中的RST标志位就会被置1，表示要求对方重新建立连接。</strong></li><li><strong>在双方建立好连接进行正常通信时，如果通信中途发现之前建立好的连接出现了异常也会要求重新建立连接</strong></li></ul></blockquote><hr><h2 id="确认应答机制-ACK"><a href="#确认应答机制-ACK" class="headerlink" title="确认应答机制(ACK)"></a>确认应答机制(ACK)</h2><blockquote><p><strong><font color=red>TCP保证可靠性的机制之一就是确认应答机制</font></strong></p></blockquote><p><strong><mark>确认应答机制就是由TCP报头当中的，32位序号和32位确认序号来保证的。需要再次强调的是，确认应答机制不是保证双方通信的全部消息的可靠性，而是通过收到对方的应答消息，来保证自己曾经发送给对方的某一条消息被对方可靠的收到了</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219202903645.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219202903645.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221219202903645"><blockquote><p><strong><font color=red>如何理解TCP将每个字节的数据都进行了编号？</font></strong></p></blockquote><p><strong><mark>TCP是面向字节流的，我们可以将TCP的发送缓冲区和接收缓冲区都想象成一个字符数组</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219203123143.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219203123143.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221219203123143"><blockquote><ul><li><strong><font color=red>此时上层应用拷贝到TCP发送缓冲区当中的每一个字节数据天然有了一个序号，这个序号就是字符数组的下标，只不过这个下标不是从0开始的，而是从1开始往后递增的</font></strong></li><li><strong><font color=red>而双方在通信时，本质就是将自己发送缓冲区当中的数据拷贝到对方的接收缓冲区当中</font></strong></li><li><strong><font color=red>发送方发送数据时报头当中所填的序号，实际就是发送的若干字节数据当中，首个字节数据在发送缓冲区当中对应的下标</font></strong></li><li><strong><font color=red>接收方接收到数据进行响应时，响应报头当中的确认序号实际就是，接收缓冲区中接收到的最后一个有效数据的下一个位置所对应的下标</font></strong></li><li><strong><font color=red>当发送方收到接收方的响应后，就可以从下标为确认序号的位置继续进行发送了</font></strong></li></ul></blockquote><hr><h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2><p><strong><font color=red>超时重传机制概念：当发送端发送数据，如果在一段时间内没有收到应答(ACK)，会直接重发数据</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219205713202.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219205713202.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221219205713202"><blockquote><p><strong><font color=red>但是在我们在传输的时候可能会发生丢包问题</font></strong></p><ul><li><strong><code>丢包分为两种情况：</code></strong></li></ul><ol><li><p><strong><font color=red>第一种情况：发送的数据报文丢失了，此时发送端在一定时间内收不到对应的响应报文，就会进行超时重传</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219210403247.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219210403247.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221219210403247"></li><li><p><strong><font color=red>第二种情况：其实不是发送端发送的数据丢包了，而是对方发来的响应报文丢包了，此时发送端也会因为收不到对应的响应报文，而进行超时重传</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219210418929.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219210418929.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221219210418929"></li></ol><ul><li><strong><mark>当出现丢包时，发送方是无法辨别是发送的数据报文丢失了，还是对方发来的响应报文丢失了，因为这两种情况下发送方都收不到对方发来的响应报文，此时发送方就只能进行超时重传</mark></strong></li><li><strong><mark>如果是对方的响应报文丢失而导致发送方进行超时重传，此时接收方就会再次收到一个重复的报文数据，但此时也不用担心，接收方可以根据报头当中的32位序号来判断曾经是否收到过这个报文，从而达到报文去重的目的</mark></strong></li><li><strong><mark>需要注意的是，当发送缓冲区当中的数据被发送出去后，操作系统不会立即将该数据从发送缓冲区当中删除或覆盖，而会让其保留在发送缓冲区当中，以免需要进行超时重传，直到收到该数据的响应报文后，发送缓冲区中的这部分数据才可以被删除或覆盖</mark></strong></li></ul></blockquote><hr><h2 id="连接管理机制"><a href="#连接管理机制" class="headerlink" title="连接管理机制"></a>连接管理机制</h2><p><strong><font color=red>首先我们来理解一下连接：一台主机可能收到很多的连接，操作系统需要对连接进行管理，先描述后组织。所以连接在内核层会有对应数据结构。所以建立连接是有时间和空间的成本</font></strong></p><h3 id="三次握手和四次挥手图解"><a href="#三次握手和四次挥手图解" class="headerlink" title="三次握手和四次挥手图解"></a>三次握手和四次挥手图解</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219212417735.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219212417735.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221219212417735"><hr><h3 id="详解三次握手过程"><a href="#详解三次握手过程" class="headerlink" title="详解三次握手过程"></a>详解三次握手过程</h3><blockquote><p><strong><font color=red>详解三次握手过程：</font></strong></p><p><strong><mark>双方在进行TCP通信之前需要先建立连接，建立连接的这个过程我们称之为三次握手</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219212720149.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219212720149.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221219212720149"><p><strong><mark>以服务器和客户端为例，当客户端想要与服务器进行通信时，需要先与服务器建立连接，此时客户端作为主动方会先向服务器发送连接建立请求，然后双方TCP在底层会自动进行三次握手</mark></strong></p><ul><li><strong><font color=red>第一次握手：客户端向服务器发送的报文当中的SYN位被设置为1，表示请求与服务器建立连接</font></strong></li><li><strong><font color=red>第二次握手：服务器收到客户端发来的连接请求报文后，紧接着向客户端发起连接建立请求并对客户端发来的连接请求进行响应，此时服务器向客户端发送的报文当中的SYN位和ACK位均被设置为1</font></strong></li><li><strong><font color=red>第三次握手：客户端收到服务器发来的报文后，得知服务器收到了自己发送的连接建立请求，并请求和自己建立连接，最后客户端再向服务器发来的报文进行响应</font></strong></li></ul><p><strong><mark>需要注意的是，客户端向服务器发起的连接建立请求，是请求建立从客户端到服务器方向的通信连接，而TCP是全双工通信，因此服务器在收到客户端发来的连接建立请求后，服务器也需要向客户端发起连接建立请求，请求建立从服务器到客户端方法的通信连接</mark></strong></p><hr><p><strong><code>思考一个问题：为什么是三次握手呢？</code></strong></p><p><strong><font color=red>首先我们需要知道，连接建立不是百分之百能成功的，通信双方在进行三次握手时，其中前两次握手能够保证被对方收到，因为前两次握手都有对应的下一次握手对其进行响应，但第三次握手是没有对应的响应报文的，如果第三次握手时客户端发送的ACK报文丢失了，那么连接建立就会失败</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219213319865.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221219213319865.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221219213319865"><p><strong><mark>虽然客户端发起第三次握手后就完成了三次握手，但服务器却没有收到客户端发来的第三次握手，此时服务器端就不会建立对应的连接。所以建立连接时不管采用几次握手，最后一次握手的可靠性都是不能保证的</mark></strong></p><p><strong><mark>既然连接的建立都不是百分之百成功的，因此建立连接时具体采用几次握手的依据，实际是看几次握手时的优点更多，如下：</mark></strong></p><p><strong><font color=red>三次握手是验证双方通信信道的最小次数：</font></strong></p><ul><li><strong><font color=green>因为TCP是全双工通信的，因此连接建立的核心要务实际是，验证双方的通信信道是否是连通的</font></strong></li><li><strong><font color=green>而三次握手恰好是验证双方通信信道的最小次数，通过三次握手后双方就都能知道自己和对方是否都能够正常发送和接收数据</font></strong></li><li><strong><font color=green>在客户端看来，当它收到服务器发来第二次握手时，说明自己发出的第一次握手被对方可靠的收到了，证明自己能发以及服务器能收，同时当自己收到服务器发来的第二次握手时，也就证明服务器能发以及自己能收，此时就证明自己和服务器都是能发能收的</font></strong></li><li><strong><font color=green>在服务器看来，当它收到客户端发来第一次握手时，证明客户端能发以及自己能收，而当它收到客户端发来的第三次握手时，说明自己发出的第二次握手被对方可靠的收到了，也就证明自己能发以及客户端能收，此时就证明自己和客户端都是能发能收的</font></strong></li><li><strong><font color=green>既然三次握手已经能够验证双方通信信道是否正常了，那么三次以上的握手当然也是可以验证的，但既然三次已经能验证了就没有必要再进行更多次的握手了</font></strong></li></ul><p><strong><font color=red>三次握手能够保证连接建立时的异常连接挂在客户端：</font></strong></p><ul><li><strong><font color=green>当客户端收到服务器发来的第二次握手时，客户端就已经证明双方通信信道是连通的了，因此当客户端发出第三次握手后，这个连接就已经在客户端建立了</font></strong></li><li><strong><font color=green>而只有当服务器收到客户端发来的第三次握手后，服务器才知道双方通信信道是连通的，此时在服务器端才会建立对应的连接</font></strong></li><li><strong><font color=green>因此双方在进行三次握手建立连接时，双方建立连接的时间点是不一样的。如果客户端最后发出的第三次握手丢包了，此时在服务器端就不会建立对应的连接，而在客户端就需要短暂的维护一个异常的连接</font></strong></li><li><strong><font color=green>而维护连接是需要时间成本和空间成本的，因此三次握手还有一个好处就是能够保证连接建立异常时，这个异常连接是挂在客户端的，而不会影响到服务器</font></strong></li><li><strong><font color=green>虽然此时客户端也需要短暂维护这个异常，但客户端的异常连接不会特别多，不像服务器，一旦多个客户端建立连接时都建立失败了，此时服务器端就需要耗费大量资源来维护这些异常连接</font></strong></li><li><strong><font color=green>此外，建立连接失败时的异常连接不会一直维护下去。如果服务器端长时间收不到客户端发来的第三次握手，就会将第二次握手进行超时重传，此时客户端就有机会重新发出第三次握手。或者当客户端认为连接建立好后向服务器发送数据时，此时服务器会发现没有和该客户端建立连接而要求客户端重新建立连接</font></strong></li></ul><p><strong><font color=red>因此，这里给出两个建立连接时采用三次握手的理由：</font></strong></p><ul><li><strong><font color=green>三次握手是验证双方通信信道的最小次数，能够让能建立的连接尽快建立起来</font></strong></li><li><strong><font color=green>三次握手能够保证连接建立时的异常连接挂在客户端（风险转移）</font></strong></li></ul></blockquote><p><strong><font color=red>三次握手时的状态变化：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221124640255.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221124640255.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221124640255"><p><strong><mark>三次握手时的状态变化如下：</mark></strong></p><blockquote><ul><li><strong><font color=red>最开始时客户端和服务器都处于CLOSED状态</font></strong></li><li><strong><font color=red>服务器为了能够接收客户端发来的连接请求，需要由CLOSED状态变为LISTEN状态</font></strong></li><li><strong><font color=red>此时客户端就可以向服务器发起三次握手了，当客户端发起第一次握手后，状态变为SYN_SENT状态</font></strong></li><li><strong><font color=red>处于LISTEN状态的服务器收到客户端的连接请求后，将该连接放入内核等待队列中，并向客户端发起第二次握手，此时服务器的状态变为SYN_RCVD</font></strong></li><li><strong><font color=red>当客户端收到服务器发来的第二次握手后，紧接着向服务器发送最后一次握手，此时客户端的连接已经建立，状态变为ESTABLISHED</font></strong></li><li><strong><font color=red>而服务器收到客户端发来的最后一次握手后，连接也建立成功，此时服务器的状态也变成ESTABLISHED</font></strong></li></ul></blockquote><p><strong><font color=green>至此三次握手结束，通信双方可以开始进行数据交互了</font></strong></p><blockquote><p><strong><font color=red>套接字和三次握手之间的关系</font></strong></p><ul><li><strong><mark>在客户端发起连接建立请求之前，服务器需要先进入LISTEN状态，此时就需要服务器调用对应listen函数</mark></strong></li><li><strong><mark>当服务器进入LISTEN状态后，客户端就可以向服务器发起三次握手了，此时客户端对应调用的就是connect函数</mark></strong></li><li><strong><mark>需要注意的是，connect函数不参与底层的三次握手，connect函数的作用只是发起三次握手。当connect函数返回时，要么是底层已经成功完成了三次握手连接建立成功，要么是底层三次握手失败</mark></strong></li><li><strong><mark>如果服务器端与客户端成功完成了三次握手，此时在服务器端就会建立一个连接，但这个连接在内核的等待队列当中，服务器端需要通过调用accept函数将这个建立好的连接获取上来</mark></strong></li><li><strong><mark>当服务器端将建立好的连接获取上来后，双方就可以通过调用read&#x2F;recv函数和write&#x2F;send函数进行数据交互了</mark></strong></li></ul></blockquote><hr><h3 id="详解四次挥手过程"><a href="#详解四次挥手过程" class="headerlink" title="详解四次挥手过程"></a>详解四次挥手过程</h3><blockquote><p><strong><font color=red>详解四次挥手过程：</font></strong></p><p><strong><mark>由于双方维护连接都是需要成本的，因此当双方TCP通信结束之后就需要断开连接，断开连接的这个过程我们称之为四次挥手</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221125402640.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221125402640.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221125402640"><p><strong><font color=red>还是以服务器和客户端为例，当客户端与服务器通信结束后，需要与服务器断开连接，此时就需要进行四次挥手</font></strong></p><ul><li><strong><mark>第一次挥手：客户端向服务器发送的报文当中的FIN位被设置为1，表示请求与服务器断开连接</mark></strong></li><li><strong><mark>第二次挥手：服务器收到客户端发来的断开连接请求后对其进行响应</mark></strong></li><li><strong><mark>第三次挥手：服务器收到客户端断开连接的请求，且已经没有数据需要发送给客户端的时候，服务器就会向客户端发起断开连接请求</mark></strong></li><li><strong><mark>第四次挥手：客户端收到服务器发来的断开连接请求后对其进行响应</mark></strong></li><li><strong><font color=red>四次挥手结束后双方的连接才算真正断开</font></strong></li></ul></blockquote><blockquote><p><strong><font color=red>为什么是四次挥手？</font></strong></p><ul><li><strong><font color=green>由于TCP是全双工的，建立连接的时候需要建立双方的连接，断开连接时也同样如此。在断开连接时不仅要断开从客户端到服务器方向的通信信道，也要断开从服务器到客户端的通信信道，其中每两次挥手对应就是关闭一个方向的通信信道，因此断开连接时需要进行四次挥手</font></strong></li><li><strong><font color=green>需要注意的是，四次挥手当中的第二次和第三次挥手不能合并在一起，因为第三次握手是服务器端想要与客户端断开连接时发给客户端的请求，而当服务器收到客户端断开连接的请求并响应后，服务器不一定会马上发起第三次挥手，因为服务器可能还有某些数据要发送给客户端，只有当服务器端将这些数据发送完后才会向客户端发起第三次挥手</font></strong></li></ul></blockquote><p><strong><font color=red>四次挥手时的状态变化：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221125833983.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221125833983.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221125833983"><p><strong><font color=red>四次挥手时的状态变化如下：</font></strong></p><blockquote><ul><li><strong><mark>在挥手前客户端和服务器都处于连接建立后的ESTABLISHED状态</mark></strong></li><li><strong><mark>客户端为了与服务器断开连接主动向服务器发起连接断开请求，此时客户端的状态变为FIN_WAIT_1</mark></strong></li><li><strong><mark>服务器收到客户端发来的连接断开请求后对其进行响应，此时服务器的状态变为CLOSE_WAIT</mark></strong></li><li><strong><mark>当服务器没有数据需要发送给客户端的时，服务器会向客户端发起断开连接请求，等待最后一个ACK到来，此时服务器的状态变为LASE_ACK</mark></strong></li><li><strong><mark>客户端收到服务器发来的第三次挥手后，会向服务器发送最后一个响应报文，此时客户端进入TIME_WAIT状态</mark></strong></li><li><strong><mark>当服务器收到客户端发来的最后一个响应报文时，服务器会彻底关闭连接，变为CLOSED状态</mark></strong></li><li><strong><mark>而客户端则会等待一个2MSL（Maximum Segment Lifetime，报文最大生存时间）才会进入CLOSED状态</mark></strong></li></ul></blockquote><p><strong><font color=red>至此四次挥手结束，通信双方成功断开连接</font></strong></p><blockquote><p><strong><font color=red>套接字和四次挥手之间的关系</font></strong></p><ul><li><strong><mark>客户端发起断开连接请求，对应就是客户端主动调用close函数</mark></strong></li><li><strong><mark>服务器发起断开连接请求，对应就是服务器主动调用close函数</mark></strong></li><li><strong><mark>一个close对应的就是两次挥手，双方都要调用close，因此就是四次挥手</mark></strong></li></ul></blockquote><blockquote><p><strong><font color=red>对于CLOSE_WAIT的详解：</font></strong></p><ul><li><strong><mark>双方在进行四次挥手时，如果只有客户端调用了close函数，而服务器不调用close函数，此时服务器就会进入CLOSE_WAIT状态，而客户端则会进入到FIN_WAIT_2状态</mark></strong></li><li><strong><mark>但只有完成四次挥手后连接才算真正断开，此时双方才会释放对应的连接资源。如果服务器没有主动关闭不需要的文件描述符，此时在服务器端就会存在大量处于CLOSE_WAIT状态的连接，而每个连接都会占用服务器的资源，最终就会导致服务器可用资源越来越少</mark></strong></li><li><strong><mark>因此如果不及时关闭不用的文件描述符，除了会造成文件描述符泄漏以外，可能也会导致连接资源没有完全释放，这其实也是一种内存泄漏的问题</mark></strong></li><li><strong><mark>因此在编写网络套接字代码时，如果发现服务器端存在大量处于CLOSE_WAIT状态的连接，此时就可以检查一下是不是服务器没有及时调用close函数关闭对应的文件描述符</mark></strong></li></ul></blockquote><blockquote><p><strong><font color=red>对于TIME_WAIT的详解：</font></strong></p><p><strong><mark>四次挥手中前三次挥手丢包时的解决方法：</mark></strong></p><ul><li><strong><font color=red>第一次挥手丢包：客户端收不到服务器的应答，进而进行超时重传</font></strong></li><li><strong><font color=red>第二次挥手丢包：客户端收不到服务器的应答，进而进行超时重传</font></strong></li><li><strong><font color=red>第三次挥手丢包：服务器收不到客户端的应答，进而进行超时重传</font></strong></li><li><strong><font color=red>第四次挥手丢包：服务器收不到客户端的应答，进而进行超时重传</font></strong></li></ul></blockquote><p><strong><mark>如果客户端在发出第四次挥手后立即进入CLOSED状态，此时服务器虽然进行了超时重传，但已经得不到客户端的响应了，因为客户端已经将连接关闭了</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221131031486.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221131031486.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221131031486"><p><strong><mark>服务器在经过若干次超时重发后得不到响应，最终也一定会将对应的连接关闭，但在服务器不断进行超时重传期间还需要维护这条废弃的连接，这样对服务器是非常不友好的</mark></strong></p><p><strong><mark>为了避免这种情况，因此客户端在四次挥手后没有立即进入CLOSED状态，而是进入到了TIME_WAIT状态进行等待，此时要是第四次挥手的报文丢包了，客户端也能收到服务器重发的报文然后进行响应</mark></strong></p><blockquote><p><strong><font color=red>TIME_WAIT状态存在的必要性：</font></strong></p><ul><li><strong><mark>客户端在进行四次挥手后进入TIME_WAIT状态，如果第四次挥手的报文丢包了，客户端在一段时间内仍然能够接收服务器重发的FIN报文并对其进行响应，能够较大概率保证最后一个ACK被服务器收到</mark></strong></li><li><strong><mark>客户端发出最后一次挥手时，双方历史通信的数据可能还没有发送到对方。因此客户端四次挥手后进入TIME_WAIT状态，还可以保证双方通信信道上的数据在网络中尽可能的消散</mark></strong></li></ul><p><strong><font color=red>实际第四次挥手丢包后，可能双方网络状态出现了问题，尽管客户端还没有关闭连接，也收不到服务器重发的连接断开请求，此时客户端TIME_WAIT等若干时间最终会关闭连接，而服务器经过多次超时重传后也会关闭连接。这种情况虽然也让服务器维持了闲置的连接，但毕竟是少数，引入TIME_WAIT状态就是争取让主动发起四次挥手的客户端维护这个成本</font></strong></p><ul><li><strong><mark>因此TCP并不能完全保证建立连接和断开连接的可靠性，TCP保证的是建立连接之后，以及断开连接之前双方通信数据的可靠性</mark></strong></li></ul></blockquote><blockquote><p><strong><font color=red>TIME_WAIT的等待时长是多少？</font></strong></p><ul><li><p><strong><mark>TIME_WAIT的等待时长既不能太长也不能太短</mark></strong></p></li><li><p><strong><mark>太长会让等待方维持一个较长的时间的TIME_WAIT状态，在这个时间内等待方也需要花费成本来维护这个连接，这也是一种浪费资源的现象</mark></strong></p></li><li><p><strong><mark>太短可能没有达到我们最初目的，没有保证ACK被对方较大概率收到，也没有保证数据在网络中消散，此时TIME_WAIT的意义也就没有了</mark></strong></p></li></ul><p><strong><font color=red>TCP协议规定，主动关闭连接的一方在四次挥手后要处于TIME_WAIT状态，等待两个MSL（Maximum Segment Lifetime，报文最大生存时间）的时间才能进入CLOSED状态</font></strong></p><p><strong><font color=green>MSL在RFC1122中规定为两分钟，但是各个操作系统的实现不同，比如在Centos7上默认配置的值是60s。我们可以通过下面命令查看MSL：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cat <span class="token operator">/</span>proc<span class="token operator">/</span>sys<span class="token operator">/</span>net<span class="token operator">/</span>ipv4<span class="token operator">/</span>tcp_fin_timeout #查看MSL的值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><font color=green>TIME_WAIT的等待时长设置为两个MSL的原因：</font></strong></p><ul><li><strong><mark>MSL是TCP报文的最大生存时间，因此TIME_WAIT状态持续存在2MSL的话，就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失</mark></strong></li><li><strong><mark>同时也是在理论上保证最后一个报文可靠到达的时间</mark></strong></li></ul></blockquote><hr><h2 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h2><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221133324206.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221133324206.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221133324206"><p><strong><font color=red>滑动窗口存在的最大意义就是可以提高发送数据的效率：</font></strong></p><blockquote><ul><li><strong><mark>滑动窗口的大小等于对方窗口大小与自身拥塞窗口大小的较小值，因为发送数据时不仅要考虑对方的接收能力，还要考虑当前网络的状况</mark></strong></li><li><strong><mark>我们这里先不考虑拥塞窗口，并且假设对方的窗口大小一直固定为4000，此时发送方不用等待ACK一次所能发送的数据就是4000字节，因此滑动窗口的大小就是4000字节（四个段）</mark></strong></li><li><strong><mark>现在连续发送1001-2000、2001-3000、3001-4000、4001-5000这四个段的时候，不需要等待任何ACK，可以直接进行发送</mark></strong></li><li><strong><mark>当收到对方响应的确认序号为2001时，说明1001-2000这个数据段已经被对方收到了，此时该数据段应该被纳入发送缓冲区当中的第一部分，而由于我们假设对方的窗口大小一直是4000，因此滑动窗口现在可以向右移动，继续发送5001-6000的数据段，以此类推</mark></strong></li><li><strong><mark>滑动窗口越大，则网络的吞吐率越高，同时也说明对方的接收能力很强</mark></strong></li></ul></blockquote><hr><h3 id="滑动窗口的由来"><a href="#滑动窗口的由来" class="headerlink" title="滑动窗口的由来"></a>滑动窗口的由来</h3><p><strong><font color=red>TCP以1个段为单位，每发一个段进行一次确认应答的处理。这样的传输方式有一个缺点：包的往返时间越长通信性能就越低</font></strong></p><blockquote><p><strong><mark>刚才我们讨论了确认应答策略, 对每一个发送的数据段, 都要给一个ACK确认应答，收到ACK后再发送下一个数据段。这样做有一个比较大的缺点, 就是性能较差。尤其是数据往返的时间较长的时候</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221134356041.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221134356041.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221134356041"></blockquote><p><strong><font color=red>既然这样一发一收的方式性能较低, 那么我们一次发送多条数据, 就可以大大的提高性能(其实是将多个段的等待时间重叠在一起了）为解决这个问题，TCP引入了窗口这个概念。即使在往返时间较长的情况下，它也能控制网络性能的下降。如图所示，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221134923990.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221134923990.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221134923990"><blockquote><ul><li><strong><font color=red>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。图中，窗口大小为4个段，也就是4000个字节</font></strong></li><li><strong><font color=red>发送前四个段的时候, 不需要等待任何ACK, 直接发送</font></strong></li><li><strong><font color=red>收到第一个ACK后, 滑动窗口向后移动, 继续发送第五个段的数据; 依次类推</font></strong></li><li><strong><font color=red>操作系统内核为了维护这个滑动窗口, 需要开辟 发送缓冲区 来记录当前还有哪些数据没有应答; 只有确认应答过的数据, 才能从缓冲区删掉</font></strong></li><li><strong><font color=red>窗口越大, 则网络的吞吐率就越高</font></strong></li></ul></blockquote><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221135539734.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221135539734.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221135539734"><p><strong><mark>这种机制就被称为滑动窗口机制</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221141845039.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221141845039.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221141845039"><p><strong><font color=red>再具体一点就是：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221142024227.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221142024227.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221142024227"><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221150150119.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221150150119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221150150119"><hr><h3 id="滑动窗口存在的问题"><a href="#滑动窗口存在的问题" class="headerlink" title="滑动窗口存在的问题"></a>滑动窗口存在的问题</h3><p><strong><font color=red>滑动窗口的大小：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221142535966.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221142535966.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221142535966"><p><strong><font color=red>数据包已经传输给对方，但是对方返回的ACK数据包丢失：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221142818898.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221142818898.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221142818898"><blockquote><p><strong><font color=red>数据包已经抵达, ACK被丢了</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221143206703.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221143206703.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221143206703"><p><strong><font color=red>这种情况下, 部分ACK丢了并不要紧, 因为可以通过后续的ACK进行确认</font></strong></p></blockquote><blockquote><p><strong><font color=red>传输的数据包直接丢失，或者说是某个报文段丢失的情况</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221143723884.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221143723884.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221143723884"><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221143735665.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221143735665.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221143735665"><ul><li><strong><mark>当某一段报文段丢失之后, 发送端会一直收到 1001 这样的ACK, 就像是在提醒发送端 “我想要的是 1001开始的数据”一样</mark></strong></li><li><strong><mark>如果发送端主机连续三次收到了同样一个 “1001” 这样的应答, 就会将对应的数据 1001 - 2000 重新发送</mark></strong></li><li><strong><mark>这个时候接收端收到了 1001 之后, 再次返回的ACK就是7001了(因为2001 - 7000)接收端其实之前就已经收到了, 被放到了接收端操作系统内核的接收缓冲区中</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221143910478.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221143910478.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221143910478"></blockquote><hr><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><blockquote><p><strong><font color=red>接收端处理数据的速度是有限的。 如果发送端发的太快, 导致接收端的缓冲区被打满, 这个时候如果发送端继续发送,就会造成丢包, 继而引起丢包重传等等一系列连锁反应。因此TCP支持根据接收端的处理能力, 来决定发送端的发送速度。这个机制就叫做流量控制(Flow Control)</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221144245508.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221144245508.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221144245508"><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221144508032.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221144508032.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221144508032"><ul><li><strong><font color=red>接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段, 通过ACK端通知发送端</font></strong></li><li><strong><font color=red>窗口大小字段越大, 说明网络的吞吐量越高</font></strong></li><li><strong><font color=red>接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端</font></strong></li></ul><p><strong><font color=green>让我们来思考下，什么时候回复 发送方给接收方发送的数据？两种回复方式！</font></strong></p><ol><li><strong><font color=green>发送方主动给接收方发送窗口探测包，询问接收方的接收能力。注意：窗口探测包的数据的大小为固定的1字节</font></strong></li><li><strong><font color=green>接收方主动给发送方发送窗口更新通知</font></strong></li></ol><ul><li><strong><font color=red>发送端接受到这个窗口之后, 就会减慢自己的发送速度</font></strong></li><li><strong><font color=red>如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段, 使接收端把窗口大小告诉发送端</font></strong></li></ul></blockquote><p><strong><font color=green>接收端如何把窗口大小告诉发送端呢? 回忆我们的TCP首部中, 有一个16位窗口字段, 就是存放了窗口大小信息;那么问题来了, 16位数字最大表示65535, 那么TCP窗口最大就是65535字节么?</font></strong></p><p><strong><font color=red>实际上, TCP首部40字节选项中还包含了一个窗口扩大因子M, 实际窗口大小是 窗口字段的值左移 M 位</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221145545330.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221145545330.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221145545330"><hr><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221150646732.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221150646732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221150646732"><ul><li><strong><font color=red>虽然TCP有了滑动窗口这个大杀器, 能够高效可靠的发送大量的数据. 但是如果在刚开始阶段就发送大量的数据, 仍然可能引发问题</font></strong></li><li><strong><font color=red>因为网络上有很多的计算机, 可能当前的网络状态就已经比较拥堵. 在不清楚当前网络状态下, 贸然发送大量的数据,是很有可能引起雪上加霜的</font></strong></li><li><strong><font color=red>TCP引入 慢启动机制, 先发少量的数据, 探探路, 摸清当前的网络拥堵状态, 再决定按照多大的速度传输数据</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151314315.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151314315.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221151314315"><blockquote><p><strong><font color=red>此处引入一个概念称为<code>拥塞窗口</code>，详解如下：</font></strong></p><ul><li><strong><mark>发送开始的时候, 定义拥塞窗口大小为1个数据段（1MSS）</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151437841.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151437841.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221151437841"><ul><li><strong><mark>每次收到一个ACK应答, 拥塞窗口加1</mark></strong></li><li><strong><mark>每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的滑动窗口大小做比较, 取较小的值作为实际发送的窗口</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151507666.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151507666.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221151507666"></blockquote><p><strong><font color=red>像上面这样的拥塞窗口增长速度, 是指数级别的。“慢启动” 只是指初使时慢, 但是增长速度非常快</font></strong></p><blockquote><ul><li><strong><mark>为了不增长的那么快, 因此不能使拥塞窗口单纯的加倍</mark></strong></li><li><strong><mark>此处引入一个叫做<code>慢启动的阈值</code></mark></strong></li><li><strong><mark>当拥塞窗口超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长</mark></strong></li><li><strong><mark>当TCP开始启动的时候, 慢启动阈值等于窗口最大值</mark></strong></li><li><strong><mark>在每次超时重发的时候, 慢启动阈值会变成原来的一半, 同时拥塞窗口置回1</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151845767.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151845767.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221151845767"></blockquote><blockquote><p><strong><font color=red>少量的丢包, 我们仅仅是触发超时重传; 大量的丢包, 我们就认为网络拥塞，当TCP通信开始后, 网络吞吐量会逐渐上升，随着网络发生拥堵, 吞吐量会立刻下降</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151942843.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221151942843.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221151942843"><p><strong><font color=red>但是这种拥塞窗口的大小一旦到达网络拥塞的情况时，拥塞窗口的大小会直接一下子变为慢启动时的阈值，即1个MSS，但是这种情况其实是不科学的，因为我一次丢包有可能是正常的，这种正常的情况的发生有可能是网络闪断了，当网络闪断的时候，拥塞串口的大小就会被置为1，然后再慢启动，再进行拥塞控制，针对这种情况，我们就需要一种快恢复的机制</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221152023505.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221152023505.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221152023505"></blockquote><p><strong><code>总结一下：TCP为了实现拥塞控制，总共采用了慢启动机制、拥塞避免机制、快重传机制和快恢复机制</code></strong></p><blockquote><p><strong><font color=red>图示说明：</font></strong></p><ul><li><strong><mark>指数增长。刚开始进行TCP通信时拥塞窗口的值为1，并不断按指数的方式进行增长</mark></strong></li><li><strong><mark>加法增大。慢启动的阈值初始时为对方窗口大小的最大值，图中慢启动阈值的初始值为16，因此当拥塞窗口的值增大到16时就不再按指数形式增长了，而变成了的线性增长</mark></strong></li><li><strong><mark>乘法减小。拥塞窗口在线性增长的过程中，在增大到24时如果发生了网络拥塞，此时慢启动的阈值将变为当前拥塞窗口的一半，也就是12，并且拥塞窗口的值被重新设置为1，所以下一次拥塞窗口由指数增长变为线性增长时拥塞窗口的值应该是12</mark></strong></li></ul></blockquote><p><strong><font color=red>主机在进行网络通信时，实际就是在不断进行指数增长、加法增大和乘法减小</font></strong></p><p><strong><font color=red>需要注意的是，不是所有的主机都是同时在进行指数增长、加法增大和乘法减小的。每台主机认为拥塞窗口的大小不一定是一样的，即便是同区域的两台主机在同一时刻认为拥塞窗口的大小也不一定是完全相同的。因此在同一时刻，可能一部分主机正在进行正常通信，而另一部分主机可能已经发生网络拥塞了</font></strong></p><hr><h2 id="TCP的延迟应答"><a href="#TCP的延迟应答" class="headerlink" title="TCP的延迟应答"></a>TCP的延迟应答</h2><p><strong><font color=red>接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口。那是因为刚接收完数据，缓冲区已满</font></strong></p><p><strong><font color=green>当某个接收端收到这个小窗口的通知以后，会以它为上限发送数据，从而又降低了网络的利用率（这其实是窗口控制特有的问题，专门术语叫做糊涂窗口综合征）。为此，引入了一个方法，那就是收到数据以后并不立即返回确认应答，而是延迟一段时间的机制</font></strong></p><blockquote><ul><li><strong><font color=red>假设对方接收端缓冲区剩余空间大小为1M，对方一次收到500K的数据后，如果立即进行ACK应答，此时返回的窗口就是500K</font></strong></li><li><strong><font color=red>但实际接收端处理数据的速度很快，10ms之内就将接收缓冲区中500K的数据消费掉了</font></strong></li><li><strong><font color=red>在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来</font></strong></li><li><strong><font color=red>如果接收端稍微等一会再进行ACK应答，比如等待200ms再应答，那么这时返回的窗口大小就是1M</font></strong></li></ul></blockquote><p><strong>需要注意的是，<mark>延迟应答的目的不是为了保证可靠性，而是留出一点时间让接收缓冲区中的数据尽可能被上层应用层消费掉</mark>，此时在进行ACK响应的时候报告的窗口大小就可以更大，从而增大网络吞吐量，进而提高数据的传输效率</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221153446651.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221153446651.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221153446651"><p><strong>此外，不是所有的数据包都可以延迟应答</strong></p><ul><li><strong>数量限制：每个N个包就应答一次</strong></li><li><strong>时间限制：超过最大延迟时间就应答一次（这个时间不会导致误超时重传）</strong></li></ul><p><strong>延迟应答具体的数量和超时时间，依操作系统不同也有差异，一般N取2，超时时间取200ms</strong></p><hr><h2 id="TCP的捎带应答"><a href="#TCP的捎带应答" class="headerlink" title="TCP的捎带应答"></a>TCP的捎带应答</h2><p><strong><font color=red>捎带应答，其实是TCP通信时最常规的一种方式，就好比主机A给主机B发送了一条消息，当主机B收到这条消息后需要对其进行ACK应答，但如果主机B此时正好也要给主机A发送消息，此时这个ACK就可以搭顺风车，而不用单独发送一个ACK应答，此时主机B发送的这个报文既发送了数据，又完成了对收到数据的响应，这就叫做捎带应答</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221153616247.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221153616247.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221153616247"><blockquote><ul><li><strong><mark>捎带应答最直观的角度实际也是发送数据的效率，此时双方通信时就可以不用再发送单纯的确认报文了</mark></strong></li><li><strong><mark>此外，由于捎带应答的报文携带了有效数据，因此对方收到该报文后会对其进行响应，当收到这个响应报文时不仅能够确保发送的数据被对方可靠的收到了，同时也能确保捎带的ACK应答也被对方可靠的收到了</mark></strong></li></ul></blockquote><hr><h2 id="TCP中的粘包问题"><a href="#TCP中的粘包问题" class="headerlink" title="TCP中的粘包问题"></a>TCP中的粘包问题</h2><p><strong><font color=red>什么是粘包：</font></strong></p><blockquote><ul><li><strong><font color=red>首先要明确，粘包问题中的“包”，是指的应用层的数据包</font></strong></li><li><strong><font color=red>在TCP的协议头中，没有如同UDP一样的“报文长度”这样的字段</font></strong></li><li><strong><font color=red>站在传输层的角度，TCP是一个一个报文过来的，按照序号排好序放在缓冲区中</font></strong></li><li><strong><font color=red>但站在应用层的角度，看到的只是一串连续的字节数据</font></strong></li><li><strong><font color=red>那么应用程序看到了这么一连串的字节数据，就不知道从哪个部分开始到哪个部分，是一个完整的应用层数据包</font></strong></li></ul></blockquote><p><strong><font color=red>如何解决粘包问题：</font></strong></p><blockquote><p><strong><font color=green>要解决粘包问题，本质就是要明确报文和报文之间的边界</font></strong></p><ul><li><strong><mark>对于定长的包，保证每次都按固定大小读取即可</mark></strong></li><li><strong><mark>对于变长的包，可以在报头的位置，约定一个包总长度的字段，从而就知道了包的结束位置。比如HTTP报头当中就包含Content-Length属性，表示正文的长度</mark></strong></li><li><strong><mark>对于变长的包，还可以在包和包之间使用明确的分隔符。因为应用层协议是程序员自己来定的，只要保证分隔符不和正文冲突即可</mark></strong></li></ul></blockquote><p><strong><font color=red>UDP是否存在粘包问题？</font></strong></p><blockquote><ul><li><strong><mark>对于UDP，如果还没有上层交付数据，UDP的报文长度仍然在，同时，UDP是一个一个把数据交付给应用层的，有很明确的数据边界</mark></strong></li><li><strong><mark>站在应用层的角度，使用UDP的时候，要么收到完整的UDP报文，要么不收，不会出现“半个”的情况</mark></strong></li><li><strong><font color=red>因此UDP是不存在粘包问题的，根本原因就是UDP报头当中的16位UDP长度记录的UDP报文的长度，因此UDP在底层的时候就把报文和报文之间的边界明确了，而TCP存在粘包问题就是因为TCP是面向字节流的，TCP报文之间没有明确的边界</font></strong></li></ul></blockquote><hr><h2 id="TCP的异常情况"><a href="#TCP的异常情况" class="headerlink" title="TCP的异常情况"></a>TCP的异常情况</h2><p><strong><font color=red>TCP的异常情况分为三种：进程终止、机器重启、机器掉线(网线断开)</font></strong></p><blockquote><p><strong><mark>进程终止：</mark></strong></p><ul><li><strong>当客户端正常访问服务器时，如果客户端进程突然崩溃了，此时建立好的连接会怎么样？</strong></li><li><strong>当一个进程退出时，该进程曾经打开的文件描述符都会自动关闭，因此当客户端进程退出时，相当于自动调用了close函数关闭了对应的文件描述符，此时双方操作系统在底层会正常完成四次挥手，然后释放对应的连接资源。也就是说，进程终止时会释放文件描述符，TCP底层仍然可以发送FIN，和进程正常退出没有区别</strong></li></ul><hr><p><strong><mark>机器重启：</mark></strong></p><ul><li><strong>当客户端正常访问服务器时，如果将客户端主机重启，此时建立好的连接会怎么样？</strong></li><li><strong>当我们选择重启主机时，操作系统会先杀掉所有进程然后再进行关机重启，因此机器重启和进程终止的情况是一样的，此时双方操作系统也会正常完成四次挥手，然后释放对应的连接资源</strong></li></ul><hr><p><strong><mark>机器掉线：</mark></strong></p><p><strong>当客户端正常访问服务器时，如果将客户端突然掉线了，此时建立好的连接会怎么样？</strong></p><p><strong>当客户端掉线后，服务器端在短时间内无法知道客户端掉线了，因此在服务器端会维持与客户端建立的连接，但这个连接也不会一直维持，因为TCP是有保活策略的，如下：</strong></p><ul><li><strong>服务器会定期客户端客户端的存在状况，检查对方是否在线，如果连续多次都没有收到ACK应答，此时服务器就会关闭这条连接</strong></li><li><strong>此外，客户端也可能会定期向服务器“报平安”，如果服务器长时间没有收到客户端的消息，此时服务器也会将对应的连接关闭</strong></li></ul><p><strong>其中服务器定期询问客户端的存在状态的做法，叫做基于保活定时器的一种心跳机制，是由TCP实现的。此外，应用层的某些协议，也有一些类似的检测机制，例如基于长连接的HTTP，也会定期检测对方的存在状态</strong></p></blockquote><hr><h2 id="TCP的保活机制"><a href="#TCP的保活机制" class="headerlink" title="TCP的保活机制"></a>TCP的保活机制</h2><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221161540676.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-tcp-xie-yi-chuan-shu-ceng/image-20221221161540676.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221221161540676"><hr><h2 id="对于TCP协议机制的总结"><a href="#对于TCP协议机制的总结" class="headerlink" title="对于TCP协议机制的总结"></a>对于TCP协议机制的总结</h2><p><strong><font color=red>TCP协议这么复杂就是因为TCP既要保证可靠性，同时又尽可能的提高性能</font></strong></p><blockquote><p><strong><font color=red>在可靠性上的机制：</font></strong></p><ol><li><strong><code>检验和</code></strong></li><li><strong><code>序列号</code></strong></li><li><strong><code>确认应答</code></strong></li><li><strong><code>超时重传</code></strong></li><li><strong><code>连接管理</code></strong></li><li><strong><code>流量控制</code></strong></li><li><strong><code>拥塞控制</code></strong></li></ol></blockquote><blockquote><p><strong><font color=red>在提高性能上的机制：</font></strong></p><ul><li><strong><code>滑动窗口</code></strong></li><li><strong><code>快速重传</code></strong></li><li><strong><code>延迟应答</code></strong></li><li><strong><code>捎带应答</code></strong></li></ul></blockquote><blockquote><p><strong><font color=red>在定时器上的机制：</font></strong></p><ul><li><strong><code>重传定时器：为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间</code></strong></li><li><strong><code>坚持定时器：专门为对方零窗口通知而设立的，也就是向对方发送窗口探测的时间间隔</code></strong></li><li><strong><code>保活定时器：为了检查空闲连接的存在状态，也就是向对方发送探查报文的时间间隔</code></strong></li><li><strong><code>TIME_WAIT定时器：双方在四次挥手后，主动断开连接的一方需要等待的时长</code></strong></li></ul></blockquote><p><strong><mark>需要注意的是，TCP的这些机制有些能够通过TCP报头体现出来的，但还有一些是通过代码逻辑体现出来的</mark></strong></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux网络协议之TCP协议-传输层&quot;&gt;&lt;a href=&quot;#Linux网络协议之TCP协议-传输层&quot; class=&quot;headerlink&quot; title=&quot;Linux网络协议之TCP协议(传输层)&quot;&gt;&lt;/a&gt;Linux网络协议之TCP协议(传输层)&lt;/h1&gt;&lt;h2</summary>
      
    
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络协议之IP协议(网络层)</title>
    <link href="https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/"/>
    <id>https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/</id>
    <published>2023-03-20T04:16:00.000Z</published>
    <updated>2023-06-23T19:01:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux网络协议之IP协议-网络层"><a href="#Linux网络协议之IP协议-网络层" class="headerlink" title="Linux网络协议之IP协议(网络层)"></a>Linux网络协议之IP协议(网络层)</h1><h2 id="IP协议基本概念"><a href="#IP协议基本概念" class="headerlink" title="IP协议基本概念"></a>IP协议基本概念</h2><p><strong><font color=red>IP协议全称为“网际互连协议（Internet Protocol）”，IP协议是TCP&#x2F;IP体系中的网络层协议</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227122816940.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227122816940.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227122816940"><blockquote><p><strong><font color=red>三个基本概念：</font></strong></p><ol><li><strong><code>主机：配有IP地址，但是不进行路由控制的设备</code></strong></li><li><strong><code>路由器：既有IP地址，又进行路由控制的设备</code></strong></li><li><strong><code>节点：主机和路由器的统称</code></strong></li></ol><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227123134267.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227123134267.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227123134267"></blockquote><hr><h2 id="IPV4协议格式"><a href="#IPV4协议格式" class="headerlink" title="IPV4协议格式"></a>IPV4协议格式</h2><p><strong><font color=red>IPV4协议格式如下：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227123618650.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227123618650.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227123618650"><blockquote><ul><li><strong><font color=red>4位版本号(version)：指定IP协议版本，对于IPV4来说就是4，对于IPV6来说就是6</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227125322264.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227125322264.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227125322264"><hr><ul><li><strong><font color=red>4位首部长度(header length)：IP头部的长度是个32bit, 也就是 length * 4 的字节数，4bit能表示最大的数字是15(2^4-1), 因此IP头部最大长度是60字节(4x15&#x3D;60)</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227125851132.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227125851132.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227125851132"><hr><ul><li><strong><font color=red>8位服务类型(type of service)：</font></strong></li><li><strong>3位优先权字段(已经弃用), 4位TOS字段, 和1位保留字段(必须置为0). 4位TOS分别表示: 最小延时, 最大吞吐量, 最高可靠性, 最小成本. 这四者相互冲突, 只能选择一个. 对于ssh&#x2F;telnet这样的应用程序, 最小延时比较重要; 对于ftp这样的程序, 最大吞吐量比较重要</strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227125959951.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227125959951.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227125959951"><hr><ul><li><strong><font color=red>16位总长度(total length)：IP数据报整体占多少个字节</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227130046241.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227130046241.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227130046241"><hr><ul><li><strong><font color=red>16位标识(Id)：唯一的标识主机发送的报文。如果IP报文在数据链路层被分片了, 那么每一个片里面的这个id都是相同的</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227130216198.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227130216198.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227130216198"><hr><ul><li><p><strong><font color=red>3位标志字段：第一位保留(保留的意思是现在不用, 但是还没想好说不定以后要用到). 第二位置为1表示禁止分片, 这时候如果报文长度超过MTU, IP模块就会丢弃报文. 第三位表示”更多分片”, 如果分片了的话,最后一个分片置为1, 其他是0. 类似于一个结束标记</font></strong></p></li><li><p><strong>第一位保留(保留的意思是现在不用, 但是还没想好说不定以后要用到). 第二位置为1表示禁止分片, 这时候如果报文长度超过MTU, IP模块就会丢弃报文. 第三位表示”更多分片”, 如果分片了的话,最后一个分片置为1, 其他是0. 类似于一个结束标记</strong></p></li></ul><hr><ul><li><strong><font color=red>13位分片偏移(framegament offset)：分片相当于在原始数据当中的偏移量</font></strong></li></ul><hr><ul><li><p><strong><font color=red>8位生存时间(Time To Live，TTL)：</font></strong></p></li><li><p><strong>数据报到达目的地的最大报文跳数. 一般是64. 每次经过一个路由, TTL-&#x3D; 1, 一直减到0还没到达, 那么就丢弃了. 这个字段主要是用来防止出现路由循环</strong></p></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227131910586.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227131910586.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227131910586"><hr><ul><li><strong><font color=red>8位协议：表示上层协议的类型</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227132001026.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227132001026.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227132001026"><hr><ul><li><strong><font color=red>16位头部校验和：使用CRC进行校验, 来鉴别头部是否损坏</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227132211521.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227132211521.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227132211521"><hr><ul><li><strong><font color=red>32位源地址和32位目标地址：表示发送端和接收端</font></strong></li></ul><hr><ul><li><strong><font color=red>选项字段：不定长，最多40字节</font></strong></li></ul></blockquote><hr><h2 id="分片与组装"><a href="#分片与组装" class="headerlink" title="分片与组装"></a>分片与组装</h2><blockquote><p><strong><font color=red>分片与组装过程：</font></strong></p><ul><li><strong><mark>如果IP层要传送的数据超过了1500字节，那么就需要先在IP层对该数据进行分片，然后再将分片后的数据交给下层MAC帧进行发送</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227135959215.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227135959215.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227135959215"><ul><li><strong><mark>如果发送数据时在IP层进行了分片，那么当这些分片数据到达对端主机的IP层后就需要先进行组装，然后再将组装好的数据交付给上层传输层</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227140028681.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221227140028681.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221227140028681"><p><strong><mark>注意：</mark></strong></p><ul><li><strong>数据的分片不是经常需要做的，实际在网络通信过程中不分片才是常态，因为数据分片会存在一些潜在的问题，比如分片可能会增加丢包的概率</strong></li><li><strong>数据的分片和组装发生在IP层，不仅源端主机可能会对数据进行分片，数据在路由过程中的路由器也可能对数据进行分片。因为不同网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU小，那么路由器就可能对IP数据报再次进行分片</strong></li><li><strong>分片数据的组装只会发生在目的端的IP层</strong></li><li><strong>在分片的数据中，每一个分片在IP层都会被添加上对应的IP报头，而传输层添加的报头只会出现在第一个分片中，因此网络中传输的数据包可能没有传输层的报头</strong></li></ul></blockquote><blockquote><p><strong><font color=red>数据的分片和组装都是由IP层完成的：</font></strong></p><ul><li><p><strong>数据的分片和组装都是在IP层完成的，上层的传输层和下层的链路层并不关心</strong></p></li><li><p><strong>传输层只负责为数据传送提供可靠性保证，比如当数据传送失败后，传输层的TCP协议可以组织进行数据重传</strong></p></li><li><p><strong>当TCP将待发送的数据交给IP后，TCP并不关心该数据是否会在IP层进行分片，即TCP并不关心数据具体的发送过程</strong></p></li><li><p><strong>当TCP从IP获取到数据后，TCP也不关心该数据是否在IP层经过了组装</strong></p></li><li><p><strong>而链路层的MAC帧只负责，将数据从一个节点传送到和自己相连的下一个节点</strong></p></li><li><p><strong>当IP将待发送的数据交给MAC帧后，MAC帧并不知道该数据是IP经过分片后的某个分片数据，还是一个没有经过分片的数据，MAC帧只知道它一次最多只能发送MTU大小的数据，如果IP交给MAC帧大于MTU字节的数据，那MAC帧就无法进行发送</strong></p></li><li><p><strong>MAC帧从网络中获取到数据后，MAC帧也不关心这个数据是否需要进行组装，MAC帧只需要将该数据的MAC帧报头去掉后直接上交给上层IP就行了，而至于该数据的组装问题则是IP需要解决的</strong></p></li><li><p><strong>因此，数据的分片和组装完全是由IP协议自己完成的，传输层和链路层不必关心也不需要关心</strong></p></li></ul></blockquote><blockquote><p><strong><font color=red>分片的过程：</font></strong></p><ul><li><strong>假设IP层要发送4500字节的数据，由于该数据超过了MAC帧规定的MTU，因此IP需要先将该数据进行分片，然后再将一个个的分片交给MAC帧进行发送</strong></li><li><strong>IP报头如果不携带选项字段，那么其大小就是20字节，假设IP层添加的IP报头的长度就是20字节，并按下列方式将数据分片后形成了四个分片报文，如下图：</strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229161430947.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229161430947.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229161430947"><ul><li><strong>需要注意的是，分片后的每一个分片数据都需要封装上对应的IP报头，因此4500字节的数据至少需要分为四个分片报文进行发送</strong></li><li><strong>分片报文到达对方的IP层后需要被重新组装起来，因此IP层在对数据进行分片时需要记录分片的信息，而IP报头当中的16位标识、3位标志和13位片偏移实际就是与数据分片相关的字段</strong></li><li>16位标识：唯一标识主机发送的报文，如果数据在IP层进行了分片，那么每一个分片报文的16位标识是相同的</li><li>3位标志：第一位保留，表示暂时没有规定该字段的意义。第二位表示禁止分片，表示如果报文长度超过MTU，IP模块就会丢弃该报文。第三位表示“更多分片”，如果报文没有进行分片，则该字段设置为0，如果报文进行了分片，则除了最后一个分片报文设置为0以外，其余分片报文均设置为1</li><li>13位片偏移：分片相对于原始数据开始处的偏移，表示当前分片在原数据中的偏移位置，实际偏移的字节数是这个值× 8 \times 8×8得到的。因此除了最后一个报文之外，其他报文的长度必须是8的整数倍，否则报文就不连续了</li><li>因此上述四个分片报文对应的16位标识都是一样的，假设四个分片报文的16位标识都是123，则这四个报文对应的16位标识、3位标志中的“更多分片”和13位片偏移分别如下：</li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229161523760.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229161523760.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229161523760"><ul><li><strong>需要注意的是，13位片偏移当中记录的字节数是当前分片在原数据开始处的偏移字节数的值÷ 8 \div 8÷8得到的，比如分片报文2在原始数据开始处的偏移字节数是1480，其对应的13位片偏移的值就是1480÷8&#x3D;185</strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229161604388.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229161604388.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229161604388"></blockquote><p>​</p><blockquote><p><strong><font color=red>组装的过程：</font></strong></p><ul><li><strong>MAC帧交给IP层的数据可能来自世界各地，这些数据可能是经过分片后发送的，也可能是没有经过分片直接发送的，因此IP必须要通过某种方式来区分收到的各个数据</strong></li><li><strong>IP报头当中有32位源IP地址，源IP地址记录了发送端所对应的IP地址，因此通过IP报头当中的32位源IP地址就可以区分来自不同主机的数据</strong></li><li><strong>IP报头当中有16位标识，未分片的数据各自的16位标识都是不同的，而由同一个数据分片得到的各个分片报文所对应的16位标识都是相同的，因此通过IP报头当中16位标识就可以判断哪些报文是没有经过分片的独立报文，哪些报文是经过分片后的分片报文</strong></li><li><strong>因此IP可以通过IP报头当中的32位源IP地址和16位标识，将经过分片的数据各自聚合在一起，聚合在一起后就可以开始进行组装了</strong></li><li><strong>对于各个分片报文来说：</strong><ul><li><strong>第一个分片报文中的13位片偏移的值一定为0</strong></li><li><strong>最后一个分片报文中的“更多分片”标志位一定为0</strong></li><li><strong>对于每一个分片报文来说，当前报文的13位片偏移加上当前报文的数据字节数 ÷ 8所得到的值，就是下一个分片报文的所对应的13位片偏移</strong></li></ul></li><li><strong>根据分片报文的这三个特点就能够将分片报文合理的组装起来</strong></li><li><strong>先找到分片报文中13位片偏移为0的分片报文，然后提取出其IP报头当中的16位总长度字段，通过计算即可得出下一个分片报文所对应的13位片偏移，按照此方式依次将各个分片报文拼接起来</strong></li><li><strong>直到拼接到一个“更多分片”标志位为0的分片报文，此时表明分片报文组装完毕</strong></li></ul></blockquote><blockquote><p><strong><font color=red>分片报文丢包的问题：</font></strong></p><ul><li><strong>分片后的报文在网络传输过程中也可能会出现丢包问题，但接收端有能力判断是否收到了全部分片报文，比如假设某组分片报文对应的16位标识值为x：</strong><ul><li><strong>如果分片报文中的第一个分片报文丢包了，那么接收端收到的分片报文中就找不到对应16位标识为x，并且13位片偏移为0的分片报文</strong></li><li><strong>如果分片报文中的最后一个分片报文丢包了，那么接收端收到的分片报文中就找不到对应16为标识为x，并且“更多分片”标志位为0的分片报文</strong></li><li><strong>如果分片报文中的其它分片报文丢包了，那么接收端在进行分片报文的组装时就会找不到对应13位片偏移为特定值的分片报文</strong></li></ul></li><li><strong>需要注意的是，未分片报文的“更多分片”标志位为0，最后一个分片报文的“更多分片”标志位也为0，但当接收端只收到分片报文中的最后一个分片报文时，接收端不会将其识别成一个未分片的报文，因为未分片的报文所对应的13位片偏移的值也应该是0，而最后一个分片报文所对应的13位片偏移的值不为0</strong></li><li><strong>因此只有当一个报文的13位片偏移为0，并且该报文的“更多分片”标志位也为0时，该报文才会被识别成一个没有被分片的独立报文，否则该报文就会被识别成一个分片报文</strong></li></ul></blockquote><blockquote><p><strong><font color=red>为什么不建议进行分片？</font></strong></p><ul><li><strong>虽然传输层并不关心IP层的分片问题，但分片对传输层也是有影响的</strong></li><li><strong>如果一个数据在网络传输过程中没有经过分片，那么只要接收端收到了这一个报文，我们就可以认为该数据被对方可靠的收到了</strong></li><li><strong>而如果一个数据在网络传输过程中进行了分片，那么只有当接收端收到了全部的分片报文并将其成功组装起来，这时我们才认为该数据被对方可靠的收到了。但如果众多的分片报文当中有一个报文出现了丢包，就会导致接收端就无法将报文成功组装起来，这时接收端会将收到的分片报文全部丢弃，此时传输层TCP会因为收不到对方应答而进行超时重传</strong></li><li><strong>假设在网络传输时丢包的概率是万分之一，如果将数据拆分为一百份进行发送，那么此时丢包的概率就上升到了百分之一。因为只要有一个分片报文丢包了也就等同于这个报文整体丢失了，因此分片会增加传输层重传数据的概率</strong></li><li><strong>需要注意的是，只要分片报文当中的某一个出现了丢包，此时传输层都需要将数据整体进行重传，因为传输层并不知道底层IP对数据进行了分片，当传输层发送出去的数据得不到应答时传输层就只能将数据整体进行重传，因此数据在发送时不建议进行分片</strong></li></ul></blockquote><blockquote><p><strong><font color=red>如何尽可能避免分片？</font></strong></p><ul><li><strong>实际数据分片的根本原因在于传输层一次向下交付的数据太多了，导致IP无法直接将数据向下交给MAC帧，如果传输层控制好一次交给IP的数据量不要太大，那么数据在IP层自然也就不需要进行分片</strong></li><li><strong>因此TCP作为传输控制协议，它需要控制一次向下交付数据不能超过某一阈值，这个阈值就叫做MSS（Maximum Segment Size，最大报文段长度）</strong></li><li><strong>通信双方在建立TCP连接时，除了需要协商自身窗口大小等概念之外，还会协商后续通信时每一个报文段所能承载的最大报文段长度MSS</strong></li><li><strong>MAC帧的有效载荷最大为MTU，TCP的有效载荷最大为MSS，由于TCP和IP常规情况下报头的长度都是20字节，因此一般情况下 MSS &#x3D; MTU - 20 - 20，而MTU的值一般是1500字节，因此MSS的值一般就是1460字节</strong></li><li><strong>所以一般建议TCP将发送的数据控制在1460字节以内，此时就能够降低数据分片的可能性。之所以说是降低数据分片的可能性，是因为每个网络的链路层对应的MTU可能是不同的，如果数据在传输过程中进入到了一个MTU较小的网络，那么该数据仍然可能需要在路由器中进行分片</strong></li></ul></blockquote><hr><h2 id="IP网段划分"><a href="#IP网段划分" class="headerlink" title="IP网段划分"></a>IP网段划分</h2><h3 id="IP地址组成"><a href="#IP地址组成" class="headerlink" title="IP地址组成"></a>IP地址组成</h3><blockquote><p><strong><font color=green>路由查找目标主机过程：路由查找是先找到目标网络，在找到目标主机</font></strong></p></blockquote><p><strong><font color=red>IP地址可以分为两个部分：网络号和主机号</font></strong></p><ul><li><strong><mark>网络号：保证相互连接的两个网段具有不同的标识</mark></strong></li><li><strong><mark>主机号：在同一网段内，主机具有相同的网络号，但是具有不同的主机号。标识相同网段里的不同主机</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229163906962.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229163906962.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229163906962"><ul><li><strong><mark>不同的子网其实就是把网络号相同的主机连接到了一起</mark></strong></li><li><strong><mark>如果在子网中新增一台主机，这台主机的网络号和这个子网的网络号一致，但是主机号必须不同和子网中的其它主机重复</mark></strong></li></ul><p><strong><font color=red>由上可知，在子网中新增一台主机需要为其分配对应且正确的IP，去除一台主机的话，需要回收IP。但是手动管理子网IP很麻烦</font></strong></p><ul><li><strong><mark>有一种技术DHCP，能够自动的给子网内新增主机结点分配IP地址，避免了手动管理的不便</mark></strong></li><li><strong><mark>一般现在的路由器都带有DHCP功能，因此路由器可以看作一个DHCP服务器</mark></strong></li></ul><hr><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p><strong><font color=red>过去曾经提出一种划分网络号和主机号的方案，就是把所有IP地址分为五类，如下图所示：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229164233812.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229164233812.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229164233812"><blockquote><p><strong><font color=red>因此，各类IP地址的取值范围如下：</font></strong></p><ul><li><strong><code>A类：</code><mark>0.0.0.0 ~ 127.255.255.255</mark></strong></li><li><strong><code>B类：</code><mark>128.0.0.0 ~ 191.255.255.255</mark></strong></li><li><strong><code>C类：</code><mark>192.0.0.0 ~ 223.255.255.255</mark></strong></li><li><strong><code>D类：</code><mark>224.0.0.0 ~ 239.255.255.255</mark></strong> </li><li><strong><code>E类：</code><mark>240.0.0.0 ~ 247.255.255.255</mark></strong></li></ul></blockquote><p><strong><font color=red>当要判断一个IP地址是属于哪一类时，只需要遍历IP地址的前五个比特位，第几个比特位最先出现0值，那么这个IP地址对应就属于A、B、C、D、E类地址</font></strong></p><p><strong><font color=blue>这种划分方法，我们发现 A，B，C类越往下网络号表示越来越多，主机号表示越来越少。随着互联网的发展，大多数组织都申请B类网络地址，导致B类很快就用完了，针对上面的情况，提出了一个新的方案，称为CIDR(无类域间路)。只与子网掩码有关，通过子网掩码要区分网络号和主机号</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229165229516.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229165229516.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229165229516"><blockquote><p><strong><font color=red>CIDR(Classless Interdomain Routing)：又叫无类域间路</font></strong></p><ul><li><strong><mark>引入一个额外的子网掩码(subnet mask)来区分网络号和主机号</mark></strong></li><li><strong><mark>子网掩码也是一个32位的正整数。通常用一串 “0” 来结尾</mark></strong></li><li><strong><mark>将IP地址和子网掩码进行 “按位与” 操作, 得到的结果就是网络号</mark></strong></li><li><strong><mark>网络号和主机号的划分与这个IP地址是A类、B类还是C类无关</mark></strong></li></ul></blockquote><p><strong><font color=red>CIDR划分法如何计算当前网络的网络号：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229170038142.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229170038142.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229170038142"><p><strong><font color=red>如何得到当前子网中的IP地址使用多少个比特位作为主机号？</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229170204397.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229170204397.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229170204397"><p><strong>比如：</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229170310170.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229170310170.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229170310170"><hr><h3 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h3><blockquote><ul><li><strong><font color=red>在一个网段中都会有一个网络号的和广播号，即 192.0.0.0 ~ 192.0.0.255</font></strong></li><li><strong><font color=red>网络号：主机号全为0的ip地址，就为该网段中的网络号，代表整个局域网</font></strong></li><li><strong><font color=red>广播号：主机号中全为1的ip地址，就为该网段中的广播号，代表广播地址</font></strong></li><li><strong><font color=red>127.0.0.1 ：本地回环网卡地址（通常用来测试自己机器的网络连通性）</font></strong></li><li><strong><font color=red>0.0.0.0：代表本地所有的网卡地址</font></strong></li></ul></blockquote><hr><h3 id="IP地址的数量限制"><a href="#IP地址的数量限制" class="headerlink" title="IP地址的数量限制"></a>IP地址的数量限制</h3><blockquote><ul><li><strong><mark>我们知道, IP地址(IPv4)是一个4字节32位的正整数。那么一共只有2<sup>32</sup>个IP地址, 大概是43亿左右。而TCP&#x2F;IP协议规定, 每个主机都需要有一个IP地址，这意味着, 一共只有43亿台主机能接入网络么?</mark></strong></li><li><strong><mark>实际上, 由于一些特殊的IP地址的存在, 数量远不足43亿; 另外IP地址并非是按照主机台数来配置的, 而是每一个网卡都需要配置一个或多个IP地址</mark></strong></li><li><strong><font color=red>CIDR在一定程度上缓解了IP地址不够用的问题(提高了利用率, 减少了浪费。但是IP地址的绝对上限并没有增加), 仍然不是很够用。 这时候有三种方式来解决：</font></strong><ol><li><strong><code>动态分配IP地址: 只给接入网络的设备分配IP地址. 因此同一个MAC地址的设备, 每次接入互联网中, 得到的IP地址不一定是相同的</code></strong></li><li><strong><code>NAT技术</code></strong></li><li><strong><code>IPv6: IPv6并不是IPv4的简单升级版. 这是互不相干的两个协议, 彼此并不兼容; IPv6用16字节128位来表示一个IP地址; 但是目前IPv6还没有普及</code></strong></li></ol></li></ul></blockquote><hr><h3 id="私网IP地址与公网IP地址"><a href="#私网IP地址与公网IP地址" class="headerlink" title="私网IP地址与公网IP地址"></a>私网IP地址与公网IP地址</h3><blockquote><p> <strong><font color=red>首先了解一下运营商：运营商为我们建设了网络通信的基础设施。当我们在进行通信的时候，都需要经过运营商为我们建立的基础设施</font></strong></p><ul><li><strong>我们知道IPv4的IP地址个数是一个确定的数，某些组织有将所有的IP地址分成了两大类，私网IP地址和公网IP地址</strong></li><li><strong><font color=red>私网IP地址和公网IP地址的区别：</font></strong><ul><li><strong>私网就可以理解成是一个局域网。私网可以有很多个，而公网只有一个</strong></li><li><strong>顾名思义，私网IP就是在私网中使用的IP地址，公网IP就是在公网中使用的IP地址</strong></li><li><strong>不同的私网私网IP可以相同，但是在公网中，公网IP只有一个，是唯一的</strong></li><li><strong>同一私网内的IP地址不能是重复的</strong></li></ul></li><li><strong><font color=red>RFC1918规定，包含在以下范围的IP地址称为私有IP地址，其余的都是公网IP地址</font></strong><ul><li><strong>私有IP地址：</strong></li><li><strong><code>10.*</code>，前8位是网络号，共16777216个地址</strong></li><li>**<code>172.16.*到172.31.*</code>，前12位是网络号，共1048576个地址**</li><li><strong><code>192.168.*</code>前16位是网络号，共65536个地址</strong></li></ul></li></ul></blockquote><p><strong><font color=red>让我们来了解下数据是如何发送到服务器的：</font></strong></p><blockquote><p><strong><font color=red>路由器是连接两个或多个网络的硬件设备，在路由器上有两种网络接口，分别是LAN口和WAN口：</font></strong></p><ul><li><strong><mark>LAN口（Local Area Network）：表示连接本地网络的端口，主要与家庭网络中的交换机、集线器或PC相连</mark></strong></li><li><strong><mark>WAN口（Wide Area Network）：表示连接广域网的端口，一般指互联网</mark></strong></li></ul><p><strong><font color=red>我们将LAN口的IP地址叫做LAN口IP，也叫做子网IP，将WAN口的IP地址叫做WAN口IPO，也叫做外网IP</font></strong></p><p><strong><font color=red>我们使用的电脑、家用路由器、运营商路由器、广域网以及我们要访问的服务器之间的关系大致如下：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229172212580.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229172212580.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229172212580"><ul><li><strong><mark>不同的路由器，子网IP其实都是一样的（通常都是192.168.1.1），子网内的主机IP地址不能重复，但是子网之间的IP地址就可以重复了</mark></strong></li><li><strong><mark>每一个家用路由器，其实又作为运营商路由器的子网中的一个节点，这样的运营商路由器可能会有很多级，最外层的运营商路由器的WAN口IP就是一个公网IP了</mark></strong></li><li><strong><mark>如果希望我们自己实现的服务器程序，能够在公网上被访问到，就需要把程序部署在一台具有外网IP的服务器上，这样的服务器可以在阿里云&#x2F;腾讯云上进行购买</mark></strong></li><li><strong><mark>由于私网IP不能出现在公网当中，因此<font color=red>子网内的主机在和外网进行通信时，路由器会不断将数据包IP首部中的源IP地址替换成路由器的WAN口IP，这样逐级替换，最终数据包中的源IP地址成为一个公网IP，这种技术称为NAT（Network Address Translation，网络地址转换）</font></mark></strong></li></ul></blockquote><p><strong>让我们再来思考两个问题：</strong></p><blockquote><p><strong><font color=red>问题一：为什么私网IP不能出现在公网当中？</font></strong></p><ul><li><strong>不同的局域网中主机的IP地址可能是相同的，所以私网IP无法唯一标识一台主机，因此不能让私网IP出现在公网上，因为IP地址要能唯一标识公网上的一台主机</strong></li><li><strong>但由于IP地址不足的原因，我们不能让主机直接使用公网IP而让主机使用私网IP，因为私网IP可以重复也就意味着我们可以在不同的局域网使用相同的IP地址，缓解了IP的不足</strong></li><li><strong>此外，我们不能直接使用公网IP还有一个原因就是，因为我们的数据包必须要经过运营商的路由器，如果我们发送的数据直接到了公网，那也就意味着我们再也不用交网费了，这是不现实的</strong></li></ul><hr><p><strong><font color=red>问题二：为什么两个局域网当中的主机不能不跨公网进行通信</font></strong></p><ul><li><strong>两个局域网当中的主机理论上是不能不跨公网进行通信的，因为一个主机要将数据发送给另一台主机的前提是得先知道另一台主机的IP地址</strong></li><li><strong>即便现在这个主机知道了另一台主机的IP地址，但有可能这两台主机的IP地址是一样的，因为它们的IP地址都是私网IP地址</strong></li><li><strong>当这一台主机发送数据时将目的IP地址填成和自己相同的IP地址，操作系统就会认为这个数据就是要发给自己的，而不会向外进行发送了</strong></li><li><strong>所以数据要从一个局域网发送到另一个局域网，如果不经过公网是基本上不可能的。我们在和别人聊天的时候，也不是直接将数据从一个局域网直接发送到了另一个局域网，而是先将数据经过公网发送到了服务器，然后再由服务器将数据经过公网转发到了另一个局域网</strong></li><li><strong>但实际确实存在一些技术能够使数据包在发送过程中不进行公网IP的替换，而将数据正确送到目标主机，这种技术叫做内网穿透，也叫做NAT穿透</strong></li></ul></blockquote><hr><h2 id="对路由的了解"><a href="#对路由的了解" class="headerlink" title="对路由的了解"></a>对路由的了解</h2><p><strong><font color=red>主机A跨网络通信主机B，首先需要找到主机B所在的局域网，再在该局域网中找到主机B。路由就是找下一跳往哪跳，下一次发送给那个节点</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229174042658.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229174042658.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229174042658"><blockquote><ul><li><strong><font color=red>IP数据包的传输过程中会遇到很多路由器，这些路由器会帮助数据包进行路由转发，每当数据包遇到一个路由器后，对应路由器都会查看该数据的目的IP地址，并告知该数据下一跳应该往哪跳</font></strong></li><li><strong><font color=red>路由器的查找结果可能有以下三种：</font></strong><ul><li><strong><mark>路由器经过路由表查询后，得知该数据下一跳应该跳到哪一个子网</mark></strong></li><li><strong><mark>路由器经过路由表查询后，没有发现匹配的子网，此时路由器会将该数据转发给默认路由</mark></strong></li><li><strong><mark>路由器经过路由表查询后，得知该数据的目标网络就是当前所在的网络，此时路由器就会将该数据转给当前网络中对应的主机</mark></strong></li></ul></li><li><strong><font color=red>路由表：路由表存储着指向特定网络地址的路径</font></strong></li><li><strong><font color=red>注意：路由表不仅仅存在于路由器中，还存在于联网的计算机中</font></strong></li><li><strong><font color=red>路由表可以通过<code>route</code>命令查看</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229174219567.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-ip-xie-yi-wang-luo-ceng/image-20221229174219567.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229174219567"><ul><li><strong><font color=red>路由过程：根据IP地址和子网掩码，按位与得到目的网络号，找路由表中找是否有匹配的目的网络号。有匹配的目的网络号，通过Iface接口发送出去，去找目标主机。没有匹配到，会发送给默认网络号(default)，一般是路由器，然后该路由器循环上面操作，直到找到主机</font></strong></li></ul></blockquote><p><strong><font color=red>一点扩展：路由表生成算法</font></strong></p><blockquote><p><strong><font color=red>路由可分为静态路由和动态路由：</font></strong></p><ul><li><strong><mark>静态路由：是指由网络管理员手工配置路由信息</mark></strong></li><li><strong><mark>动态路由：是指路由器能够通过算法自动建立自己的路由表，并且能够根据实际情况进行调整</mark></strong></li></ul><p><strong><font color=red>路由表相关生成算法：距离向量算法、LS算法、Dijkstra算法等</font></strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux网络协议之IP协议-网络层&quot;&gt;&lt;a href=&quot;#Linux网络协议之IP协议-网络层&quot; class=&quot;headerlink&quot; title=&quot;Linux网络协议之IP协议(网络层)&quot;&gt;&lt;/a&gt;Linux网络协议之IP协议(网络层)&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络协议之以太网协议(数据链路层)</title>
    <link href="https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/"/>
    <id>https://not-go.github.io/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/</id>
    <published>2023-03-20T04:14:00.000Z</published>
    <updated>2023-06-23T19:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux网络协议之以太网协议-数据链路层"><a href="#Linux网络协议之以太网协议-数据链路层" class="headerlink" title="Linux网络协议之以太网协议(数据链路层)"></a>Linux网络协议之以太网协议(数据链路层)</h1><h2 id="数据链路层解决的问题"><a href="#数据链路层解决的问题" class="headerlink" title="数据链路层解决的问题"></a>数据链路层解决的问题</h2><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229184725621.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229184725621.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229184725621"><blockquote><ul><li><strong><font color=red>IP拥有将数据跨网络从一台主机送到另一台主机的能力，但IP并不能保证每次都能够将数据可靠的送到对端主机，因此IP需要上层TCP为其提供可靠性保证，比如数据丢包后TCP可以让IP重新发送数据，最终在TCP提供的可靠性机制下IP就能够保证将数据可靠的发送到对端主机</font></strong></li><li><strong><font color=red>TCP除了对下层IP提供可靠性机制之外，TCP对上还提供进程到进程的服务，我们在进行socket编程时，本质就是在使用TCP或UDP为我们提供的进程到进程的服务</font></strong></li><li><strong><font color=red>但数据在网络传输时需要一跳一跳的从一台主机跳到另一台主机，最终才能将数据转发到目标主机，因此要将数据发送到目标主机的前提是，需要先将数据转发给与当前主机直接相连的下一跳主机，而两台主机直接相连也就意味着这两台主机属于同一网段，因此将数据转发到下一跳主机实际是属于局域网通信范畴的，而这实际就是链路层需要解决的问题</font></strong></li><li><strong><font color=red>也就是说，网络层IP提供的是跨网络发送数据的能力，传输层TCP是为数据发送提供可靠性保证的，而链路层解决的则是两台相连主机之间的通信问题</font></strong></li></ul></blockquote><hr><h2 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h2><h3 id="认识以太网"><a href="#认识以太网" class="headerlink" title="认识以太网"></a>认识以太网</h3><p><strong>不同局域网所采用的通信技术可能是不同的，常见的局域网技术有以下三种：</strong></p><ul><li><strong>以太网：以太网是一种计算机局域网技术，一种应用最普遍的局域网技术</strong></li><li><strong>令牌环网：令牌环网常用于IBM系统中，在这种网络中有一种专门的帧称为“令牌”，在环路上持续地传输来确定一个节点何时可以发送包</strong></li><li><strong>无线LAN&#x2F;WAN：无线局域网是有线网络的补充和扩展，现在已经是计算机网络的一个重要组织部分</strong></li></ul><blockquote><p><strong><font color=red>以太网协议本质上就是相邻设备之间的数据转发，是局域网中通信的一种标准</font></strong></p></blockquote><hr><h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229185338661.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229185338661.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229185338661"><blockquote><ul><li><strong><font color=red>源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的</font></strong></li><li><strong><font color=red>帧协议类型字段有三种值，分别对应IP协议、ARP协议和RARP协议</font></strong></li><li><strong><font color=red>帧末尾是CRC校验码</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229185603769.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229185603769.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229185603769"></blockquote><hr><h3 id="认识MAC地址"><a href="#认识MAC地址" class="headerlink" title="认识MAC地址"></a>认识MAC地址</h3><p><strong><font color=red>MAC地址：每一个网卡设备在出厂的时候都会拥有一个全球独一无二的MAC地址，MAC地址也被称为硬件的地址</font></strong></p><blockquote><ul><li><strong><mark>MAC地址用来识别数据链路层中相连的节点</mark></strong></li><li><strong><mark>长度为48位, 及6个字节。 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)</mark></strong></li><li><strong><mark>在网卡出厂时就确定了, 不能修改。 mac地址通常是唯一的(虚拟机中的mac地址不是真实的mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址)</mark></strong></li><li><strong><mark><code>ifconfig</code> 命令可以用于显示或设置网络设备的状态</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229185820819.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229185820819.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229185820819"></blockquote><hr><h3 id="MAC地址与IP地址的区别"><a href="#MAC地址与IP地址的区别" class="headerlink" title="MAC地址与IP地址的区别"></a>MAC地址与IP地址的区别</h3><blockquote><ul><li><strong><font color=red>IP地址描述的是路途总体的 起点 和 终点</font></strong></li><li><strong><font color=red>MAC地址描述的是路途上的每一个区间的起点和终点</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229190444693.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229190444693.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229190444693"></blockquote><hr><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><p><strong><font color=red>首先强调ARP协议并不是一个单纯的链路层的协议，而是介于数据链路层和网络层之间的协议</font></strong></p><blockquote><p><strong><font color=green>上面其实我们也谈到了以太网协议格式，我们可以看到格式中的目的地址和源地址指的是目的MAC地址和源MAC地址，换句话说，数据在数据链路层进行数据发送的时候，需要知道目标主机MAC地址，但是网络层的协议递交给数据链路层的数据仅仅包含目标主机的ip地址，我们无法获知其对应的MAC地址，那么，我们该如何获取目标主机的MAC地址呢？</font></strong></p><ul><li><strong><font color=red>在网络通讯时,源主机的应用程序知道目的主机的IP地址和端口号,却不知道目的主机的硬件地址</font></strong></li><li><strong><font color=red>数据包首先是被网卡接收到再去处理上层协议的,如果接收到的数据包的硬件地址与本机不符,则直接丢弃</font></strong></li><li><strong><font color=red>因此在通讯前必须获得目的主机的硬件地址</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229191911537.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229191911537.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229191911537"></blockquote><p><strong><mark>ARP协议</mark>就是用来解决此类问题的，他可以<mark>通过ip地址获取对应的MAC地址</mark></strong></p><p><strong>注意：这里的ip地址本质上是通过路由项计算出来的接下来该条数据该去往的ip地址，而不是自己本身该去的ip地址</strong></p><p><strong>因此，可以说ARP协议是介于网络层和数据链路层之间的协议，话句话来说就是ARP协议建立了主机 IP地址 和 MAC地址 的映射关系</strong></p><hr><h3 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229192434515.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229192434515.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229192434515"><blockquote><ul><li><strong><font color=red>以太网首部和上面相同。但是ARP协议，类型设为0806</font></strong></li><li><strong><font color=red>硬件类型：指链路层网络类型，1为以太网</font></strong></li><li><strong><font color=red>协议类型：指要转换的地址类型，0800为IP地址，意思是通过IP地址找MAC地址</font></strong></li><li><strong><font color=red>硬件地址长度：对于以太网地址为6字节</font></strong></li><li><strong><font color=red>协议地址长度：对于IP地址为4字节</font></strong></li><li><strong><font color=red>op字段：为1表示ARP请求，为2表示ARP应答</font></strong></li></ul></blockquote><hr><h3 id="ARP协议工作流程"><a href="#ARP协议工作流程" class="headerlink" title="ARP协议工作流程"></a>ARP协议工作流程</h3><blockquote><ul><li><strong><font color=red>ARP协议先广播数据到居于网中，目的MAC地址为全1</font></strong></li><li><strong><font color=red>每台主机收到数据后，解开以太网报头和IP报头，拿到目的IP地址</font></strong></li><li><strong><font color=red>拿目的IP地址和字节主机的IP地址向比较，匹配就返回ARP响应</font></strong></li><li><strong><font color=red>发送端收到响应就获得了对方的MAC地址</font></strong></li></ul></blockquote><p><strong><mark>如果局域网中的主机没有目标主机，怎么知道对方的IP地址呢？(ARP字段要填写)</mark></strong></p><ul><li><strong>我们知道最终要接收数据主机的IP地址(应用层会数据URL中)。在IP成先查路由表，发现不在当前局域网中，会发送给路由表中默认的网段，也就是路由器。主机知道路由器的IP地址，一般是当前局域网的网络号，主机号为1。会在ARP协议的目标IP地址填入路由器的IP地址。路由器收到后会ARP响应</strong></li><li><strong>如果查看路由表，最终要接收数据主机的IP地址在当前局域网中，会在ARP目的IP地址填入最终要接收数据主机的IP地址。最终要接收的主机收到会响应ARP</strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229192929055.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229192929055.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229192929055"><ul><li><strong>局域网中的主机收到ARP请求，向判断op字段是否是请求，因为当前主机可能还收到了别的主机的响应。再解开报头，获得目的IP地址，是否与自己的IP地址匹配，匹配响应，不匹配丢弃。(广播的，局域网中的主机都会解开报头，匹配目的IP地址)</strong></li><li><strong>局域网中发送请求的主机收到ARP响应，向判断op字段是否是响应，因为当前主机可能还收到了别的主机的请求。再解开报头，MAC地址与自己的匹配，不匹配的丢弃。发送请求的主机就获得了对方的MAC地址。(不是广播的，请求知道了发送主机的MAC地址)</strong></li></ul><hr><h3 id="ARP缓存表"><a href="#ARP缓存表" class="headerlink" title="ARP缓存表"></a>ARP缓存表</h3><blockquote><p><strong><font color=red>使用<code>arp -a 查看arp缓存表：</code></font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229193427974.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229193427974.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229193427974"><p><img src="/image-20221229193447003.png" class="lazyload placeholder" data-srcset="/image-20221229193447003.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20221229193447003"></p></blockquote><p><strong><mark>如果每发送一个IP数据报都要进行一次ARP请求以此确定MAC地址，那将会造成不必要的网络流量，因此，通常的做法是把获取到的MAC地址缓存（是指预见到同样的信息可能会再次使用，从而在内存中开辟一块区域记忆这些信息） 一段时间。<font color=red>即把第一次通过ARP获取到的MAC地址作为IP对MAC的映射关系记忆（记录IP地址与MAC地址对应关系的数据库叫做ARP表） 到一个ARP缓存表中，下一次再向这个IP地址发送数据报时不需再重新发送ARP请求，而是直接使用这个缓存表当中的MAC地址进行数据报的发送</font>。每执行一次ARP，其对应的缓存内容都会被清除。不过在清除之前都可以不需要执行ARP就可以获取想要的MAC地址。这样，在一定程度上也防止了ARP包在网络上被大量广播的可能性</mark></strong></p><blockquote><ul><li><strong><mark>当然ARP是有老化时间的，老化时间为20min，会进行相应的更新</mark></strong></li><li><strong><mark>ARP协议只能在子网内部使用，只能给子网内部的机器进行广播ARP请求。换句话说，只能获取子网内部机器的MAC地址</mark></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229193834224.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229193834224.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229193834224"></blockquote><p><strong><font color=red>那么问题来了，IP地址和MAC地址缺一不可吗？</font></strong></p><blockquote><p><strong>① 数据链路上只要知道接收端的MAC地址不就知道数据是准备发送给主机B的吗，那还需要知道它的IP地址吗？</strong><br><strong>② 只要知道了IP地址，即使不做ARP，只要在数据链路上做一个广播不就能发给主机B了吗？”那么，为什么既需要IP地址又需要MAC地址呢?</strong></p></blockquote><p><strong><mark>主机A想要发送IP数据报给主机B时必须得经过路由器C。即使知道了主机B的MAC地址，由于路由器C会隔断两个网络，还是无法实现直接从主机A发送数据报给主机B。此时，主机A必须得先将数据报发送给路由器C的MAC地址C1</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229194013010.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229194013010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229194013010"><p><strong><mark>如此看来，IP地址和MAC地址两者缺一不可。于是就有将这两个地址相关联的ARP协议（为了避免这两个阶段的通信带来过多的网络流量，ARP具有对IP地址和MAC地址的映射进行缓存的功能。有了这个缓存功能，发送IP包时就不必每次都发送ARP请求，从而防止性能下降）</mark></strong></p><hr><h2 id="认识MTU-最大传输单元"><a href="#认识MTU-最大传输单元" class="headerlink" title="认识MTU(最大传输单元)"></a>认识MTU(最大传输单元)</h2><blockquote><ul><li><strong><font color=red>MTU(Maximum Transmission Unit)：中文意思是最大传输单位</font></strong></li><li><strong><font color=red>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP数据报小于46字节时，要在后面补充位数</font></strong></li><li><strong><font color=red>最大值1500字节称为以太网的最大传输单元(MTU)，不同网络类型有不同的MTU</font></strong></li><li><strong><font color=red>如果一个数据包的长度超过了MTU，则需要对数据进行分片，分片是网络层IP做的</font></strong></li><li><strong><font color=red>不同的数据链路层标准的MTU是不同的，在数据传输过程中，数据可能会被路由器继续分片</font></strong></li></ul></blockquote><hr><h3 id="MTU对IP协议的影响"><a href="#MTU对IP协议的影响" class="headerlink" title="MTU对IP协议的影响"></a>MTU对IP协议的影响</h3><p><strong><mark>发送时，网络层IP协议的数据需要发送到链路层，由于MTU的影响，对于超过MTU的数据，IP要对其进行分片处理</mark></strong></p><blockquote><ul><li><strong>同一组数据的每一个分片IP协议的16位标识id是相同的</strong></li><li><strong>每一个分片IP协议报头的3位标志段，第二位为0，表示允许分片，第三位为1，表示后面还有分片，第三位为0，表示后面没有分片</strong></li><li><strong>每一个分片IP协议报头的13为偏移量，表示的是当前分片距离起始位置的偏移量，用于接收端组装的</strong></li><li><strong>一旦一些分片丢失，数据重组失败，但是IP层不负责重传数据</strong></li><li><strong>负责数据重传的是传输层，准确来说是TCP协议，UDP协议不可靠</strong></li></ul></blockquote><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229191301635.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229191301635.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229191301635"><hr><h3 id="MTU对UDP协议的影响"><a href="#MTU对UDP协议的影响" class="headerlink" title="MTU对UDP协议的影响"></a>MTU对UDP协议的影响</h3><p> <strong><font color=red>UDP协议的特点是：无连接，不可靠和面向数据报的</font></strong></p><blockquote><ul><li><strong>当一个UDP携带的数据超过1472(1500 - 8(UDP报头) - 20(IP报头))时，在IP层就一定会进行分片</strong></li><li><strong>分片之后，一个数据被分成了多份，说明，数据丢包的概率增加了</strong></li><li><strong>并且，UDP没有可靠性保证，数据不会重传</strong></li></ul></blockquote><hr><h3 id="MTU对TCP协议的影响"><a href="#MTU对TCP协议的影响" class="headerlink" title="MTU对TCP协议的影响"></a>MTU对TCP协议的影响</h3><blockquote><ul><li><strong>TCP协议的一个数据报也不能是无限大的，不仅受之于流量控制，拥塞控制的影响，还受MTU的影响。TCP的有效载荷的最大消息长度，称为MSS</strong></li><li><strong>TCP在建立连接，三次握手时，通信双方会进行MSS协商</strong></li><li><strong>双方SYN时会在TCP报头写入自己能支持的MSS值</strong></li><li><strong>双方知道知道对方的MSS后，选择最小值作为最终MSS</strong></li><li><strong>MSS值在TCP报头填入位置在选项</strong></li></ul></blockquote><p><strong><font color=red>虽然TCP会协商MSS，但是，仍然可能会被分片。接收端就收在组装时，如果发现一个分片丢失，接收端TCP收不到数据，就认为整个数据丢失，会让发送方，重发整个数据</font></strong></p><p><strong><mark>MSS和MTU的关系：</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229191606320.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221229191606320.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221229191606320"><hr><h2 id="DNS协议-域名系统协议"><a href="#DNS协议-域名系统协议" class="headerlink" title="DNS协议(域名系统协议)"></a>DNS协议(域名系统协议)</h2><h3 id="DNS背景"><a href="#DNS背景" class="headerlink" title="DNS背景"></a>DNS背景</h3><p><strong><font color=red>DNS（Domain Name System，域名系统）协议，是一个用来将域名转化为IP地址的应用层协议</font></strong></p><p><strong>TCP&#x2F;IP中通过IP地址和端口号的方式，来确定网络中一个主机上的一个程序。但IP地址是一长串数字，并不便于人们记忆，于是人们发明了一种叫做主机名的东西，并用hosts文件夹来描述主机名和IP地址之间的对应关系</strong></p><p><strong>最初，这个hosts文件是由互联网信息中心（SRI-NIC）来管理的</strong></p><ul><li><strong>如果一个新计算机要接入网络，或者某个计算机IP变更，都需要到信息中心申请变更hosts文件</strong></li><li><strong>其他计算机也需要定期下载更新新版本的hosts文件才能正确上网</strong></li><li><strong>当用户通过域名访问互联网服务时，会先通过域名在本地的hosts文件中找到其对应的IP地址，然后再用这个IP地址去访问对应的服务</strong></li></ul><p><strong><font color=red>但这样太麻烦了，于是产生了DNS系统：</font></strong></p><ul><li><strong>由一个组织的系统管理机构，维护系统内的每个主机的IP和主机名的对应关系</strong></li><li><strong>如果新计算机要接入网络，或者某个计算机IP变更，就需要将对应信息注册到数据库中</strong></li><li><strong><mark>当用户通过域名访问互联网服务时，会自动查询DNS服务器，由DNS服务器检索数据库，得到对应的IP地址</mark></strong></li></ul><p><strong><mark>至今，我们的计算机上仍然保留了hosts文件，这个hosts文件当中一般存储的是主机名与IP地址之间的映射，用户也可以在hosts文件中自主添加域名和IP映射关系，在域名解析的过程中会优先查找hosts文件的内容</mark></strong></p><p><strong><font color=red>通过<code>cat /etc/hosts</code>可以查看hosts文件当中的内容</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230110039739.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230110039739.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230110039739"><hr><h3 id="域名简介"><a href="#域名简介" class="headerlink" title="域名简介"></a>域名简介</h3><p><strong><font color=red>DNS域名解析技术属于应用层技术，底层用的是UDP协议</font></strong></p><p><strong><font color=red>域名是用来识别主机名称和主机所属的组织机构的一种分层结构的名称，例如<code>www.baidu.com</code></font></strong></p><blockquote><p><strong><mark>域名(倒着数级别)：</mark></strong></p><ul><li><strong><font color=red>一级域名：.com、.cn、.gov、.us</font></strong></li><li><strong><font color=red>二级域名：baidu.com、jd.com、taobao.com</font></strong></li><li><strong><font color=red>三级域名：baike.baidu.com</font></strong></li></ul><hr><p><strong><mark>域名服务器：</mark></strong></p><ul><li><strong><font color=red>根域名服务器：给其他域名服务器做授权使用</font></strong></li><li><strong><font color=red>一级域名服务器：管理一级域名</font></strong></li><li><strong><font color=red>二级域名服务器：管理二级域名</font></strong></li><li><strong><font color=red>三级域名服务器：管理三级域名</font></strong></li></ul></blockquote><hr><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><strong><mark>至今, 我们的计算机上仍然保留了hosts文件，在域名解析的过程中仍然会优先查找hosts文件的内容</mark></strong></p><p><strong><mark>在浏览器中输入<code>url</code>后，如果<code>url</code>当中包含域名，则需要进行域名解析</mark></strong></p><p><strong><font color=red>域名解析流程：</font></strong></p><blockquote><p><strong><font color=red>递归域名解析过程：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230112108959.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230112108959.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230112108959"><p><strong><font color=red>或者：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230112310785.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230112310785.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="**image-20221230112310785**"></blockquote><hr><h3 id="dig工具分析DNS过程"><a href="#dig工具分析DNS过程" class="headerlink" title="dig工具分析DNS过程"></a>dig工具分析DNS过程</h3><p><strong><font color=red>我们可以使用dig工具来查看域名解析的过程，例如查看百度域名<code>www.baidu.com</code>的解析过程</font></strong></p><p><strong><mark>dig工具的分析结果如下：</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230112834456.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230112834456.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230112834456"><p><strong><font color=red>结果解释：</font></strong></p><ul><li><strong><mark>开头位置是dig工具的版本号</mark></strong></li><li><strong><mark>第二部分是服务器返回的详情，其中status参数为NOERROR表示查询成功</mark></strong></li><li><strong><mark>QUESTION SECTION表示待查询的域名</mark></strong></li><li><strong><mark>ANSWER SECTION表示查询的结果，首先<a href="http://www.baidu.com被查询成了www.a.shifen.com,而最终www.a.shifen.com被查询成了两个具体的ip地址/">www.baidu.com被查询成了www.a.shifen.com，而最终www.a.shifen.com被查询成了两个具体的IP地址</a></mark></strong></li><li><strong><mark>最下面是一些结果统计，包含查询时间和DNS服务器的地址等</mark></strong></li></ul><hr><h2 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h2><p><strong><font color=red>NAT（Network Address Translation，网络地址转换）技术，是解决IP地址不足的主要手段，并且能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230113047549.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230113047549.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230113047549"><hr><h3 id="NAT技术背景"><a href="#NAT技术背景" class="headerlink" title="NAT技术背景"></a>NAT技术背景</h3><p><strong>在IPv4协议中，IP地址数量不足是一个大问题，而NAT技术就是当前解决IP地址不够用的主要手段，是路由器的一个重要功能</strong></p><ul><li><strong>在进行对外通信时，NAT能够将私有IP经过一系列替换操作最终转为全局IP，也就是说，NAT是一种将私有IP和全局IP相互转化的技术方法</strong></li><li><strong>装有NAT软件的路由器叫做NAT路由器，所有使用私有IP的主机在和外界通信时，都要在NAT路由器上将其私有IP转换成全局IP</strong></li><li><strong>很多学校、家庭、公司内部每个终端设置的IP都是私有IP，而只在路由器或必要的服务器上设置全局IP</strong></li><li><strong>全局IP要求唯一，但是私有IP不需要，在不同的局域网中出现相同的私有IP是完全不影响的</strong></li></ul><hr><h3 id="NAT-IP转换过程"><a href="#NAT-IP转换过程" class="headerlink" title="NAT IP转换过程"></a>NAT IP转换过程</h3><p><strong><mark>假设某个局域网当中有A、B、C三台主机，在公网当中有一台服务器，以主机A访问公网中的这台服务器为例，我们来看看数据包在传输过程中IP地址的转换过程</mark></strong></p><blockquote><p><strong><font color=green>数据包从局域网到公网的过程：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230113856977.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230113856977.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230113856977"><p><strong><font color=red>主机A向服务器发起数据请求的过程中，数据包中IP地址的转换过程如下：</font></strong></p><ul><li><strong><font color=red>刚开始，该数据包当中的源IP地址就是主机A的私有IP地址，目的IP地址就是服务器的公网IP地址</font></strong></li><li><strong><font color=red>当数据包经过NAT路由器时，路由器会将该数据包的源IP地址替换成自己的WAN口IP地址，此时该数据包的源和目的IP地址就都是公网IP了</font></strong></li><li><strong><font color=red>该数据包在互联网中经过各种路由转发，最终到达服务器主机</font></strong></li></ul><p><strong><font color=red>服务器收到主机A的数据请求并处理后，就会对主机A发来的请求进行响应</font></strong></p><hr><p><strong><font color=green>数据包从公网到局域网的过程：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230114141133.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230114141133.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230114141133"><p><strong><font color=red>服务器向主机A进行响应的过程中，数据包中IP地址的转换过程如下：</font></strong></p><ul><li><strong><font color=red>刚开始，该数据包当中的源IP地址就是服务器的公网IP地址，目的IP地址就是路由器的WAN口IP地址</font></strong></li><li><strong><font color=red>数据包在互联网中经过各种路由转发，到达主机A所在局域网的NAT路由器，此时路由器会将该数据包的目的IP地址替换成主机A的私有IP地址</font></strong></li><li><strong><font color=red>最终路由器就会将该数据包转发给局域网中的主机A</font></strong></li></ul><p><strong><font color=red>需要注意的是，因为主机A向服务器发起数据请求时，该数据包当中的源IP地址被替换成了NAT路由器的WAN口IP地址，相当于是该路由器代替主机A向服务器发起了数据请求，因此服务器发出的响应数据包的目的IP地址应该是NAT路由器的WAN口IP地址</font></strong></p></blockquote><hr><h3 id="NAT的作用"><a href="#NAT的作用" class="headerlink" title="NAT的作用"></a>NAT的作用</h3><blockquote><ul><li><strong><font color=red>私网对公网请求的时候：将网络数据当中的私网的源ip地址转化成为公网的ip地址</font></strong></li><li><strong><font color=red>公网对私网的应答：将网络数据当中的公网的目的ip地址转化成为私网的ip地址</font></strong></li></ul><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230114744461.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230114744461.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230114744461"><ul><li><strong><mark>静态NAT：NAT协议，将一个私网和一个公网唯一进行映射管理</mark></strong></li><li><strong><mark>动态NAT：NAT管理的不止是一个公网ip，当私网数据到来的时候，选择一个空闲的ip进行映射</mark></strong></li><li><strong><font color=red>如上图，以10.0.0.10的源主机与163.221.120.9的目的主机进行通信为例。利用NAT，途中的NAT路由器将发送源地址从10.0.0.10转换为全局的IP地址（202.244.174.37）再发送数据。反之，当包从地址163.221.120.9发过来时，目标地址（202.244.174.37）先被转换成私有IP地址10.0.0.10以后再被转发（在TCP或UDP中，由于IP首部中的IP地址还要用于校验和的计算，因此当IP地址发生变化时，也需要相应地将TCP、UDP的首部进行转换）</font></strong></li><li><strong><mark>总结一下就是：不管是静态NAT还是动态NAT，都没有缓解ipv4枯竭的问题，本质上还是一个私网IP一定要对应一个公网ip，才能访问互联网，这也是后面出现ipv6的原因之一</mark></strong></li></ul></blockquote><hr><h2 id="NAPT协议-动态NAT重载"><a href="#NAPT协议-动态NAT重载" class="headerlink" title="NAPT协议(动态NAT重载)"></a>NAPT协议(动态NAT重载)</h2><h3 id="NAPT-IP转换过程"><a href="#NAPT-IP转换过程" class="headerlink" title="NAPT IP转换过程"></a>NAPT IP转换过程</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230115130863.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230115130863.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230115130863"><p><strong><mark>在进行私网ip转化为公网ip的时候，不仅仅将ip地址转换掉了，并且还将传输层的端口也转换掉了</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230115914385.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230115914385.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230115914385"><p><strong><mark>主机163.221.120.9的端口号是80，LAN中有两个客户端10.0.0.10和10.0.0.11同时进行通信，并且这两个客户端的本地端口都是1025。此时，仅仅转换IP地址为某个全局地址202.244.174.37，会令转换后的所有数字完全一致。为此，只要将10.0.0.11的端口号转换为1026就可以解决问题。如图所示，生成一个NAPT路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端A、B能同时与服务器之间进行通信</mark></strong></p><p><strong><mark>这种转换表在NAT路由器上自动生成。例如，在TCP的情况下，建立TCP连接首次握手时的SYN包一经发出，就会生成这个表。而后又随着收到关闭连接时发出FIN包的确认应答从表中被删除（UDP中两端应用进行通信时起止时间不一定保持一致，因此在这种情况下生成转换表相对较难）</mark></strong></p><p><strong><mark>注：在使用TCP或UDP的通信当中，只有目标地址、源地址、目标端口、源端口以及协议类型（TCP还是UDP）五项内容都一致时才被认为是同一个通信连接。此时所使用的正是NAPT</mark></strong></p><hr><h3 id="NAT技术的缺陷"><a href="#NAT技术的缺陷" class="headerlink" title="NAT技术的缺陷"></a>NAT技术的缺陷</h3><p><strong><font color=red>NAT技术进行私有IP和公网之间的替换，主要就是依赖NAT路由器当中维护的网络地址转换表，但这张转换表也体现出了NAT的一些缺陷：</font></strong></p><ul><li><strong><mark>无法从NAT外部向内部服务器建立连接，因为外部无法知道内部的私网IP，也就无法主动与内部服务器建立连接</mark></strong></li><li><strong><mark>转换表的生成和销毁都需要额外开销</mark></strong></li><li><strong><mark>通信过程中一旦NAT设备异常，即使存在热备，所有的TCP连接也都会断开</mark></strong></li></ul><hr><h3 id="NAT和代理服务器"><a href="#NAT和代理服务器" class="headerlink" title="NAT和代理服务器"></a>NAT和代理服务器</h3><p><strong><font color=red>代理服务器（Proxy Server）的功能就是代理网络用户去取得网络信息，代理服务器又分为正向代理和反向代理</font></strong></p><blockquote><p><strong><mark>正向代理：</mark></strong></p><p><strong><font color=green>正向代理，是一个位于客户端和目标服务器之间的服务器，客户端并不直接访问目标服务器，而是先访问代理服务器，由代理服务器代替客户端去访问对应的目标服务器，并将目标服务器的响应结果返回给客户端</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230121058502.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230121058502.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230121058502"><p><strong>比如公司内部一般都会有自己的服务器，当我们使用公司内网上网时：</strong></p><ul><li><strong>我们对外网发起的数据请求，首先会转发到公司的这台服务器上，然后由公司的这台服务器代替你对外网进行访问</strong></li><li><strong>当公司的服务器收到对应外网的响应数据后，再由公司的这台服务器将数据转发给你</strong></li></ul><p><strong><font color=red>正向代理的好处：</font></strong></p><ul><li><strong><font color=red>正向代理最大的一个好处就是可以加速资源访问</font></strong></li><li><strong><font color=red>比如公司中大量员工都要访问外网的同一个资源，那么正向代理服务器就可以将对应的资源缓存到本地，此时当其他人要访问该资源时，直接在正向代理服务器就可以获取，而不需要再次进行外网访问</font></strong></li></ul><hr><p><strong><mark>反向代理：</mark></strong></p><p><strong><font color=green>反向代理，也是一个位于客户端和目标服务器之间的服务器，对于客户端而言，反向代理服务器就相当于目标服务器，用户不需要知道目标服务器的地址，用户只需要访问反向代理服务器就可以获得目标服务器提供的服务</font></strong></p><p><strong><font color=green>反向代理，也是一个位于客户端和目标服务器之间的服务器，客户端直接向反向代理服务器发起数据请求，然后再由反向代理服务器将客户端的数据请求转发给真正的目标服务器进行处理，数据处理完毕后反向代理服务器再将数据结果返回给客户端</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230121328904.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230121328904.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230121328904"><p><strong>比如域名<code>www.baidu.com</code>对应的服务器实际就是一个反向代理服务器</strong></p><ul><li><strong>百度内部实际并不是只有一台服务器，但不同地区的人们都可以通过访问<a href="http://www.baidu.com享受到百度提供的服务,实际我们访问的就是百度的反向代理服务器/">www.baidu.com享受到百度提供的服务，实际我们访问的就是百度的反向代理服务器</a></strong></li><li><strong>当这台反向代理服务器收到客户端的数据请求后，就会将我们的数据请求转发给百度内部的某台服务器进行数据处理，然后再将数据处理的结果返回给客户端</strong></li></ul><p><strong><font color=red>反向代理的好处：</font></strong></p><ul><li><strong><font color=red>反向代理可以起到负载均衡的作用。比如不设置反向代理服务器，那么用户在访问百度时，就会随机访问到百度内部的某台服务器，此时就可能导致某些服务器压力太大，而某些服务器却处于闲置状态。而设置了反向代理服务器后，我们就能够通过某些方法让用户的数据请求较为平均的落到每台服务器上</font></strong></li><li><strong><font color=red>反向代理还能起到安全防护的作用。有了方向代理服务器后，我们不需要直接将提供服务的服务器对应的信息暴露出去，此外，当由非法请求发送到反向代理服务器时，反向代理服务器就相当于一层软件屏障，可以在反向代理服务器当中部署一些防护措施，让这些非法请求在反向代理服务器这里就被过滤掉，而不会影响内部实际提供服务的服务器</font></strong></li></ul><p><strong><font color=red>需要注意的是，代理服务器的主要工作只是对数据进行转发，因此代理服务器处理数据的压力不会特别大，并且代理服务器也可以有多个，因此不必担心代理服务器过载的情况</font></strong></p><hr><p><strong><font color=red>正向代理和反向代理的异同：</font></strong></p><p><strong><mark>正向代理和反向代理的相同点</mark></strong></p><ul><li><strong>正向代理服务器和反向代理服务器都是位于客户端和服务器之间的</strong></li><li><strong>正向代理服务器和反向代理服务器的主要工作，都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端</strong></li></ul><p><strong><mark>正向代理和反向代理的不同点</mark></strong></p><ul><li><strong>正向代理是客户端的代理，帮助客户端访问其无法访问的服务器资源的，而反向代理则是服务器的代理，帮助服务器做负载均衡、安全防护等工作的</strong></li><li><strong>正向代理一般是客户端架设的，比如公司的正向代理服务器是公司作为客户端架设的，而反向代理一般是服务端架设的，比如百度的反向代理服务器是百度作为服务端架设的</strong></li><li><strong>正向代理中，服务器不知道真正的客户端到底是谁，服务器认为正向代理服务器就是真实的客户端，而反向代理中，客户端不知道真正的服务器是谁，客户端认为反向代理服务器就是真实的服务器</strong></li></ul><hr><p><strong><font color=red>NAT和代理服务器的区别：</font></strong></p><p><strong>NAT和代理服务器都是代替我们向服务器发起数据请求的，但它们有如下区别：</strong></p><ul><li><strong>从应用上讲，NAT设备是网络基础设备之一，解决的是IP不足的问题，而代理服务器则是更贴近具体应用，比如通过代理服务器进行翻墙，另外像迅游这样的加速器，也是使用的代理服务器</strong></li><li><strong>从底层实现上讲，NAT工作在网络层，直接对IP地址进行替换，而代理服务器往往工作在应用层</strong></li><li><strong>从使用范围上讲，NAT一般在局域网的出口部署，而代理服务器可以在局域网代理，也可以在广域网代理，也可以跨网代理</strong></li><li><strong>从部署位置上看，NAT一般集成在防火墙、路由器等硬件设备上，而代理服务器则是一个软件程序（比如Nginx和Apache），需要部署在服务器上</strong></li></ul></blockquote><hr><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><h3 id="ICMP功能"><a href="#ICMP功能" class="headerlink" title="ICMP功能"></a>ICMP功能</h3><blockquote><p><strong><font color=red>ICMP的主要功能包括：</font></strong></p><ul><li><strong><mark>确认IP包是否成功到达目标地址</mark></strong></li><li><strong><mark>通知在发送过程中IP包丢弃的原因</mark></strong></li><li><strong><mark>ICMP只能搭配IPv4使用，如果是IPv6的情况下，需要使用ICMPv6</mark></strong></li></ul></blockquote><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122136789.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122136789.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230122136789"><p><strong><font color=green>当发送的数据包到达主机B所在局域网的入口路由器时，入口路由器为了获得主机B的MAC地址，于是会向主机B发送ARP请求包，但由于主机B已经离线了，因此路由器在多次发送ARP请求包而得不到响应后，就会返回一个ICMP Destination Unreachable的包给主机A，此时主机A就知道自己发送的数据无法到达主机B</font></strong></p><hr><h3 id="ICMP协议格式"><a href="#ICMP协议格式" class="headerlink" title="ICMP协议格式"></a>ICMP协议格式</h3><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122247904.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122247904.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230122247904"><blockquote><p><strong><code>ICMP大概分为两类报文：</code></strong></p><ul><li><strong><mark>一类是通知出错原因的</mark></strong></li><li><strong><mark>一类是用于诊断查询的</mark></strong></li></ul></blockquote><p><strong><font color=red>ICMP包常见类型如下：</font></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122336404.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122336404.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230122336404"><hr><h3 id="ping命令与ICMP"><a href="#ping命令与ICMP" class="headerlink" title="ping命令与ICMP"></a>ping命令与ICMP</h3><p><strong><font color=red>ping命令是基于ICMP协议实现的，通常用于测试本地主机与另一台主机之间的通信信道是否正常</font></strong></p><p><strong>例如，使用<code>ping www.baidu.com</code>命令，测试本地主机与百度服务器之间的通信信道是否正常</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122738209.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122738209.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230122738209"><blockquote><ul><li><strong><mark>注意，此处ping的是百度的域名，该域名会由DNS解析成IP地址</mark></strong></li><li><strong><mark>ping命令不仅能验证网络的连通性，同时也会统计响应时间和TTL（IP包中的Time To Live，生存时间）</mark></strong></li><li><strong><mark>ping命令会先发送一个ICMP Echo Request给对端</mark></strong></li><li><strong><mark>对端接收到之后，会返回一个ICMP Echo Reply</mark></strong></li></ul></blockquote><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122830516.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230122830516.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230122830516"><hr><h3 id="traceroute命令与ICMP"><a href="#traceroute命令与ICMP" class="headerlink" title="traceroute命令与ICMP"></a>traceroute命令与ICMP</h3><p><strong><font color=red>traceroute命令也是基于ICMP协议实现的，traceroute命令可以遍历数据包传送到目标主机所经过的所有路由器</font></strong></p><p><strong>例如，使用<code>traceroute www.baidu.com</code>命令，遍历数据包传送到百度服务器所经过的所有路由器</strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230123019891.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230123019891.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230123019891"><p><strong><font color=red>原理简述：</font></strong></p><blockquote><ul><li><strong><mark>traceroute命令底层实际是通过增加存活时间（TTL）值来实现的</mark></strong></li><li><strong><mark>因为每当数据包经过一个路由器，其TTL值就会减1，当TTL值减为0时对应路由设备就会将该数据包丢弃，并传送一个ICMP TTL数据包给发送主机</mark></strong></li><li><strong><mark>因此traceroute命令底层可以发出多个数据包，并给这些数据包设置不同的TTL值，最后该主机就能够得到一连串的数据包路径</mark></strong></li></ul></blockquote><hr><h3 id="扩展：ping命令与面试官的圈套"><a href="#扩展：ping命令与面试官的圈套" class="headerlink" title="扩展：ping命令与面试官的圈套"></a>扩展：ping命令与面试官的圈套</h3><blockquote><p><strong><font color=red>问题：telnet对应的端口号是23，ssh对应的端口号是22，那ping对应的端口号是多少？</font></strong></p></blockquote><p><strong><mark>这是面试官设的一个圈套，ping命令是基于网络层的ICMP协议，而端口号是属于传输层的内容，因此ICMP协议根本就不关心端口号这样的信息</mark></strong></p><img src="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230123330603.png" class="lazyload placeholder" data-srcset="/2023/03/20/1.linux-wang-luo-xie-yi-zhi-yi-tai-wang-xie-yi-shu-ju-lian-lu-ceng/image-20221230123330603.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221230123330603"><p><strong><font color=red>因此，ping命令实际是绕过了传输层的，在Linux当中实际也有绕过传输层的一套网络编程接口，叫做原生套接字</font></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux网络协议之以太网协议-数据链路层&quot;&gt;&lt;a href=&quot;#Linux网络协议之以太网协议-数据链路层&quot; class=&quot;headerlink&quot; title=&quot;Linux网络协议之以太网协议(数据链路层)&quot;&gt;&lt;/a&gt;Linux网络协议之以太网协议(数据链路层)</summary>
      
    
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux网络编程" scheme="https://not-go.github.io/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>GUI版扫雷游戏</title>
    <link href="https://not-go.github.io/2023/03/12/1.sao-lei-xiang-mu/"/>
    <id>https://not-go.github.io/2023/03/12/1.sao-lei-xiang-mu/</id>
    <published>2023-03-12T04:00:00.000Z</published>
    <updated>2023-07-04T09:30:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUI版扫雷游戏项目"><a href="#GUI版扫雷游戏项目" class="headerlink" title="GUI版扫雷游戏项目"></a>GUI版扫雷游戏项目</h1><h2 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h2><p><strong><font color=red>本程序为本人原创，没有参考任何其他资料或博客，图片素材基于原版扫雷图片</font></strong></p><blockquote><p><strong><font color=green>制作带GUI的扫雷游戏项目主要是为了练习自己的C语言基础。写这篇博客一是为了记录自己曾经练习写代码的过程和思路，害怕后面忘记了，二是分享给更多感兴趣的朋友。我将项目捏碎了给大家讲解了出来，相信只要具有一定的耐心，都能随便写出来！</font></strong></p></blockquote><p><font color=blue><strong>源码里的游戏本体有很多步骤可以放入函数进行执行的，这样代码看起来更加简洁。由于我写这个游戏的时候在高铁上，有些不方便，所以我并没有进行功能合并，有兴趣的朋友，自己new个函数将功能合并吧</strong></font></p><hr><h2 id="扫雷游戏项目效果展示"><a href="#扫雷游戏项目效果展示" class="headerlink" title="扫雷游戏项目效果展示"></a>扫雷游戏项目效果展示</h2><img src="/2023/03/12/1.sao-lei-xiang-mu/20221010110319002.gif" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/20221010110319002.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20221010110319002"><hr><h2 id="扫雷游戏项目基本信息"><a href="#扫雷游戏项目基本信息" class="headerlink" title="扫雷游戏项目基本信息"></a>扫雷游戏项目基本信息</h2><p><strong><code>项目名称：扫雷</code></strong></p><p><strong><code>开发语言：C语言</code></strong></p><p><strong><code>开发作者：牟建波</code></strong></p><p><strong><code>开发环境：Visual Studio2019、EasyX图形库、Windows</code></strong></p><p><strong><code>开发时间：2023-03-12</code></strong></p><hr><h2 id="扫雷游戏项目设计思路"><a href="#扫雷游戏项目设计思路" class="headerlink" title="扫雷游戏项目设计思路"></a>扫雷游戏项目设计思路</h2><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312080110355-1688462726255-4.png" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312080110355-1688462726255-4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312080110355"><hr><h2 id="扫雷游戏实现原理"><a href="#扫雷游戏实现原理" class="headerlink" title="扫雷游戏实现原理"></a>扫雷游戏实现原理</h2><h3 id="头文件解析"><a href="#头文件解析" class="headerlink" title="头文件解析"></a>头文件解析</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span> <span class="token comment">//SetConsoleTextAttribute()函数头文件</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;graphics.h></span> <span class="token comment">//easyx图形库</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span> <span class="token comment">//srand()函数头文件</span></span> 头文件使用解释：    <span class="token number">1.</span>使用#include<span class="token operator">&lt;</span>windows<span class="token punctuation">.</span>h<span class="token operator">></span>头文件，是为了使用其中的<span class="token function">SetConsoleTextAttribute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>进行字体颜色修改，方便后期给雷标记颜色区分 <span class="token number">2.</span>使用#include<span class="token operator">&lt;</span>graphics<span class="token punctuation">.</span>h<span class="token operator">></span>头文件，是为了使用eaxys函数库，进行鼠标交互和图形绘制     <span class="token number">3.</span>使用#include<span class="token operator">&lt;</span>time<span class="token punctuation">.</span>h<span class="token operator">></span>头文件，是为了使用<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数，通过时间播种生成随机数去对应雷 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="素材解析"><a href="#素材解析" class="headerlink" title="素材解析"></a>素材解析</h3><blockquote><ul><li><p><font color=red><strong>扫雷项目中的素材，全部来自官方原版游戏截图和自己画的，我把素材全放在pic文件夹下了，如下图2中各种表情、方块、数字、地雷</strong></font></p></li><li><p><font color=red><strong>在项目中，我们会使用easyx图形库对图像进行提取使用，所以尽量将素材和游戏放在同一目录下，避免一些奇怪的错误</strong></font></p></li></ul></blockquote><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312221322361.png" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312221322361.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312221322361"><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312221340904.png" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312221340904.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312221340904"><hr><h3 id="变量与矩形布局解析"><a href="#变量与矩形布局解析" class="headerlink" title="变量与矩形布局解析"></a>变量与矩形布局解析</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//三重矩阵布局：我的想法是用三个16*16的矩阵，分别用来表示雷区、地雷的数量、方块的状态，然后将他们进行一张棋盘重合</span><span class="token comment">//这样的布局，可以降低开发难度，调用时也更加不易弄晕矩阵</span><span class="token keyword">int</span> Minefield_matrix<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//雷区矩阵</span><span class="token keyword">int</span> Mine_Count_matrix<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//地雷计数矩阵</span><span class="token keyword">int</span> Block_Status_matrix<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//方块状态矩阵</span><span class="token comment">//公用循环变量：</span><span class="token comment">//这里设定为全局变量，是因为后续会使用很多次，我懒得在里面加int，而且C89标准是不能在for里定义int i的</span><span class="token comment">//所以为了照顾不同编译标准的读者，这里我将其定义为全局变量</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//中转地雷数组：用于临时中转存储地雷</span><span class="token keyword">int</span> Transfer_Mine_matrix<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//方块状态flag</span><span class="token keyword">int</span> IsMine_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//0表示非雷，1表示雷</span><span class="token comment">//游戏胜利flag</span><span class="token keyword">int</span> Success_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//0表示失败，1表示成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="随机雷的实现"><a href="#随机雷的实现" class="headerlink" title="随机雷的实现"></a>随机雷的实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//生成随机雷</span><span class="token comment">//思路：</span><span class="token comment">//1.雷随机生成 16*16=256 从左到右 1~256</span><span class="token comment">//2.随机生成40个[1,256]范围的随机数，通过对矩阵的位置，将对应的编号设置为雷</span><span class="token comment">//3.为防止生成的随机数有重复的，每生成一个随机数，就将这个数存入Transfer_Mine_matrix[40]这个中转地雷数组中</span><span class="token comment">//4.之后生成的随机数需与数组中的元素进行比较，若重复则不会保存在数组中</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过时间播种生成随机数用于表示雷</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> Mine_Number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> Mine_Number <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span> Mine_Number<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> Correct_Number_mine <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//合格的雷的随机数字</span>Correct_Number_mine <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//生成1~256范围内随机数</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Correct_Number_mine <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> Correct_Number_mine <span class="token operator">></span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token comment">//随机数不符合要求</span><span class="token punctuation">&#123;</span>Mine_Number<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token comment">//随机数符合要求</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Transfer_Mine_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> Correct_Number_mine<span class="token punctuation">)</span><span class="token comment">//如果合格的雷在中转地雷数组中存在</span><span class="token punctuation">&#123;</span>Mine_Number<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//不符合的雷去掉，雷数-1</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Transfer_Mine_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//如果合格的雷没有出现过，则存入中转地雷数组中 中转地雷数组初始化是0</span><span class="token punctuation">&#123;</span>Transfer_Mine_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Correct_Number_mine<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//测试雷的位置</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> Transfer_Mine_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><font color=red>随机雷生成测试结果图：</font></strong></p><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312222108713.png" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312222108713.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312222108713"><hr><h3 id="生成雷位置矩阵的实现"><a href="#生成雷位置矩阵的实现" class="headerlink" title="生成雷位置矩阵的实现"></a>生成雷位置矩阵的实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//生成雷的矩阵</span><span class="token comment">//思路：通过Transfer_Mine_matrix中转地雷数组中的随机数，通过对应关系写入雷区矩阵Minefield_matrix[16][16]中，雷的位置表示为1，非雷的位置表示为0</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> length <span class="token operator">&lt;</span> <span class="token number">40</span><span class="token punctuation">;</span> length<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//计数</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Transfer_Mine_matrix<span class="token punctuation">[</span>length<span class="token punctuation">]</span> <span class="token operator">==</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>IsMine_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//1表示雷，0表示非雷</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>IsMine_flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>IsMine_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化，以免影响下次循环</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化，以免影响下次循环</span><span class="token punctuation">&#125;</span><span class="token comment">//雷矩阵调试</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">colour</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是雷标记为红色</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">colour</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不是雷标记为白色</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印雷矩阵</span><span class="token punctuation">&#125;</span><span class="token function">colour</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//让后续字体染色显示不为红色</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><font color=red>生成雷位置矩阵调试结果图：</font></strong></p><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312222302830.png" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312222302830.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312222302830"><hr><h3 id="生成雷数矩阵的实现"><a href="#生成雷数矩阵的实现" class="headerlink" title="生成雷数矩阵的实现"></a>生成雷数矩阵的实现</h3><blockquote><p><strong>&#x3D;&#x3D;雷数矩阵处理的想法：&#x3D;&#x3D;</strong></p><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312223433200.png" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312223433200.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312223433200"><ul><li><strong><font color=red>上图是我们对于一个矩阵四周遍历的常规过程，可以看出，我们进行遍历都是一边一边的进行遍历，由外向内进行遍历。当我们处理边界的是否就非常头疼了，这时我们可以使用循环不变量法</font></strong></li><li><strong>&#x3D;&#x3D;循环不变量法：比如上图，就是我们在考虑边界问题的时候是非常头疼的，如果我们每边都考虑全部遍历完，就会出现很多边界考虑问题，但是如果我们把遍历方式都设置成一种，那么就让边界问题变成了一种情况，也就是上图的只遍历开始到最后一位的前一位，让下一次循环遍历剩下的元素，从而叫做循环不变量法&#x3D;&#x3D;</strong></li><li><strong>&#x3D;&#x3D;但是我们在处理雷数矩阵的时候，要处理的时一个元素四周，所以直接使用循环不变量法不合适的。我们可以使用它的思想，进行雷数的计算&#x3D;&#x3D;</strong></li><li><strong><font color=red>这里我的想法是，先处理矩阵的四个角，然后处理去角的四边，那么我们就剩下了一个15*15的正方形了，处理正方形我们就有了一个通用的方法进行计算，如下图</font></strong></li></ul><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312223651966.png" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312223651966.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312223651966"></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//通过对matrix矩阵每个元素的周围八个元素计算雷数，并将雷数存入number[16][16]矩阵中</span><span class="token comment">//number矩阵中1~8表示雷数，9表示该元素为雷</span><span class="token comment">//通过对Minefield_matrix雷区矩阵每个元素的周围八个元素进行计算雷数，并将雷存入Mine_Count_matrix地雷计数矩阵中</span><span class="token comment">//Mine_Count_martix地雷计数矩阵中，1~8表示周围雷数量，9表示该元素为雷</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//如果是雷设为9</span><span class="token punctuation">&#123;</span>Mine_Count_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//思路：</span><span class="token comment">//1.先处理16*16矩阵的，四个边角，坐标为(0,0)、(0,15)、(15,0)、(15,15)</span><span class="token comment">//2.再处理矩形的四边，在处理过程把矩阵看成一个17*17的矩阵，这样是为了方便计数设计，数组溢出并不会有什么问题，因为我们没有使用它</span><span class="token comment">//3.最后我们会剩下一个规整15*15的正方形，然后处理每个方块的八个方向就可以了</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//左上角</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左上角方块右侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左上角方块下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左上角方块斜右下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token comment">//右上角</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右上角方块左侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右上角方块下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右上角方块斜左下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">15</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//左下角</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左下角方块右侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左下角方块侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左下角方块斜右上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">15</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token comment">//右下角</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右下角方块左侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右下角方块上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右小角方块斜左上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//处理顶部,第二个方块开始</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理左侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理右侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理左下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理右下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token comment">//处理右部，第二个方块开始</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理右侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理左侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理左上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理左下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token comment">//处理底部，第二个方块开始</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理左侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理右侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理左上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理右上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//处理左部，第二个方块开始</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理右侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理右上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//处理右下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token comment">//处理剩下的规整15*15正方形的八个方向</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右上侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//左下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//右下侧</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Mine_Count_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//数字阵调试</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Mine_Count_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">colour</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//red</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">colour</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//white</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> Mine_Count_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">colour</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red><strong>雷数矩阵数字阵调试结果图：</strong></font></p><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312223143153.png" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312223143153.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312223143153"><hr><h3 id="绘制图像过程"><a href="#绘制图像过程" class="headerlink" title="绘制图像过程"></a>绘制图像过程</h3><img src="/2023/03/12/1.sao-lei-xiang-mu/image-20230312080110001.gif" class="lazyload placeholder" data-srcset="/2023/03/12/1.sao-lei-xiang-mu/image-20230312080110001.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20230312080110001"><blockquote><p><strong>&#x3D;&#x3D;我们在绘制函数initgraph哪里打个断点，让我们继续往后执行，看下图像绘制的过程&#x3D;&#x3D;</strong></p><ul><li><strong><font color=red>通过上图可以很直观的看到，这个图像的绘制时先导入图像，然后先绘制一个(735,883)的长方形，然后绘制中间的笑脸，最后根据我们设定的方块间隔，一块一块的绘制整个图像</font></strong></li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//载入素材</span><span class="token function">initgraph</span><span class="token punctuation">(</span><span class="token number">735</span><span class="token punctuation">,</span> <span class="token number">883</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//测试(745,845)刚好放下16*16的矩形</span><span class="token comment">//IMAGE 定义一个图片名</span><span class="token comment">//游戏背景</span>IMAGE cube<span class="token punctuation">;</span><span class="token comment">//方块图标</span>IMAGE cube_trigger<span class="token punctuation">;</span><span class="token comment">//方块触发器：变色</span>IMAGE background<span class="token punctuation">;</span><span class="token comment">//背景</span><span class="token comment">//游戏符号</span>IMAGE mine_eliminate<span class="token punctuation">;</span><span class="token comment">//地雷图标</span>IMAGE mine_trigger<span class="token punctuation">;</span><span class="token comment">//地雷触发器：变色</span>IMAGE mine_flag<span class="token punctuation">;</span><span class="token comment">//插旗图标</span>IMAGE question<span class="token punctuation">;</span><span class="token comment">//问号图标</span>IMAGE question_trigger<span class="token punctuation">;</span><span class="token comment">//问号触发器：变色</span><span class="token comment">//游戏脸部</span>IMAGE smile<span class="token punctuation">;</span><span class="token comment">//笑脸图标</span>IMAGE smile_trigger<span class="token punctuation">;</span><span class="token comment">//笑脸触发器：变脸</span>IMAGE caution<span class="token punctuation">;</span><span class="token comment">//谨慎图标</span>IMAGE dead<span class="token punctuation">;</span><span class="token comment">//死亡图标</span>IMAGE dead_trigger<span class="token punctuation">;</span><span class="token comment">//死亡触发器：变脸</span><span class="token comment">//游戏雷数：雷数0-8颜色,9表示本身为雷</span>IMAGE mine_0<span class="token punctuation">;</span><span class="token comment">//雷数0图标</span>IMAGE mine_1<span class="token punctuation">;</span><span class="token comment">//雷数1图标</span>IMAGE mine_2<span class="token punctuation">;</span><span class="token comment">//雷数2图标</span>IMAGE mine_3<span class="token punctuation">;</span><span class="token comment">//雷数3图标</span>IMAGE mine_4<span class="token punctuation">;</span><span class="token comment">//雷数4图标</span>IMAGE mine_5<span class="token punctuation">;</span><span class="token comment">//雷数5图标</span>IMAGE mine_6<span class="token punctuation">;</span><span class="token comment">//雷数6图标</span>IMAGE mine_7<span class="token punctuation">;</span><span class="token comment">//雷数7图标</span>IMAGE mine_8<span class="token punctuation">;</span><span class="token comment">//雷数8图标</span>IMAGE mine_9<span class="token punctuation">;</span><span class="token comment">//雷数9图标</span><span class="token comment">//loadimage 从图片中获取图像</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cube<span class="token punctuation">,</span> <span class="token string">"./pic/cube.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载方块图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cube_trigger<span class="token punctuation">,</span> <span class="token string">"./pic/cube_trigger.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载方块触发器图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>background<span class="token punctuation">,</span> <span class="token string">"./pic/background.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载背景图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_eliminate<span class="token punctuation">,</span> <span class="token string">"./pic/mine_eliminate.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载地雷图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_trigger<span class="token punctuation">,</span> <span class="token string">"./pic/mine_trigger.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载地雷触发器图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_flag<span class="token punctuation">,</span> <span class="token string">"./pic/mine_flag.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载插旗图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>question<span class="token punctuation">,</span> <span class="token string">"./pic/question.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载问号图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>question_trigger<span class="token punctuation">,</span> <span class="token string">"./pic/question_trigger.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载问号触发器图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>smile<span class="token punctuation">,</span> <span class="token string">"./pic/smile.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载笑脸图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>smile_trigger<span class="token punctuation">,</span> <span class="token string">"./pic/smile_trigger.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载笑脸触发器图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>caution<span class="token punctuation">,</span> <span class="token string">"./pic/caution.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载谨慎图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dead<span class="token punctuation">,</span> <span class="token string">"./pic/dead.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载死亡图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dead_trigger<span class="token punctuation">,</span> <span class="token string">"./pic/dead_trigger.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载死亡触发器图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_0<span class="token punctuation">,</span> <span class="token string">"./pic/mine_0.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数0图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_1<span class="token punctuation">,</span> <span class="token string">"./pic/mine_1.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数1图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_2<span class="token punctuation">,</span> <span class="token string">"./pic/mine_2.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数2图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_3<span class="token punctuation">,</span> <span class="token string">"./pic/mine_3.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数3图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_4<span class="token punctuation">,</span> <span class="token string">"./pic/mine_4.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数4图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_5<span class="token punctuation">,</span> <span class="token string">"./pic/mine_5.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数5图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_6<span class="token punctuation">,</span> <span class="token string">"./pic/mine_6.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数6图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_7<span class="token punctuation">,</span> <span class="token string">"./pic/mine_7.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数7图标</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mine_8<span class="token punctuation">,</span> <span class="token string">"./pic/mine_8.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载雷数8图标</span><span class="token comment">//贴图</span><span class="token comment">//putimage 绘制图片到屏幕，图片左上角坐标为(0,0)</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>background<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>smile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//绘制扫雷的矩阵，循环中i、j同时对应Minefield_matrix雷区数组、Mine_Count_matrix地雷计数数组、 Block_Status_matrix方块状态矩阵</span><span class="token comment">//这样做的好处是方便后面的鼠标机交互坐标检测</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cube<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="输赢检测规则"><a href="#输赢检测规则" class="headerlink" title="输赢检测规则"></a>输赢检测规则</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在游戏逻辑大循环前进行输赢检测，通过遍历Block_Status_matrix矩阵中的值进行计数，若元素值4的数量到达216即判定为胜利</span><span class="token comment">/*|-----------------------------------------------------------------------------------------------||Block_Status_matrix矩阵内元素值的含义：     ||0 = 未触发的元素，相当于普通白方块      ||    ||1 = 鼠标左键点击某元素后与其相邻的number矩阵中值为0的，但还未检测周边元素的元素          ||    ||2 = 鼠标左键点击某元素后触发拓展后与number矩阵中值为0的元素相邻的number矩阵中值为1~8的元素         ||    ||3 = 鼠标左键点击某元素后与其相邻的number矩阵中值为0的，且已检测周边元素的元素      ||    ||4 = 界面上已被贴图位置（空贴图，及1~8数字贴图）所对应的元素       ||    ||5 = 鼠标右键点击某元素后，该元素位置被贴为红旗的元素    ||    ||6 = 鼠标右键点击某元素后，该元素位置被贴为问号的元素    ||-----------------------------------------------------------------------------------------------|*/</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> Block_Status4_Number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//Block_Status4_Number矩阵内元素值4的贴图数量</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">//如果贴上红旗</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//如果红旗下是雷</span>Block_Status4_Number<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status4_Number <span class="token operator">==</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token comment">//40个雷都给正确排出来了</span><span class="token punctuation">&#123;</span>Success_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//游戏成功旗帜</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Block_Status4_Number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//排除特殊情况，初始化为0开始正常情况</span><span class="token comment">//正常情况：界面贴图216游戏结束，还有40个是雷</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span>Block_Status4_Number<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status4_Number <span class="token operator">==</span> <span class="token number">216</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Success_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//游戏成功旗帜</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Block_Status4_Number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="检测相邻空元素的方法"><a href="#检测相邻空元素的方法" class="headerlink" title="检测相邻空元素的方法"></a>检测相邻空元素的方法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//检测相邻空元素函数解释：   </span><span class="token comment">//1.此处运用递归方法，实现了对触发空元素的所有相邻空元素的检测，检测完成的空元素，status矩阵中的状态值会被调整为3； </span><span class="token comment">//2.被检测出但还未检测其本身的元素状态值将会被设为1，当status矩阵中不存在值为1的元素时，即表示所有相邻空元素已检测完成，递归停止</span>    <span class="token comment">//检测相邻空元素函数：Detects_adjacent_empty_elements(int, int, int[16][16], int[16][16])</span><span class="token keyword">void</span> <span class="token function">Detects_adjacent_empty_elements</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> number<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> status<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//1.检测初始状态为0、没有被检测的0、没有被贴红旗的0、没有被贴为问号的0</span><span class="token comment">//2.将符合条件的元素状态变更为1，即此元素已经被检测过的0</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>number<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>number<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>number<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>number<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//将此元素调整为3，即表示：此元素周围元素都被检测了</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//调整状态为3</span><span class="token comment">//通过递归法，将256个元素都进行检查，调整状态</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">Detects_adjacent_empty_elements</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> number<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="扩展空元素区域的方法"><a href="#扩展空元素区域的方法" class="headerlink" title="扩展空元素区域的方法"></a>扩展空元素区域的方法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//扩展空元素区域函数解释：</span><span class="token comment">//1.经上一步检测出的空元素后，要将其相邻的数值为1~8的元素也贴上图，因此将status矩阵中值为3的元素的周围的值</span><span class="token comment">//2.不为3的元素的状态值变为2，即表示即将要被贴图的不为空的元素</span> <span class="token comment">//扩展空元素区域函数：Expand_empty_element_area(int[16][16],int[16][16])</span><span class="token keyword">void</span> <span class="token function">Expand_empty_element_area</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//如何状态已经被检测</span><span class="token punctuation">&#123;</span>                <span class="token comment">//1.符合状态不为3、不为5、不为6的元素</span>                <span class="token comment">//2.将符合条件的元素状态更改为2</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">!=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">15</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">15</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">!=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">&amp;&amp;</span> status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">6</span><span class="token punctuation">)</span>status<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="绘制状态贴图的方法"><a href="#绘制状态贴图的方法" class="headerlink" title="绘制状态贴图的方法"></a>绘制状态贴图的方法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">状态绘图函数解释：<span class="token number">1.</span>经过上两步的检测，所有要被贴图的元素状态已被设为<span class="token number">2</span>和<span class="token number">3</span>，因此仅需遍历status矩阵                             <span class="token number">2.</span>找到状态为<span class="token number">2</span>和<span class="token number">3</span>的元素，在对照number矩阵中的值贴上空以及<span class="token number">1</span><span class="token operator">~</span><span class="token number">8</span>的图片素材<span class="token comment">//状态绘图函数：State_mapping(int[16][16], int[16][16], IMAGE, IMAGE, IMAGE, IMAGE, IMAGE, IMAGE, IMAGE, IMAGE, IMAGE)</span><span class="token keyword">void</span> <span class="token function">State_mapping</span><span class="token punctuation">(</span><span class="token keyword">int</span> Mine_Count_matrix<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> Block_Status_matrix<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> IMAGE ZERO<span class="token punctuation">,</span> IMAGE ONE<span class="token punctuation">,</span> IMAGE TWO<span class="token punctuation">,</span> IMAGE THREE<span class="token punctuation">,</span> IMAGE FOUR<span class="token punctuation">,</span> IMAGE FIVE<span class="token punctuation">,</span> IMAGE SIX<span class="token punctuation">,</span> IMAGE SEVEN<span class="token punctuation">,</span> IMAGE EIGHT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>Mine_Count_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ONE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TWO<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>THREE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>FOUR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>FIVE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>SIX<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>SEVEN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>EIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="展示地雷的方法"><a href="#展示地雷的方法" class="headerlink" title="展示地雷的方法"></a>展示地雷的方法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//展示地雷函数解释：</span><span class="token comment">//1.游戏失败后，需向玩家展示所有地雷的位置，根据雷位置所在元素进行贴图即可</span><span class="token comment">//展示地雷：Display_mine(int matrix[16][16], IMAGE mine_eliminate)</span><span class="token keyword">void</span> <span class="token function">Display_mine</span><span class="token punctuation">(</span><span class="token keyword">int</span> matrix<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> IMAGE mine_eliminate<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_eliminate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="鼠标交互逻辑解析"><a href="#鼠标交互逻辑解析" class="headerlink" title="鼠标交互逻辑解析"></a>鼠标交互逻辑解析</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//鼠标交互逻辑</span>MOUSEMSG mousemsg <span class="token operator">=</span> <span class="token function">GetMouseMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解释：</span><span class="token comment">//1.MOUSEMSG:定义结构体鼠标</span><span class="token comment">//2.GetMouseMsg():获取当前鼠标信息</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j <span class="token operator">&lt;=</span> mousemsg<span class="token punctuation">.</span>x <span class="token operator">&amp;&amp;</span> mousemsg<span class="token punctuation">.</span>x <span class="token operator">&lt;=</span> <span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j <span class="token operator">+</span> <span class="token number">42</span> <span class="token operator">&amp;&amp;</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i <span class="token operator">&lt;=</span> mousemsg<span class="token punctuation">.</span>y<span class="token operator">&amp;&amp;</span> mousemsg<span class="token punctuation">.</span>y <span class="token operator">&lt;=</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">42</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span>            <span class="token operator">||</span> Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token operator">||</span> Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mousemsg<span class="token punctuation">.</span>uMsg <span class="token operator">==</span> WM_LBUTTONDOWN <span class="token operator">&amp;&amp;</span> Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">//如果左键点击,并且没贴红旗</span><span class="token punctuation">&#123;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>caution<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//界面上方笑脸图标切换为谨慎图标 </span><span class="token keyword">if</span><span class="token punctuation">(</span>Mine_Count_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token comment">//如果点击的元素为雷</span><span class="token punctuation">&#123;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_trigger<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//绘制雷的图片 </span>Success_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//游戏失败旗帜</span>IsMine_flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//是雷旗帜</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Mine_Count_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//如果点击的元素不为雷而为空</span><span class="token punctuation">&#123;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>Mine_Count_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//按照相邻元素中雷的数量进行贴图</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_5<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_6<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_7<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span> <span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_8<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//状态转换为已贴图</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token comment">//该元素为雷</span><span class="token punctuation">&#123;</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">Detects_adjacent_empty_elements</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> Mine_Count_matrix<span class="token punctuation">,</span> Block_Status_matrix<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//扫描周围的所有空元素</span><span class="token function">Expand_empty_element_area</span><span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对周围空元素进行扩展</span><span class="token function">State_mapping</span><span class="token punctuation">(</span>Mine_Count_matrix<span class="token punctuation">,</span> Block_Status_matrix<span class="token punctuation">,</span> mine_0<span class="token punctuation">,</span> mine_1<span class="token punctuation">,</span> mine_2<span class="token punctuation">,</span> mine_3<span class="token punctuation">,</span> mine_4<span class="token punctuation">,</span> mine_5<span class="token punctuation">,</span> mine_6<span class="token punctuation">,</span> mine_7<span class="token punctuation">,</span> mine_8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//绘制状态图片</span><span class="token punctuation">&#125;</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//睡眠0.25秒，让谨慎脸转换笑脸自然一点</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>smile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//界面上方的笑脸</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mousemsg<span class="token punctuation">.</span>uMsg <span class="token operator">==</span> WM_RBUTTONDOWN<span class="token punctuation">)</span><span class="token comment">//如果右键点击</span><span class="token punctuation">&#123;</span><span class="token comment">//将状态在未触发0、插旗状态5、问号状态6之间切换</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//不是雷</span><span class="token punctuation">&#123;</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//贴插旗状态</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//贴上插旗图标 </span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">//如果已经是红旗状态了</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">//状态改为问号</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token comment">//如果已经是问号状态了</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//状态改为未触发状态</span><span class="token punctuation">&#125;</span><span class="token comment">//将触发状态图标在未触发、问号之间切换</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//未触发图标</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cube_trigger<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//问号图标</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>question_trigger<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//将图标在未触发、问号之间切换</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token comment">//鼠标交互反应贴图</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cube<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>question<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>IsMine_flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>IsMine_flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>IsMine_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">333</span> <span class="token operator">&lt;=</span> mousemsg<span class="token punctuation">.</span>x <span class="token operator">&amp;&amp;</span> mousemsg<span class="token punctuation">.</span>x <span class="token operator">&lt;=</span> <span class="token number">413</span> <span class="token operator">&amp;&amp;</span> <span class="token number">15</span> <span class="token operator">&lt;=</span> mousemsg<span class="token punctuation">.</span>y <span class="token operator">&amp;&amp;</span> mousemsg<span class="token punctuation">.</span>y <span class="token operator">&lt;=</span> <span class="token number">95</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mousemsg<span class="token punctuation">.</span>uMsg <span class="token operator">==</span> WM_LBUTTONDOWN<span class="token punctuation">)</span><span class="token comment">//如果点击笑脸，重新开始游戏</span><span class="token punctuation">&#123;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>smile_trigger<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">goto</span> start<span class="token punctuation">;</span><span class="token comment">//goto函数进行跳转</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="游戏获胜与失败判定原理"><a href="#游戏获胜与失败判定原理" class="headerlink" title="游戏获胜与失败判定原理"></a>游戏获胜与失败判定原理</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//游戏失败</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Success_flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">settextcolor</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setbkmode</span><span class="token punctuation">(</span>TRANSPARENT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">settextstyle</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"黑体"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">outtextxy</span><span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"GAME  OVER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Display_mine</span><span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">,</span> mine_eliminate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> j<span class="token punctuation">,</span> <span class="token number">118</span> <span class="token operator">+</span> <span class="token number">45</span> <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mine_trigger<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>MOUSEMSG mouse <span class="token operator">=</span> <span class="token function">GetMouseMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">333</span> <span class="token operator">&lt;=</span> mouse<span class="token punctuation">.</span>x <span class="token operator">&amp;&amp;</span> mouse<span class="token punctuation">.</span>x <span class="token operator">&lt;=</span> <span class="token number">413</span> <span class="token operator">&amp;&amp;</span> <span class="token number">15</span> <span class="token operator">&lt;=</span> mouse<span class="token punctuation">.</span>y <span class="token operator">&amp;&amp;</span> mouse<span class="token punctuation">.</span>y <span class="token operator">&lt;=</span> <span class="token number">95</span><span class="token punctuation">)</span><span class="token comment">//点击哭脸可重新开始游戏</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mouse<span class="token punctuation">.</span>uMsg <span class="token operator">==</span> WM_LBUTTONDOWN<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dead_trigger<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">goto</span> start<span class="token punctuation">;</span><span class="token comment">//goto跳转</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//游戏成功</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Success_flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">settextcolor</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setbkmode</span><span class="token punctuation">(</span>TRANSPARENT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">settextstyle</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"黑体"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">outtextxy</span><span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"GAME  WIN！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>smile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Display_mine</span><span class="token punctuation">(</span>Minefield_matrix<span class="token punctuation">,</span> mine_eliminate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> Block_Status_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="自定义颜色制定"><a href="#自定义颜色制定" class="headerlink" title="自定义颜色制定"></a>自定义颜色制定</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//自定义文字颜色函数：colour(short x)</span><span class="token keyword">void</span> <span class="token function">colour</span><span class="token punctuation">(</span><span class="token keyword">short</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">SetConsoleTextAttribute</span><span class="token punctuation">(</span><span class="token function">GetStdHandle</span><span class="token punctuation">(</span>STD_OUTPUT_HANDLE<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用这个函数方便我们给雷标记颜色</span><span class="token comment">/*函数解释：SetConsoleTextAttribute()函数是一个API设置字体颜色和背景色的函数。参数表中使用两个属性（属性之间用，隔开），不同于system(color)，SetConsoleTextAttribute()可以改变界面多种颜色，而system()只能修改为一种！函数原型：SetConsoleTextAttribute(_In_ HANDLE hConsoleOutput, _In_ WORD wAttributes);第一个属性获得句柄（即要设置颜色的地方），第二个属性设置颜色句柄：STD_INPUT_HANDLE含义：标准输入的句柄句柄：STD_OUTPUT_HANDLE含义：标准输出的句柄句柄：STD_ERROR_HANDLE含义：标准错误的句柄颜色设置(三种方法)：1.SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 0x07);第二个参数填十六进制数字2.SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);直接填十进制数字3.SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLACK | FOREGROUND_RED);BACKGROUND代表背景，FOREGROUND代表前景4.数字代表的什么请搜索一下，这里我用的是十进制数字，15代表白色，12代表红色，用红色来标记雷，白色标记非雷*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GUI版扫雷游戏项目&quot;&gt;&lt;a href=&quot;#GUI版扫雷游戏项目&quot; class=&quot;headerlink&quot; title=&quot;GUI版扫雷游戏项目&quot;&gt;&lt;/a&gt;GUI版扫雷游戏项目&lt;/h1&gt;&lt;h2 id=&quot;观前提醒&quot;&gt;&lt;a href=&quot;#观前提醒&quot; class=&quot;head</summary>
      
    
    
    
    <category term="项目" scheme="https://not-go.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://not-go.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境搭建</title>
    <link href="https://not-go.github.io/2023/02/20/1.linux-huan-jing-da-jian/"/>
    <id>https://not-go.github.io/2023/02/20/1.linux-huan-jing-da-jian/</id>
    <published>2023-02-20T04:20:00.000Z</published>
    <updated>2023-06-23T16:08:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux环境搭建"><a href="#Linux环境搭建" class="headerlink" title="Linux环境搭建"></a><strong>Linux环境搭建</strong></h1><h2 id="Linux背景介绍"><a href="#Linux背景介绍" class="headerlink" title="Linux背景介绍"></a><strong>Linux背景介绍</strong></h2><h3 id="系统发展史"><a href="#系统发展史" class="headerlink" title="系统发展史"></a><strong>系统发展史</strong></h3><p><strong>我们学习Linux系统编程，那Linux从哪里来？它是怎么发展的？要说 Linux，还得从UNIX说起</strong></p><p><mark><strong>UNIX发展史：</strong></mark></p><ul><li><strong>1968年，一些来自通用电器公司、贝尔实验室和麻省理工学院的研究人员开发了一个叫Multics的特殊操作系统。Multics在多任务文件管理和用户连接中综合了许多新概念</strong></li><li><strong>1969－1970年，AT&amp;T的贝尔实验室研究人员Ken Tompson和Dennis Ritchie，在采用很多Multics特点的基础 上开发了UINX系统。它运行在小型机上，满足了系统对科研环境的要求。从产生开始，UNIX就是一个有价值 的、高效的、多用户和多任务的操作系统</strong></li><li><strong>UNIX从满足个人的设计需求开始，逐步成长为由许多不同开发商所支持的标准软件产品</strong></li><li><strong>第一个UNIX版本是免费给许多知名大学的计算机系使用的</strong></li><li><strong>1972年，贝尔实验室开始发放商业版本，并且给不同的用户授权使用这个系统，使用者之一是加州大学伯克莱 分校的计算机系。伯克莱给系统增加了许多新的特点，后来成为了标准</strong></li><li><strong>1975年伯克莱由下属部门BSD发行了自己的UNIX版本。UNIX的BSD版本成为AT&amp;T贝尔实验室版本的主要竞争 者，而其它的独立开发出的UNIX版本也开始萌生</strong></li><li><strong>1980年微软公司开发了叫做Xenix的UNIX PC版本。AT&amp;T发行了第一个商业版本。名叫System Ⅲ，后来被成为 对商用软件产品良好支持的System Ⅴ所替代</strong></li><li><strong>同时UNIX的BSD版本不断发展，在70年代末期，BSD UNIX成为了国防部的高科技研究机构科研项目的基础。 其结果，伯克莱发行了一个叫做BSD Release 4.2的有效版本</strong></li><li><strong>它包括了高级的文件管理器和基于TCP&#x2F;IP网络协议的网络特点。现在TCP&#x2F;IP被Internet所使用。BSD Release 4.2被许多厂商所采用，例如SUN Microsystem</strong></li><li><strong>UNIX不同版本的出现导致了UNIX标准的需要，软件开发商不知道他们的程序运行在哪些版本上比较合适</strong></li><li><strong>到80年代中期，两个竞争的标准出现了，一个是基于AT&amp;T的UNIX版本，另一个是BSD版本。在今天的书店里你 能发现分别适用于这两个版本的不同的UNIX的书，一些是System V，另一些集中在BSD UNIX</strong></li><li><strong>AT&amp;T建立了一个叫UNIX系统实验室的新组织，它的作用就是综合UNIX的不同版本，集中开发一个标准系统</strong></li><li><strong>1991年，UNIX综合实验室综合了System V Release3，SUN OS和Xenix的所有特点，发行了System V Release 4。为了与System V Release 4 竞争，一些其它公司，如IBM和惠普Open Software Foundation（OSF）去产 生自己的UNIX标准版本，继而出现了两个标准商业版本OSF版本和System Release 4</strong></li><li><strong>1993年，AT&amp;T把它的UNIX转卖给Novell公司。UNIX系统实验室成为了Novell的UNIX系统小组的一部分。 Novell发行了基于System V Release 4的自己的UNIX版本UNIXWare，它可以和Novell公司的Netware系统相联。SUN公司已经把System V Release 4 融进了它的SUN OS，发行了Solaris。两个相互竞争的UNIX使用的图形用户界面（一个叫Motif，另一个叫Openlook），已经合并为一个新的工作平台标准，叫做通用平台环境 （CDE）</strong></li></ul><p><mark><strong>Linux发展历史：</strong></mark></p><ul><li><strong>1991年10月5日，赫尔辛基大学的一名研究生Linus Benedict Torvalds在一个Usenet新闻组（comp.os.minix）中宣布他编制出了一种类似UNIX的小操作系统，叫Linux。新的操作系统是受到另一 个UNIX的小操作系统——Minix的启发，该系统是由一名叫Andrew S Tanenbaum的教师开发的。读者也 许猜想所发布的这个系统应该是Linux的0.01版本，实际上不是这样。真正的Linux 0.01版本并没有被发 布，原因是0.01版本不实用。Linus仅仅在第一个Linux的FTP站点（<a href="ftp://nic.funet.fi)上提供过这个版本/">ftp://nic.funet.fi）上提供过这个版本</a> 的的源代码</strong></li><li><strong>Torvalds于10月5日发布的这个Linux版本被称为0.02版，它能够运行GNU Bourne Again Shell(bash)和GNU的 C编译程序（gcc）以及为数不多的其它语言。Torvalds绝对没有想到他设想的一种能够针对高级业余爱好者和黑客们的操作系统已经产生，这就是人们所称的Linux</strong></li><li><strong>Linux发布时的版本是0.02，后来又有0.03版，然后又跳到0.10版。因为世界各地越来越多的程序员都开始开发Linux，它已经达到0.95版。这就意味着正是公布1.0版本的时间已经为期不远了。正式的1.0版本是在1994年公布的</strong></li></ul><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504001.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504001.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504001"><hr><h3 id="开源与官方网址"><a href="#开源与官方网址" class="headerlink" title="开源与官方网址"></a><strong>开源与官方网址</strong></h3><ul><li><strong>Linux是一种自由和开放源代码的类UNIX操作系统，该操作系统的内核由林纳斯托瓦兹在1991年首次发 布，之后，在加上用户空间的应用程序之后，就成为了Linux操作系统。严格来讲，Linux只是操作系统内 核本身，但通常采用“Linux内核”来表达该意思。而Linux则常用来指基于Linux内核的完整操作系统，它 包括GUI组件和许多其他实用工具</strong></li><li><strong>GNU通用公共许可协议（GNU General Public License，简称GNU GPL或GPL），是一个广泛被使用的自由软 件许可协议条款，最初由理查德斯托曼为GNU计划而撰写，GPL给予了计算机程序自由软件的定义， 任何基于 GPL软件开发衍生的产品在发布时必须采用GPL许可证方式，且必须公开源代码</strong></li><li><strong>Linux是自由软件和开放源代码软件发展中最著名的例子。只要遵循GNU通用公共许可证，任何个人和机构都可 以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。随着Linux操作系统飞速发展，各种集成 在Linux上的开源软件和实用工具也得到了应用和普及，因此，Linux也成为了开源软件的代名词</strong></li></ul><p><strong>Linux官方地址：</strong><a href="https://www.kernel.org/"><strong>Kernel官方地址</strong></a></p><hr><h3 id="企业Linux应用现状"><a href="#企业Linux应用现状" class="headerlink" title="企业Linux应用现状"></a><strong>企业Linux应用现状</strong></h3><ul><li><p><strong><mark>Linux在服务器领域的发展</mark></strong></p><p> <strong>随着开源软件在世界范围内影响力日益增强，Linux服务器操作系统在整个服务器操作系统市场格局中占 据了越来越多的市场份额，已经形成了大规模市场应用的局面。并且保持着快速的增长率。尤其在政府、 金融、农业、交通、电信等国家关键领域。此外，考虑到Linux的快速成长性以及国家相关政策的扶持力 度，Linux服务器产品一定能够冲击更大的服务器市场。 据权威部门统计，目前Linux在服务器领域已经占据75%的市场份额，同时，Linux在服务器市场的迅速崛 起，已经引起全球IT产业的高度关注，并以强劲的势头成为服务器操作系统领域中的中坚力量</strong></p></li><li><p><strong><mark>Linux在桌面领域的发展</mark></strong> </p><p><strong>近年来，特别在国内市场，Linux桌面操作系统的发展趋势非常迅猛。国内如中标麒麟Linux、红旗 Linux、深度Linux等系统软件厂商都推出的Linux桌面操作系统，目前已经在政府、企业、OEM等领域得 到了广泛应用。另外SUSE、Ubuntu也相继推出了基于Linux的桌面系统，特别是Ubuntu Linux，已经积 累了大量社区用户。但是，从系统的整体功能、性能来看，Linux桌面系统与Windows系列相比还有一定的差距，主要表现在系统易用性、系统管理、软硬件兼容性、软件的丰富程度等方面</strong></p></li><li><p><strong><mark>Linux在移动嵌入式领域的发展</mark></strong></p><p><strong>Linux的低成本、强大的定制功能以及良好的移植性能，使得Linux在嵌入式系统方面也得到广泛应用，目 前Linux以广泛应用于手机、平板电脑、路由器、电视和电子游戏机等领域。在移动设备上广泛使用的 Android操作系统就是创建在Linux内核之上的。目前，Android已经成为全球最流行的智能手机操作系 统，据2015年权威部门最新统计，Android操作系统的全球市场份额已达84.6%。 此外，思科在网络防火墙和路由器也使用了定制的Linux，阿里云也开发了一套基于Linux的操作系 统“YunOS”，可用于智能手机、平板电脑和网络电视；常见的数字视频录像机、舞台灯光控制系统等都在 逐渐采用定制版本的Linux来实现，而这一切均归功与Linux与开源的力量</strong></p></li><li><p><strong><mark>Linux在云计算&#x2F;大数据领域的发展</mark></strong></p><p> <strong>互联网产业的迅猛发展，促使云计算、大数据产业的形成并快速发展，云计算、大数据作为一个基于开源 软件的平台，Linux占据了核心优势；据Linux基金会的研究，86%的企业已经使用Linux操作系统进行云 计算、大数据平台的构建，目前，Linux已开始取代Unix成为最受青睐的云计算、大数据平台操作系统</strong></p></li></ul><hr><h3 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a><strong>Linux发行版本</strong></h3><ul><li><p><strong><mark>Debian</mark></strong></p><p><strong>Debian运行起来极其稳定，这使得它非常适合用于服务器。 debian这款操作系统无疑并不适合新手用户，而是适合系统管理员和高级用户</strong></p></li><li><p><strong><mark>Ubuntu</mark></strong></p><p><strong>Ubuntu是Debian的一款衍生版，也是当今最受欢迎的免费操作系统。Ubuntu侧重于它在这个市场的应 用，在服务器、云计算、甚至一些运行Ubuntu Linux的移动设备上很常见。Ubuntu是新手用户肯定爱不 释手的一款操作系统</strong></p></li><li><p><strong><mark>红帽企业级Linux</mark></strong></p><p><strong>这是第一款面向商业市场的Linux发行版。它有服务器版本，支持众多处理器架构，包 括x86和x86_64。红帽公司通过课程红帽认证系统管理员&#x2F;红帽认证工程师（RHCSA&#x2F;RHCE），对系统管 理员进行培训和认证</strong></p></li><li><p><strong><mark>CentOS</mark></strong></p><p><strong>CentOS是一款企业级Linux发行版，它使用红帽企业级Linux中的免费源代码重新构建而成。这款重构版 完全去掉了注册商标以及Binary程序包方面一个非常细微的变化。有些人不想支付一大笔钱，又能领略红 帽企业级Linux；对他们来说，CentOS值得一试。此外，CentOS的外观和行为似乎与母发行版红帽企业 级Linux如出一辙。 CentOS使用YUM来管理软件包</strong></p></li><li><p><strong><mark>Fedora</mark></strong></p><p><strong>小巧的Fedora适合那些人：想尝试最先进的技术，等不及程序的稳定版出来。其实，Fedora就是红帽公 司的一个测试平台；产品在成为企业级发行版之前，在该平台上进行开发和测试。Fedora是一款非常好 的发行版，有庞大的用户论坛，软件库中还有为数不少的软件包</strong></p></li><li><p><strong><mark>Kali Linux</mark></strong></p><p><strong>Kali Linux是Debian的一款衍生版。Kali旨在用于渗透测试。Kali的前身是Backtrack。用于Debian的所有 Binary软件包都可以安装到Kali Linux上，而Kali的魅力或威力就来自于此。此外，支持Debian的用户论 坛为Kali加分不少。Kali随带许多的渗透测试工具，无论是Wifi、数据库还是其他任何工具，都设计成立马 可以使用。Kali使用APT来管理软件包毫无疑问，Kali Linux是一款渗透测试工具，或者是文明黑客（我不想谈论恶意黑客）青睐的操作系统</strong></p></li><li><p><strong>还有很多Linux版本……</strong></p></li></ul><hr><h2 id="Linux环境搭配"><a href="#Linux环境搭配" class="headerlink" title="Linux环境搭配"></a><strong>Linux环境搭配</strong></h2><h3 id="Linux环境搭配方式"><a href="#Linux环境搭配方式" class="headerlink" title="Linux环境搭配方式"></a><strong>Linux环境搭配方式</strong></h3><blockquote><p><strong>1.直接安装在物理机上(即直接安装Linux系统给电脑)—不推荐，因为Linux桌面使用起来非常不友好</strong></p><p><strong>2.使用虚拟机安装，将Linux搭建在虚拟机上—当前虚拟机软件存在BUG，会导致环境上出现各种莫名其妙的问题，比较折腾人</strong></p><p><strong>3.使用云服务器，直接去购买—比较推荐，学生有优惠很便宜，系统出问题重新配置方便且快捷</strong></p></blockquote><p><strong>使用云服务器不仅环境搭建简单, 避免折腾, 同时还有一个最大的好处, 部署在云服务器上的项目可以直接被外网访问 到, 这个时候就和一个公司发布一个正式的网站没有任何区别. 也就能让我们自己写的程序真的去给别人去使用</strong></p><hr><h3 id="服务器购买"><a href="#服务器购买" class="headerlink" title="服务器购买"></a><strong>服务器购买</strong></h3><p><strong>大厂出的服务器都差不多，买来学习1G1核都够，建议1G2核，买的时候调有活动的买</strong></p><p><strong>服务器购买地址：</strong></p><p><a href="https://cloud.tencent.com/act/campus">腾讯云 (tencent.com)</a></p><p><a href="https://cn.aliyun.com/">阿里云(aliyun.com)</a></p><p><a href="https://www.huaweicloud.com/">华为云 (huaweicloud.com)</a></p><hr><h3 id="云服务器配置"><a href="#云服务器配置" class="headerlink" title="云服务器配置"></a><strong>云服务器配置</strong></h3><p><mark><strong>第一：购买云服务器</strong></mark></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504002.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504002"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504003.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504003.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504003"><p><mark><strong>第二：选择镜像CentOS7.6</strong></mark></p><p><strong>选择CentOS7.6是因为它适合初学者学习且企业很多都在用CentOS7开发</strong></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504004.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504004.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504004"><p><mark><strong>第三：进入云服务器控制台管理</strong></mark></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504005.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504005.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504005"><p><strong>进入后先重置root密码，root 密码建议设置的稍微复杂一 些, 否则容易被黑客入侵</strong></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504006.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504006.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504006"><p><mark><strong>第四：在这里面主要查看三个东西，为了方便后续使用Xshell远程登陆</strong></mark></p><p>**1. 服务器的外网 IP **</p><p>**2. 服务器的管理员账户 (固定为 root) **</p><p><strong>3. 管理员账户密码(在网站上设置的)</strong></p><hr><h2 id="Linux远程登陆"><a href="#Linux远程登陆" class="headerlink" title="Linux远程登陆"></a><strong>Linux远程登陆</strong></h2><h3 id="Linux桌面"><a href="#Linux桌面" class="headerlink" title="Linux桌面"></a><strong>Linux桌面</strong></h3><p><strong>关于Linux桌面啊，很多初学者都是使用Ubuntu学习的，Ubuntu自带GUI(图形用户界面)，但是我们实际开发是不会使用图形用户界面的，我们大部分时间都对着黑框框在哪里敲代码，主要原因是当你熟练Linux后，GUI反而降低了开发的安全性和效率</strong></p><hr><h3 id="远程登陆工具"><a href="#远程登陆工具" class="headerlink" title="远程登陆工具"></a><strong>远程登陆工具</strong></h3><p><strong>Xshell是一个远程终端软件，这个软件很好用，方便我们远程登陆访问服务器，只要有网就行</strong></p><p><strong>Xshell下载地址：<a href="https://www.xshell.com/zh/free-for-home-school/">Xshell免费版本</a></strong></p><p><strong>家庭和校园使用是免费的（个人用户）填了邮箱就可以了，官方会往你的邮箱里面发一个下载软件的链接，下载安装的时候选择 “home&#x2F;school” 则为免费版本</strong></p><hr><h3 id="Xshell登陆服务器-单用户"><a href="#Xshell登陆服务器-单用户" class="headerlink" title="Xshell登陆服务器(单用户)"></a><strong>Xshell登陆服务器(单用户)</strong></h3><p><mark><strong>方法一：打开Xshell，它会弹出会话，点击新建会话</strong></mark></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504007.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504007.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504007"><p><strong>输入公网IP，端口号22不要改，系统会让你输入用户名和密码，使用用户名root和你刚刚设置的root密码就可以登录了</strong></p><p><mark><strong>方法二：在tx云控制台这里直接点登录，会使用</strong>tx云的默认账户lighthouse<strong>连接你的云主机</strong></mark></p><p><img src="/./1.Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20220713213504008.png" class="lazyload placeholder" data-srcset="/./1.Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20220713213504008.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="20220713213504008"><img src="/./1.Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20220713213504009.png" class="lazyload placeholder" data-srcset="/./1.Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20220713213504009.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="20220713213504009"></p><p><strong>这个方法只适合基础使用，下面讲解两个不同的方法：</strong></p><p><mark><strong>1.使用SSH密钥</strong></mark></p><p><strong>因为Xshell比较聪明，会帮我们记住账户密码，自动输入。但是在很多软件（比如putty）每次开启连接都需要输入账户和密码。这时候我们可以使用更加安全的加密SSH方式连接我们的终端</strong></p><p><strong><mark>首先</mark>：在Xshell的选项卡中，新建一个密匙，这里会让你输入密匙名称和密码，请记住这里的密码！如果忘记了就只能重新生成一个密匙了</strong></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504010.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504010"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504011.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504011.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504011"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504012.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504012.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504012"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504013.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504013.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504013"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504014.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504014.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504014"><p><strong><mark>其次</mark>：来到tx云控制台，密钥，点击创建密钥，选择已有公钥，把刚刚复制的内容丢进去并起个名字。注意这里的地域必须和云服务选择的相同！</strong></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504015.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504015.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504015"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504016.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504016.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504016"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504017.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504017.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504017"><p><strong><mark>最后</mark>：新建一个会话，这里同样填公网ip，然后需要设置<code>用户身份验证</code>，这里很重要！Xshell提示“</strong>密钥没有和云服务器绑定<strong>”都是因为这里没有设置！选择你创建的本地密匙，输入</strong>创建密匙<strong>时的密码！不出意外，设置完毕后，你就可以免登录连接到云服务器的root用户了</strong></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504018.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504018.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504018"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504019.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504019.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504019"><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504020.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504020"><p><strong>这个方案只适用于<mark>单用户使用</mark>，如果多个用户想用这个方法连接同一个云服务器，就会出现大家一起用一个文件路径的问题</strong></p><hr><h3 id="Xshell登陆服务器-多用户"><a href="#Xshell登陆服务器-多用户" class="headerlink" title="Xshell登陆服务器(多用户)"></a><strong>Xshell登陆服务器(多用户)</strong></h3><p><strong>参考：</strong><a href="https://cloud.tencent.com/developer/ask/24465">腾讯云如何实现多用户登陆服务器 (tencent.com)</a></p><p><mark><strong>第一：创建新用户</strong></mark></p><p><strong>1.先用root连接终端</strong></p><blockquote><p><strong>sudo useradd -g root 用户名—这个命令的含义是在root分组下（这个是默认的分组）建立一个新的用户，用户名自定义</strong></p></blockquote><p><strong>2.然后使用这个命令设置刚刚创建的那个用户的密码</strong></p><blockquote><p><strong>sudo passwd 用户名</strong></p></blockquote><p><strong>3.随后，使用下面命令测试进入另外一个用户</strong></p><blockquote><p><strong>su - 用户名</strong></p></blockquote><p><strong>注：因为我们是从具有最高权限的root用户进入子用户，所以是不需要输入密码的，但是如果你从子用户往root跑，就需要输入root用户的密码！</strong></p><p><strong>你可以在root用户和子用户终端下用mkdir 文件夹名字创建两个不同的文件夹，ls查看当前路径下的文件夹，你会发现，root和另外一个用户直接是相互看不到对方的文件夹的，这就是我们要达到的隔离效果！相当于互不干扰！从子用户A跑到子用户B中，需要输入子用户B的密码。这需要root用户在里面创建新的用户，所以服主是知道每个用户的密码的。这就看你们的信任问题了。如果真的信不过，就让每个人进root账户，自己设置自己账户的密码，那就没啥问题了</strong></p><p><mark><strong>第二：修改密码</strong></mark></p><p><strong>实际上，在自己的用户名下，是可以更改当前用户名的密码的，所以可以让服主创建好用户后，自己登陆进去，把自己的密码改掉</strong></p><blockquote><p><strong>修改密码代码：passwd</strong></p></blockquote><p><strong>除了上面的方法外，还有一种方法可以实现多用户管理！</strong></p><p><strong>腾讯云支持多用户管理，你可以在用户组这里邀请其他人，他们就能在自己的控制台里面看到你的云服务器了</strong></p><img src="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504021.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-da-jian/20220713213504021.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220713213504021"><p><font color=red><strong>多用户方法登陆服务器不能使用SSH密钥登陆，只能使用账号密码登陆</strong></font></p><p><strong>处理办法文档：<a href="https://cloud.tencent.com/developer/article/1909909">如何远程连接服务器</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux环境搭建&quot;&gt;&lt;a href=&quot;#Linux环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Linux环境搭建&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux环境搭建&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;Linux背景介绍&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用指令与shell理解</title>
    <link href="https://not-go.github.io/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/"/>
    <id>https://not-go.github.io/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/</id>
    <published>2023-02-20T04:19:00.000Z</published>
    <updated>2023-06-23T16:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用指令与shell理解"><a href="#Linux常用指令与shell理解" class="headerlink" title="Linux常用指令与shell理解"></a><strong>Linux常用指令与shell理解</strong></h1><p><strong>插一嘴啊：我们学习Linux指令最好设置一个新的用户，直接在root下跑很容易坏！</strong></p><p><strong>&#x3D;&#x3D;其他用户切换root用户：su root&#x3D;&#x3D;</strong></p><p><strong>创建用户随后新建会话用这个ID就可以了</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626001.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626001.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626001"><p><strong>&#x3D;&#x3D;删除用户使用userdel -r 用户名 这个指令&#x3D;&#x3D;</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626002.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626002"><hr><h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a><strong>ls指令</strong></h3><blockquote><p><strong>&#x3D;&#x3D;常用：ls -a -1 其他用的很少&#x3D;&#x3D;</strong></p><p><strong><font color=red>语法：ls [选项] [目录或文件]</font></strong></p><p><strong>功能：对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息</strong></p></blockquote><p><font color=green><strong>常用选项：</strong></font></p><ul><li><p><strong>-a：列出目录下的所有文件</strong></p><blockquote><p><strong>&#x3D;&#x3D;补充：&#x3D;&#x3D;</strong></p><ol><li><strong><font color=red>在下图中我们可以看到有.和..(叫做隐藏文件)，这是因为Linux在任意目录下都会存放两个隐藏文件</font></strong></li><li><strong><code>.是当前路径</code>，<code>..是上级路径</code></strong></li></ol></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626003.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626003.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626003"></li><li><p><strong>-1：一行只输出一个文件</strong></p></li></ul><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626004.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626004.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626004"><p><strong><font color=red>其他指令不怎么用，了解就行，可以自己尝试</font></strong></p><blockquote><ul><li><p><strong>-d：将目录像文件一样显示，而不是显示其下文件</strong></p></li><li><p><strong>-i：输出文件的i节点的索引信息</strong></p></li><li><p><strong>-k：以k字节的形式表示文件大小</strong></p></li><li><p><strong>-l：列出文件的详细信息</strong></p></li><li><p><strong>-n：用数字的UID、GID代替名称</strong></p></li><li><p><strong>-F：在每个文件后附上一个字符以说明该文件类型</strong></p></li><li><p><strong>-r：对目录反向排序</strong></p></li><li><p><strong>-t：以时间排序</strong></p></li><li><p><strong>-s：在文件名后输出该文件大小</strong></p></li><li><p><strong>-R：列出所有子目录下的文件</strong></p></li></ul></blockquote><hr><h3 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a><strong>cd指令</strong></h3><blockquote><p><strong><font color=red>语法：cd 目录名</font></strong></p><p><strong>功能：改变工作目录</strong></p></blockquote><p><strong>&#x3D;&#x3D;常用：&#x3D;&#x3D;</strong></p><blockquote><p><strong>cd ..：返回上级目录</strong></p><p><strong>cd &#x2F;home&#x2F;：绝对路径</strong></p><p><strong>cd ..&#x2F;bin&#x2F;：相对路径</strong></p><p><strong>cd ~：进入用户家目录</strong></p><p><strong>cd -：返回最近访问目录</strong></p></blockquote><p><strong><font color=red>一个.(点)开头的文件是隐藏文件！</font></strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626005.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626005.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626005"><p><strong><font color=red>两个..(点)开头的文件是上级路径文件！</font></strong></p><p><strong>返回上级路径指令：cd ..</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626006.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626006.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626006"><p><strong>&#x3D;&#x3D;注意：&#x3D;&#x3D;</strong></p><p><strong>windows的路径分割符为：\ (反斜杠)</strong></p><p><strong>Linux的路径分割符为：&#x2F;（斜杠）</strong></p><p><font color=red><strong>如果我们一直cd ..那么最后就只剩下一个&#x2F;了，这个&#x2F;其实就是Linux的根目录</strong></font></p><p><strong>补充知识：Linux目录结构</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626007.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626007.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626007"><blockquote><p><strong>1.Linux的目录结构本质是一棵多叉树</strong></p><p><strong>&#x3D;&#x3D;2.每一个子节点，既可以是一个目录(再放目录或普通文件，递归式的定义)，也可以是一个普通文件&#x3D;&#x3D;</strong></p><p><strong>3.这颗多叉树的叶子节点一定是一个普通文件或空目录</strong></p><p><strong>&#x3D;&#x3D;绝对路径：从根目录开始到单一节点的路径叫绝对路径，具有唯一性，永远有效。例如：&#x2F;user&#x2F;local&#x2F;test.c&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;相对路径：从当前路径去找路径。例如：cd ..&#x2F;local&#x2F;test.c&#x3D;&#x3D;</strong></p></blockquote><ul><li><strong>-：跳转到上一个目录</strong></li></ul><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626008.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626008.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626008"><ul><li><p><strong>~：返回家目录</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626009.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626009.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626009"></li></ul><hr><h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a><strong>pwd命令</strong></h3><blockquote><p><strong><font color=red>语法：pwd</font></strong></p><p><strong>功能：显示用户当前所在的目录</strong></p><p><strong><font color=red>补充：whoami命令：用来显示用户当前身份。clear命令：清空当前屏幕</font></strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626010.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626010"><hr><h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a><strong>touch指令</strong></h3><blockquote><p><strong><font color=red>语法：touch [选项]…文件…</font></strong></p><p><strong>功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或新建一个不存在的文件</strong></p></blockquote><p><strong>&#x3D;&#x3D;常用选项：&#x3D;&#x3D;</strong></p><blockquote><p><strong>-a 或–time&#x3D;atime或–time&#x3D;access或–time&#x3D;use：只更改存取时间。</strong></p><p> <strong>-c  或–no-create：不建立任何文档。</strong> </p><p><strong>-d ：使用指定的日期时间，而非现在的时间。</strong> </p><p><strong>-f ：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</strong> </p><p><strong>-m  或–time&#x3D;mtime或–time&#x3D;modify ：只更改变动时间。</strong></p><p> <strong>-r ：把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。</strong> </p><p><strong>-t ：使用指定的日期时间，而非现在的时间</strong></p></blockquote><p><strong>&#x3D;&#x3D;touch常用来创建一个文件：&#x3D;&#x3D;</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626011.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626011.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626011"><p><strong>比如我们在test1.c下写一个Hello Linux命令：</strong></p><p><strong>第一步：用touch 创建一个test1.c，然后使用nano编译器进去编辑</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626012.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626012.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626012"><p><strong>第二步：编写代码然后按insert取消输入</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626013.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626013.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626013"><p><strong>第三步：最下面弹出选择，&#x3D;&#x3D;^符号是ctrl的意思，我们选择ctrl X保存文件&#x3D;&#x3D;，然后输入要保存目标的文件名，然后回车，&#x3D;&#x3D;最后ctrl X退出nano编译器,输入Y退出&#x3D;&#x3D;</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626014.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626014.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626014"><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626015.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626015.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626015"><p><strong>第四步：用cat命令看下自己写的代码内容，并使用gcc编译器去编辑它，然后通过.&#x2F;a.out调用编辑后的源文件</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626016.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626016.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626016"><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626017.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626017.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626017"><hr><h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a><strong>mkdir指令</strong></h3><blockquote><p><strong><font color=red>语法：mkdir [选项] dirname…</font></strong></p><p><strong>功能：在当前目录下创建一个名为dirname的目录</strong></p></blockquote><p><strong>常用选项:</strong></p><blockquote><p><strong>&#x3D;&#x3D;-p, –parents 用来创建多级路径&#x3D;&#x3D;。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录，即&#x3D;&#x3D;一次可以创立多个目录&#x3D;&#x3D;</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626018.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626018.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626018"><hr><h3 id="rmdir和rm指令"><a href="#rmdir和rm指令" class="headerlink" title="rmdir和rm指令"></a><strong>rmdir和rm指令</strong></h3><blockquote><p><strong>rmdir是一个与mkdir相对应的命令。rmdir是删除目录，mkdir是创建目录</strong></p><p><strong><font color=red>语法：rmdir [-p] [dirname]</font></strong></p><p><strong>适用对象：具有当前目录操作权限的所有使用者</strong></p><p><strong>功能：删除空目录</strong></p><p><strong><font color=red>注：rmdir只能删除空目录</font></strong></p></blockquote><p><strong>常用选项：</strong></p><blockquote><p><strong>-p：当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626019.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626019.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626019"><p><strong>这里我们会看到删除dir1提示它不为空，所以我们使用rm -r去全部删除它更加合适</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626020.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626020"><blockquote><p><strong>&#x3D;&#x3D;rm命令可以删除文件或目录&#x3D;&#x3D;</strong></p><p><strong><font color=red>语法：rm [-f-i-r-v] [dirname&#x2F;dir]</font></strong></p><p><strong>适用对象：所有使用者</strong></p><p><strong>功能：删除文件或目录</strong></p></blockquote><p><strong>常用选项：</strong></p><blockquote><p><strong>&#x3D;&#x3D;-f ：即使文件属性为只读，也直接删除（强制删除）&#x3D;&#x3D;</strong> </p><p><strong>-i ：删除前逐一询问确认</strong></p><p><strong>&#x3D;&#x3D;-r ：删除目录及其下所有文件（递归删除）&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;rm：删除普通文件&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;rm -r：递归删除目录文件&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;rm -f：强力删除&#x3D;&#x3D;</strong></p><p><strong>rm -i：删前问一下</strong></p><p><strong>&#x3D;&#x3D;补充：删根目录，rm -rf &#x2F;*&#x3D;&#x3D;</strong></p></blockquote><hr><h3 id="man指令"><a href="#man指令" class="headerlink" title="man指令"></a><strong>man指令</strong></h3><blockquote><p>**Linux的命令有很多参数，我们不可能全记住，我们可以通过查看联机手册获取帮助。访问Linux手册页的命令是 man **</p><p><strong><font color=red>语法: man [选项] 命令</font></strong></p></blockquote><p><strong>常用选项：</strong></p><blockquote><p><strong>-k：根据关键字搜索联机帮助</strong> </p><p><strong>num：只在第num章节找</strong> </p><p><strong>-a：将所有章节的都显示出来，比如man printf它缺省从第一章开始搜索，知道就停止，用a选项，当按下q退出，会继续往后面搜索，直到所有章节都搜索完毕</strong> </p><p><strong>&#x3D;&#x3D;解释一下,面手册分为8章&#x3D;&#x3D;</strong> </p><p><strong>&#x3D;&#x3D;1：是普通的命令&#x3D;&#x3D;</strong> </p><p><strong>&#x3D;&#x3D;2：是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)&#x3D;&#x3D;</strong>  </p><p><strong>&#x3D;&#x3D;3：是库函数,如printf,fread&#x3D;&#x3D;</strong></p><p><strong>4：是特殊文件,也就是&#x2F;dev下的各种设备文件</strong> </p><p><strong>5：是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义</strong> </p><p><strong>6：是给游戏留的,由各个游戏自己定义</strong></p><p><strong>7：是附件还有一些变量,比如向environ这种全局变量在这里就有说明</strong> </p><p><strong>8：是系统管理用的命令,这些命令只能由root使用,如ifconfig</strong></p></blockquote><p><strong>man手册的安装：</strong></p><p><strong>1.root用户：yum install -y man-pages</strong>  </p><p><strong>2.普通用户：sudo yum install -y man&#x3D;pages(可能会不行，切换root用户再下载)</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626021.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626021.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626021"><hr><h3 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a><strong>cp指令</strong></h3><blockquote><p><strong><font color=red>语法：cp [选项] 源文件或目录 目标文件或目录</font></strong> </p><p><strong>功能: 复制文件或目录</strong> </p><p><strong>说明: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录， 则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息</strong></p></blockquote><p><strong>常用选项：</strong></p><blockquote><p><strong>&#x3D;&#x3D;-f 或 –force：强行复制文件或目录， 不论目的文件或目录是否已经存在&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;-i 或 –interactive：覆盖文件之前先询问用户&#x3D;&#x3D;</strong> </p><p><strong>&#x3D;&#x3D;-r：递归处理，将指定目录下的文件与子目录一并处理&#x3D;&#x3D;。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理</strong> </p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626022.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626022.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626022"><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626041.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626041.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626041"><hr><h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a><strong>mv指令</strong></h3><blockquote><p><strong>&#x3D;&#x3D;mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录&#x3D;&#x3D;</strong></p><p><font color=red><strong>语法: mv [选项] 源文件或目录 目标文件或目录</strong></font></p></blockquote><p><strong>&#x3D;&#x3D;功能：剪切普通文件、整体剪切目录、重命名&#x3D;&#x3D;</strong></p><blockquote><ol><li><strong>视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中</strong></li><li><strong>&#x3D;&#x3D;当第二个参数类型是文件时，mv命令完成文件重命名&#x3D;&#x3D;，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名</strong></li><li><strong>&#x3D;&#x3D;当第二个参数是已存在的目录名称时&#x3D;&#x3D;，源文件或目录参数可以有多个，&#x3D;&#x3D;mv命令将各参数指定的源文件均移至目标目录中&#x3D;&#x3D;</strong></li></ol></blockquote><p><strong>常用选项：</strong></p><blockquote><p><strong>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</strong> </p><p><strong>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</strong></p></blockquote><p><strong><font color=red>注：Linux中不要随便删除和更改文件，因为Linux没有回收站</font></strong></p><hr><h3 id="cat与tac指令"><a href="#cat与tac指令" class="headerlink" title="cat与tac指令"></a><strong>cat与tac指令</strong></h3><blockquote><p><strong><font color=red>语法：cat [选项] [文件]</font></strong></p><p><strong>功能： 正着查看目标文件的内容</strong></p><p><strong>&#x3D;&#x3D;cat适合查看短文本和短代码&#x3D;&#x3D;</strong></p></blockquote><p><strong>常用选项：</strong></p><blockquote><p><strong>&#x3D;&#x3D;-b：对非空输出行编号&#x3D;&#x3D;</strong> </p><p><strong>&#x3D;&#x3D;-n：对输出的所有行编号&#x3D;&#x3D;</strong> </p><p><strong>-s：不输出多行空行</strong></p></blockquote><p><strong>&#x3D;&#x3D;tac：也是查看目标文件的内容，但是它是倒着查看文件内容，且它没有选项&#x3D;&#x3D;</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626023.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626023.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626023"><hr><h3 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a><strong>more指令</strong></h3><blockquote><p>**<font color=red>语法：more [选项] [文件]</font> **</p><p><strong>功能：more命令，功能类似 cat</strong> </p><p><strong>&#x3D;&#x3D;more适合查看长文本和长代码&#x3D;&#x3D;</strong></p></blockquote><p><strong>常用选项：</strong></p><blockquote><p><strong>-n：对输出的所有行编号</strong> </p><p><strong>q：退出more</strong> </p></blockquote><p><strong>&#x3D;&#x3D;首先我们先用第一行代码去生成一个1000行的hello linux在file.txt文件里，然后使用 wc -l 指令去查看有多少行&#x3D;&#x3D;</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626024.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626024.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626024"><p><strong><font color=red>使用more去查看，它只显示到把屏幕占满，如果要继续看就按enter，不看就按q：</font></strong></p><p><font color=red>&#x2F;+行号，可以直接跳转到具体的行</font></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626025.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626025.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626025"><hr><h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a><strong>less指令</strong></h3><p><strong><font color=red>less就是支持前后翻动查看，more只支持向后翻查看,cat只能打印</font></strong></p><p>这后面没什么用，看看就好了</p><blockquote><p><strong>less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极 其强大。</strong></p><p> <strong>less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看</strong> </p><p><strong>但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用 来查看一个文件的内容！</strong> </p><p><strong>除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</strong></p></blockquote><blockquote><p><strong>&#x3D;&#x3D;语法： less [参数] 文件&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;功能：less与more类似，但<code>使用less可以随意浏览文件</code>，而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件&#x3D;&#x3D;</strong></p></blockquote><p><strong>选项：</strong></p><blockquote><p><strong>-i：忽略搜索时的大小写</strong> </p><p><strong>-N：显示每行的行号 &#x2F;字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能</strong> </p><p><strong>n：重复前一个搜索（与 &#x2F; 或 ? 有关）</strong> </p><p><strong>N：反向重复前一个搜索（与 &#x2F; 或 ? 有关）</strong></p><p><strong>q：quit</strong></p></blockquote><hr><p><strong><font color=red>扩展内容：echo指令与输入输出重定向</font></strong></p><p><strong>上面的代码中，echo… &gt;</strong> </p><p><font color=red><strong>这里的&#x3D;&#x3D;&gt;&#x3D;&#x3D;被叫做&#x3D;&#x3D;输出重定向&#x3D;&#x3D;，就是说&#x3D;&#x3D;本来应该写入显示器的内容，把它写入到文件中，输出重定向会清空原始文件内容，进行重新写入&#x3D;&#x3D;</strong></font></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626026.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626026.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626026"><p><strong><font color=red>这里把上面的1000行hello Linux抹掉了，重新写入内容</font></strong></p><p>1、<font color=red><strong>对于&#x3D;&#x3D;&gt;&gt;&#x3D;&#x3D;来说：&gt;&gt;叫做&#x3D;&#x3D;追加重定向&#x3D;&#x3D;，与<code>&gt;</code>一样，但是<font color=red>它不会清空原始内容，而是在原文件结尾进行新增式写入</font></strong></font></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626027.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626027.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626027"><p>2、**<font color=red>对于cat来说：cat默认会从键盘读取输出(图中红色的就是cat打出来的)</font>**</p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626028.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626028.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626028"><p><strong>&#x3D;&#x3D;这里大家会遇到一个问题，就是无法退出它的输出！&#x3D;&#x3D;</strong></p><p><strong><font color=red>(重要!)记住！所有的阻碍你的命令操作，无脑<code>ctrl+C(杀掉程序)</code>，不敢<code>ctrl+Z(中断程序)</code></font></strong></p><p><strong>&#x3D;&#x3D;比如：我们cat并中断三次，然后用jobs查看有几个程序中断了，然后用fg 1去杀掉第一个中断程序，fg 2杀掉第二个中断程序&#x3D;&#x3D;</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626029.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626029.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626029"><p><strong>3、<font color=red>对于&lt;：<code>&lt;叫做输入重定向</code>，把本来应该从键盘文件中读取数据的方式，改成从指定文件中读取</font></strong></p><p><strong>&#x3D;&#x3D;linux下一切皆为文件！&#x3D;&#x3D;</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626030.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626030.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626030"><hr><h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a><strong>head指令</strong></h3><p><strong>&#x3D;&#x3D;head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块&#x3D;&#x3D;</strong></p><p><strong>head 用来显示档案的开头至标准输出中，而tail想当然尔就是看档案的结尾</strong> <font color=red>head默认拿头部10个，tail默认拿尾部10个</font></p><p><strong>语法： head [参数]… [文件]…</strong></p><p><strong><font color=red>功能：head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行</font></strong> </p><p><strong>选项：</strong></p><blockquote><p><strong>-n&lt;行数&gt;：显示的行数</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626031.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626031.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626031"><p><strong><font color=red>这里的|是管道的意思！</font></strong></p><p><strong>&#x3D;&#x3D;管道用来传输数据资源，什么意思呢？就是把head里运行出来的数据写入到管道里，然后tail把管道里的数据拿出来做二次加工&#x3D;&#x3D;</strong></p><p><strong><font color=red>管道级联多个命令，来完成流水线式的数据处理工作</font></strong></p><p><strong>这里head拿前900个数据，然后通过管道传输数据，然后tail只要尾部20个数据，管道的数据通过tail进行二次加工得到了从 881到900的20个数据</strong></p><hr><h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a><strong>tail指令</strong></h3><blockquote><p><strong>tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail - f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容</strong>  </p><p><strong>语法： tail[必要参数] [选择参数] [文件]</strong>  </p><p><strong>功能： 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件</strong></p></blockquote><p> <strong>选项：</strong></p><blockquote><p><strong>-f 循环读取</strong> </p><p><strong>-n&lt;行数&gt; 显示行数</strong></p></blockquote><hr><h3 id="时间指令"><a href="#时间指令" class="headerlink" title="时间指令"></a><strong>时间指令</strong></h3><blockquote><p>**date显示 **</p><p><strong>date指定格式显示时间： date +%Y:%m:%d</strong> 或 date +%Y-%m-%d </p><p><strong>date 用法：date +[OPTION]… [+FORMAT]</strong> </p></blockquote><p><strong>1.在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下</strong></p><blockquote><p><strong>%H : 小时(00..23)</strong>  </p><p><strong>%M : 分钟(00..59)</strong>  </p><p><strong>%S : 秒(00..59)</strong>  </p><p><strong>%Y : 完整年份 (0000..9999)</strong>  &#x2F;&#x2F;小写%y会丢失最前面两位，如2022丢为22</p><p><strong>%m : 月份 (01..12)</strong>  </p><p><strong>%d : 日 (01..31)</strong>   </p><p><strong>&#x3D;&#x3D;%F : 相当于 %Y-%m-%d&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;%X : 相当于 %H:%M:%S&#x3D;&#x3D;</strong></p><p><strong><font color=red>常写：date +%F_%X  显示所以时间</font></strong></p></blockquote><p><strong>2.在设定时间方面</strong></p><blockquote><p><strong>date -s &#x2F;&#x2F;设置当前时间，只有root权限才能设置，其他只能查看。</strong></p><p><strong>date -s 20080523 &#x2F;&#x2F;设置成20080523，这样会把具体时间设置成空00:00:00</strong>  </p><p><strong>date -s 01:01:01 &#x2F;&#x2F;设置具体时间，不会对日期做更改</strong> </p><p><strong>date -s “01:01:01 2008-05-23″ &#x2F;&#x2F;这样可以设置全部时间</strong> </p><p><strong>date -s “01:01:01 20080523″ &#x2F;&#x2F;这样可以设置全部时间</strong> </p><p><strong>date -s “2008-05-23 01:01:01″ &#x2F;&#x2F;这样可以设置全部时间</strong> </p><p><strong>date -s “20080523 01:01:01″ &#x2F;&#x2F;这样可以设置全部时间</strong></p></blockquote><p><strong>3.时间戳</strong></p><blockquote><p><strong>&#x3D;&#x3D;时间-&gt;时间戳转换&#x3D;&#x3D;：<code>date +%s</code></strong> </p><p><strong>&#x3D;&#x3D;时间戳-&gt;时间转换&#x3D;&#x3D;：<code>date +%F_%X -d@1508749502</code></strong> </p><p><strong>Unix时间戳（英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp）是从1970年1月1日（UTC&#x2F;GMT的 午夜）开始所经过的秒数，不考虑闰秒</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626032.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626032.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626032"><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626033.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626033.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626033"><hr><h3 id="Cal指令"><a href="#Cal指令" class="headerlink" title="Cal指令"></a><strong>Cal指令</strong></h3><p><strong>cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。“阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又叫“西历”。</strong></p><p><strong>&#x3D;&#x3D;命令格式： cal [参数]&#x2F;[月份]&#x2F;[年份]&#x3D;&#x3D;</strong></p><p><strong>功能： 用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份</strong></p><p><strong>常用选项：</strong></p><blockquote><p><strong>-3 显示系统前一个月，当前月，下一个月的月历</strong></p><p><strong>-j 显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数）</strong> </p><p><strong>-y 显示当前年份的日历</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626034.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626034.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626034"><hr><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a><strong>find指令</strong></h3><blockquote><p><strong>&#x3D;&#x3D;Linux下find命令在目录结构中搜索文件，并执行指定的操作&#x3D;&#x3D;</strong> </p><p><strong>Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下</strong> </p><p><strong>即使系统中含有网络文件系统(NFS)，find命令在该文件系统中同样有效，只你具有相应的权限</strong> </p><p><strong>在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系 统可能会花费很长的时间(这里是指30G字节以上的文件系统)</strong></p></blockquote><p><strong>语法： find pathname -options</strong></p><p><strong>功能： 用于在文件树种查找文件，并作出相应的处理（可能访问磁盘）</strong></p><p><strong>常用选项：</strong></p><blockquote><p><strong>-name  按照文件名查找文件</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626035.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626035.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626035"><hr><h3 id="grep指令"><a href="#grep指令" class="headerlink" title="grep指令"></a><strong>grep指令</strong></h3><p><strong>&#x3D;&#x3D;语法： grep [选项] 搜寻字符串文件-&#x3D;&#x3D;</strong> </p><p><strong>功能： 在文件中搜索字符串，将找到的行打印出来，grep被叫做行文本过滤工具</strong> </p><p><strong>常用选项：</strong></p><blockquote><p><strong>-i ：忽略大小写的不同，所有大小写视为相同</strong> </p><p><strong>-n ：顺便输出行号</strong> </p><p><strong>-v ：具有关键字的文本行，去掉；保留没有匹配的文本行</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626036.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626036.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626036"><hr><h3 id="zip和unzip指令"><a href="#zip和unzip指令" class="headerlink" title="zip和unzip指令"></a><strong>zip和unzip指令</strong></h3><p><strong><font color=red>语法： zip 压缩文件.zip 目录或文件</font></strong> </p><p><strong>功能： 将目录或文件压缩成zip格式</strong></p><p><strong>常用选项：</strong></p><blockquote><p><strong>&#x3D;&#x3D;-r：递归处理，将指定目录下的所有文件和子目录一并处理(即文件里面的数据一起压缩进去)&#x3D;&#x3D;</strong></p><p><strong>将test2目录&#x3D;&#x3D;压缩&#x3D;&#x3D;：zip test2.zip -d 解压路径</strong> </p><p><strong>&#x3D;&#x3D;解压&#x3D;&#x3D;到tmp目录：unzip test2.zip，&#x3D;&#x3D;压缩后如果删除了压缩文件，通过解压可以还原压缩文件&#x3D;&#x3D;</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626037.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626037.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626037"><p><strong>&#x3D;&#x3D;默认情况下(zip&#x2F;unzip test2.zip)&#x3D;&#x3D;，几乎所有的解压工具，解压出来的原始数据，都会被放在当前路径下！</strong></p><p><strong>为什么要打包压缩：1.节约空间  2.软件下载的都是压缩包，因为提供软件的人，上传的就是压缩包  3.所有的软件写好之后，不是只有一个文件</strong></p><hr><h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a><strong>tar指令</strong></h3><p><strong>&#x3D;&#x3D;tar：打包&#x2F;解包，不打开它，直接看内容&#x3D;&#x3D;</strong></p><p><strong><font color=red>一般用指定解压：tar xzf test.tgz -C 解压目录</font></strong></p><blockquote><p><strong>-c ：建立一个压缩文件的参数指令(create 的意思)；</strong> </p><p><strong>-x ：解开一个压缩文件的参数指令！</strong> </p><p><strong>-t ：查看 tarfile 里面的文件！</strong> </p><p><strong>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？</strong> </p><p><strong>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？</strong> </p><p><strong>-v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！</strong> </p><p><strong>-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！</strong> </p><p><strong>-C ：解压到指定目录</strong></p></blockquote><hr><h3 id="bc指令"><a href="#bc指令" class="headerlink" title="bc指令"></a><strong>bc指令</strong></h3><p><strong>bc命令可以很方便的进行浮点运算</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626038.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626038.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626038"><hr><h3 id="uname-r指令"><a href="#uname-r指令" class="headerlink" title="uname -r指令"></a><strong>uname -r指令</strong></h3><p><strong>语法：uname [选项]</strong>  </p><p><strong>功能： &#x3D;&#x3D;uname用来获取电脑和操作系统的相关信息&#x3D;&#x3D;</strong> </p><p><strong>补充说明：uname可显示linux主机所用的操作系统的版本、硬件的名称等基本信息</strong></p><p><strong>常用选项：</strong></p><blockquote><p><strong>-a或–all：详细输出所有信息，依次为内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626039.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626039.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626039"><p><strong>X86是主指使用的是英特尔的处理器规格，ARM主指苹果的处理器规格</strong></p><p><strong>以英特尔为例：x64对标x86_64，64位系统；x86和x86_32对标x32，32位系统</strong></p><p><strong><font color=red>补充：重要的几个热键[Tab],[ctrl]-c, [ctrl]-d</font></strong></p><blockquote><p><strong>&#x3D;&#x3D;[Tab]按键—命令自动补齐&#x3D;&#x3D;</strong> </p><p><strong>&#x3D;&#x3D;[Ctrl]-r按键—搜索历史命令&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;[Ctrl]-c按键—终止失控程序&#x3D;&#x3D;</strong> </p><p><strong>&#x3D;&#x3D;[Ctrl]-z按钮—中断当前程序&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;[Ctrl]-d按键—快速退出账户&#x3D;&#x3D;</strong></p></blockquote><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626040.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626040.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626040"><hr><h3 id="关机指令"><a href="#关机指令" class="headerlink" title="关机指令"></a><strong>关机指令</strong></h3><p><strong>语法：shutdown [选项]</strong> </p><p><strong>常见选项：</strong></p><blockquote><p><strong>-h ： 将系统的服务停掉后，立即关机。</strong> </p><p><strong>-r ： 在将系统的服务停掉之后就重新启动</strong> </p><p><strong>-t sec ： -t 后面加秒数，亦即『过几秒后关机』的意思</strong></p></blockquote><p><strong>&#x3D;&#x3D;以下命令作为扩展:&#x3D;&#x3D;</strong></p><p><strong>◆ 安装和登录命令：login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last；</strong> </p><p><strong>◆ 文件处理命令：file、mkdir、grep、dd、find、mv、ls、diff、cat、ln；</strong> </p><p><strong>◆ 系统管理相关命令：df、top、free、quota、at、lp、adduser、groupadd、kill、crontab；</strong> </p><p><strong>◆ 网络操作命令：ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、 nslookup；</strong> </p><p><strong>◆ 系统安全相关命令：passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who；</strong> </p><p><strong>◆ 其它命令：tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。</strong></p><hr><h3 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a><strong>shell命令</strong></h3><p><strong>Linux严格意义上说的是一个操作系统，我们称之为“核心（kernel）“ ，但我们一般用户，不能直接使用kernel。 而是通过kernel的“外壳”程序，也就是所谓的shell，来与kernel沟通。如何理解？为什么不能直接使用kernel？</strong></p><img src="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626042.png" class="lazyload placeholder" data-srcset="/2023/02/20/2.linux-chang-jian-zhi-ling-yu-shell-li-jie/20220807114626042.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807114626042"><p><strong><font color=red>从技术角度，Shell的最简单定义：命令行解释器（command Interpreter）主要包含：</font></strong></p><blockquote><ol><li><strong>将使用者的命令翻译给核心（kernel）处理</strong></li><li><strong>同时，将核心的处理结果翻译给使用者</strong></li></ol></blockquote><p><strong>&#x3D;&#x3D;对比windows GUI，我们操作windows 不是直接操作windows内核，而是通过图形接口，点击，从而完成我们的 操作（比如进入D盘的操作，我们通常是双击D盘盘符.或者运行起来一个应用程序）&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;shell 对于Linux，有相同的作用，主要是对我们的指令进行解析，解析指令给Linux内核。反馈结果在通过内核运行出结果，通过shell解析给用户&#x3D;&#x3D;</strong></p><blockquote><p><strong>帮助理解：如果说你是一个闷骚且害羞的程序员，那shell就像媒婆，操作系统内核就是你们村头漂亮的且有让你心动的MM小花。你看上了小花，但是有不好意思直接表白，那就让你你家人找媒婆帮你提亲，所有的事情你都直接跟媒婆沟通，由媒婆转达你的意思给小花，而我们找到媒婆姓王，所以我们叫它王婆，它对应我们常使用的bash</strong></p></blockquote><p><font color=blue><strong>Linux下，其实shell就是命令行解释器</strong></font><strong>(shell存在的目的是为了降低操作OS的成本，保护OS系统)</strong></p><p><font color=blue><strong>windous下，其实外壳就是图形化界面</strong></font></p><p><strong><font color=red>CentOs 7常用的命令行解释器(shell)，叫做bash</font></strong></p><h3 id="补充：Xshell下复制粘贴指令"><a href="#补充：Xshell下复制粘贴指令" class="headerlink" title="补充：Xshell下复制粘贴指令"></a><strong>补充：Xshell下复制粘贴指令</strong></h3><blockquote><p><strong><font color=red>Xshell下的复制粘贴指令：</font></strong></p><p><strong>&#x3D;&#x3D;复制：ctrl+insert&#x3D;&#x3D;</strong></p><p><strong>&#x3D;&#x3D;粘贴：shift+insert&#x3D;&#x3D;</strong></p><p><strong>我们也可以通过右键进行复制和粘贴</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux常用指令与shell理解&quot;&gt;&lt;a href=&quot;#Linux常用指令与shell理解&quot; class=&quot;headerlink&quot; title=&quot;Linux常用指令与shell理解&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux常用指令与shell理解&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux权限管理</title>
    <link href="https://not-go.github.io/2023/02/20/3.linux-quan-xian-guan-li/"/>
    <id>https://not-go.github.io/2023/02/20/3.linux-quan-xian-guan-li/</id>
    <published>2023-02-20T04:18:00.000Z</published>
    <updated>2023-06-23T16:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux权限管理"><a href="#Linux权限管理" class="headerlink" title="Linux权限管理"></a><strong>Linux权限管理</strong></h1><h2 id="Linux权限管理-1"><a href="#Linux权限管理-1" class="headerlink" title="Linux权限管理"></a><strong>Linux权限管理</strong></h2><p><font color=red><strong>Linux下有两种用户：超级用户（root）、普通用户</strong></font></p><blockquote><p><strong>超级用户：可以再linux系统下做任何事情，不受限制</strong> </p><p><strong>普通用户：在linux下做有限的事情</strong></p><p><strong><mark>超级用户的命令提示符是<code>“#”</code>，普通用户的命令提示符是<code>“$”</code></mark></strong></p></blockquote><p><strong><mark>命令：su [用户名]  功能：切换用户</mark>。 例如，要从root用户切换到普通用户user，则使用 su user(一般不需要输入密码)。 要从普通用户user切换到root用户则使用 su root（root可以省略，一般普通用户切换root用户都无法成功），此时系统会提示输入root用户的口令。</strong></p><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853001.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853001.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853001"><p><strong><font color=red>补充：su - 是切换为root用户命令</font></strong></p><hr><h3 id="权限访问者的分类"><a href="#权限访问者的分类" class="headerlink" title="权限访问者的分类"></a><strong>权限访问者的分类</strong></h3><blockquote><p><mark><strong>1.文件的拥有者：owner</strong></mark></p><p><mark><strong>2.文件的所属组：grouper</strong></mark></p><p><mark><strong>3.文件的其他用户：other</strong></mark></p></blockquote><p><strong>我们对于访问者进行分类是为了防止不同权限的访问者进行越级操作，从而带来系统安稳定问题全和降低开发效率问题！</strong></p><p><strong><font color=red>我们把访问者分为拥有者和其他用户就行了，为什么还要增加所属组这个访问者呢？</font></strong></p><img src="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119092950453.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119092950453.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221119092950453"><blockquote><p><strong><font color=green>原因：比如，一个公司有两个开发小组(A,B)，他们一起开发同一个项目，如果没有所属组，A组成员创建一个文件，并开放权限给自己的组员查看，那么这个文件他自己(拥有者)可以看见，B组的成员(other)也能看见。而从现实来说，A组成员是不希望B组成员看到的，所以就有了所属组这个概念。设置所属组就可以让A组成员之间看到A组的文件，而B组看不到。</font></strong></p></blockquote><hr><h3 id="文件类型与访问权限"><a href="#文件类型与访问权限" class="headerlink" title="文件类型与访问权限"></a><strong>文件类型与访问权限</strong></h3><p><strong>Linux不以后缀来区分文件类型，但是其中的编译器等工具以后缀名区分文件类型</strong></p><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853002.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853002"><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853003.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853003.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853003"><p>注：<font color=red><strong>这里的第一个pure是拥有者，第二个pure是所属组</strong></font></p><p>上面红色方框解析：文件类型：目录文件，<code>所有者(owner)</code>：可读可写可执行(rwx)；<code>用户组(grouper)</code>：可读可写可执行(rwx)；<code>其他用户(other)</code>：可读可执行(r-x)</p><p><strong>文件类型：d和-占有95％</strong>—目录文件、普通文件</p><blockquote><p><strong><code>d</code>：<mark>目录文件</mark></strong></p><p><strong><code>-</code>：<mark>普通文件(文本、源代码、可执行程序、第三方动静态库)</mark></strong> </p><p><strong>l：链接文件（类似Windows的快捷方式）</strong> </p><p><strong>b：块设备文件（例如硬盘、光驱等）</strong> </p><p>**p：管道文件 **</p><p><strong>c：字符设备文件（例如屏幕等串口设备）</strong> </p><p><strong>s：套接口文件</strong></p></blockquote><p><strong>基本权限：有字符表示和八进制表示方法(<mark>有这个权限就八进制加法得出八进制数，比如rwx&#x3D;1+2+4&#x3D;7，八进制7表示rwx权限</mark>)</strong></p><blockquote><p><strong>1、读（<code>r</code>&#x2F;<mark>4</mark>）：Read对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限</strong> </p><p><strong>2、写（<code>w</code>&#x2F;<mark>2</mark>）：Write对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限</strong> </p><p><strong>3、执行（<code>x</code>&#x2F;<mark>1</mark>）：execute对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限</strong> </p><p><strong>4、“—”表示不具有该项权限</strong></p></blockquote><hr><h3 id="文件权限值的表示方式"><a href="#文件权限值的表示方式" class="headerlink" title="文件权限值的表示方式"></a><strong>文件权限值的表示方式</strong></h3><img src="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119093839283.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119093839283.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221119093839283"><hr><h3 id="文件访问权限的相关设置方法：chmod、chown、chgrp、umask"><a href="#文件访问权限的相关设置方法：chmod、chown、chgrp、umask" class="headerlink" title="文件访问权限的相关设置方法：chmod、chown、chgrp、umask"></a><strong>文件访问权限的相关设置方法：chmod、chown、chgrp、umask</strong></h3><p><strong>Ⅰ：chmod</strong></p><p><strong><font color=red>功能：设置文件的访问权限</font></strong> </p><p><strong>格式：chmod [参数] 权限 文件名</strong></p><p><strong>常用选项：</strong></p><blockquote><p><strong>R -&gt; 递归修改目录文件的权限</strong> </p><p><strong>说明：只有文件的拥有者和root才可以改变文件的权限</strong></p></blockquote><p><strong>chmod命令权限值的定义：</strong></p><p><strong><font color=red>①用户表示符 <code>+</code> <code> -</code> <code>=</code>权限字符</font></strong></p><blockquote><p><strong>+:向权限范围增加权限代号所表示的权限</strong> </p><p><strong>-:向权限范围取消权限代号所表示的权限</strong> </p><p><strong>&#x3D;:向权限范围赋予权限代号所表示的权限用户符号：</strong>   </p><p>**<mark>u：拥有者</mark> **</p><p><strong><mark>g：拥有者同组用</mark></strong> </p><p><strong><mark>o：其它用户</mark></strong> </p><p><strong><mark>a：所有用户</mark></strong></p></blockquote><p><strong>实例：</strong></p><blockquote><p><strong># chmod u+w &#x2F;home&#x2F;abc.txt</strong> </p><p><strong># chmod o-x &#x2F;home&#x2F;abc.txt</strong></p></blockquote><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853005.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853005.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853005"><p><strong><font color=red>②修改所有权限：<code>chmod a=x /home/abc.txt</code></font></strong></p><p><strong><font color=red>③三位<code>8进制数字</code></font></strong></p><p><strong>实例：</strong></p><blockquote><p><strong># chmod 664 &#x2F;home&#x2F;abc.txt</strong> </p><p><strong># chmod 640 &#x2F;home&#x2F;abc.txt</strong></p></blockquote><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853006.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853006.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853006"><p><strong>熟记：777所有权限都有—111 111 111，000所有权限都没有—000 000 000，666去除other权限—110 110 110</strong></p><p><font color=red><strong>八进制转二进制数(一个位转2进制)，然后一一匹配位置就知道r w x的权限</strong></font></p><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853007.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853007.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853007"><hr><p><strong>Ⅱ：chown</strong></p><p><strong><font color=red>功能：修改文件的拥有者</font></strong> </p><p><strong>格式：chown [参数] 用户名 文件名</strong></p><p><strong>实例：</strong></p><blockquote><p><strong># chown user1 f1</strong> </p><p><strong># chown -R user1 filegroup1</strong></p></blockquote><p><strong>思考一下：当你想给别人东西的时候，要不要经过别人同意？</strong></p><p><strong><mark>非root用户直接使用—chown 用户名 file会报错—Operation not permitted</mark></strong></p><p><strong><mark>正确用法：sudo chown 用户名 file—这里的sudo就是提升权限的意思：以root身份去运行程序chown</mark></strong></p><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853008.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853008.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853008"><p><strong>这里提一下，为了安全性，很多linux很多都不支持直接sudo调用root权限，都要到root用户里使用！</strong></p><hr><p><strong>Ⅲ：chgrp</strong></p><p><strong><font color=red>功能：修改文件或目录的所属组</font></strong> </p><p><strong>格式：chgrp [参数] 用户组名 文件名</strong> </p><p><strong>常用选项：-R 递归修改文件或目录的所属组</strong> </p><p><strong>实例：</strong></p><blockquote><p><strong>chgrp users &#x2F;abc&#x2F;f2</strong></p></blockquote><img src="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119094701559.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119094701559.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221119094701559"><hr><p><strong>Ⅳ：umask</strong></p><p><strong><font color=red>功能： 查看或修改文件掩码</font></strong></p><ol><li><strong><code>格式：umask 权限值</code>  <font color=red>说明：将现有的存取权限<code>减去</code>权限掩码后，即可产生建立文件时预设权限</font></strong></li><li><strong><font color=green>对于减去的解释：这里的减去不是指二进制的加减，而是和<code>umask的取反结果按位与</code></font></strong></li><li><strong><mark>新建文件夹默认权限&#x3D;0666  新建目录默认权限&#x3D;0777(不同系统可能有差异)</mark> 但实际上你所创建的文件和目录，看到的权限往往不是上面这个值。原因就是创建文件或目录的时候还要受到 umask的影响。</strong></li><li>**假设默认权限是mask，则<font color=red>实际创建的出来的文件权限是: mask &amp; ~umask</font>  **</li><li><strong><mark>超级用户默认掩码值为0022</mark>，<mark>普通用户默认为0002</mark></strong></li><li><strong><mark>默认权限不是最终权限</mark></strong>—&gt;<font color=red><strong>最终权限&#x3D;默认权限 &amp; (~umask)—即：<code>默认权限和umask取反结果按位与</code></strong></font></li></ol><img src="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119094812349.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119094812349.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221119094812349"><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853009.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853009.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853009"><p><strong>实例：</strong></p><blockquote><p><strong># umask 755</strong> </p><p><strong># umask &#x2F;&#x2F;查看</strong></p><p><strong># umask 044&#x2F;&#x2F;设置</strong></p></blockquote><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853010.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853010"><hr><h3 id="file指令"><a href="#file指令" class="headerlink" title="file指令"></a><strong>file指令</strong></h3><p><strong>file指令：</strong> </p><p><strong>功能说明：辨识文件类型</strong> </p><p><strong>语法：file [选项] 文件或目录…</strong></p><p><strong>常用选项：</strong></p><blockquote><p><strong>-c 详细显示指令执行过程，便于排错或分析程序执行的情形。</strong> </p><p><strong>-z 尝试去解读压缩文件的内容。</strong></p></blockquote><img src="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853011.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/20220807233853011.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220807233853011"><hr><h3 id="目录权限理解与漏洞"><a href="#目录权限理解与漏洞" class="headerlink" title="目录权限理解与漏洞"></a><strong>目录权限理解与漏洞</strong></h3><blockquote><p><strong><font color=red><code>可读权限(w)</code>: 如果目录没有可读权限, 则无法用ls等命令查看目录中的文件内容</font></strong> </p><p><strong><font color=red><code>可写权限(r)</code>: 如果目录没有可写权限, 则无法在目录中创建文件, 也无法在目录中删除文件</font></strong></p><p><strong><font color=red><code>可执行权限(x)</code>: 如果目录没有可执行权限, 则无法cd到目录中</font></strong></p></blockquote><p><strong><mark>换句话来讲, 就是只要用户具有目录的写权限, 用户就可以删除目录中的文件, 而不论这个用户是否有这个文件的写权限</mark>。 这好像不太科学啊, 我张三创建的一个文件, 凭什么被你李四可以删掉? 我们用下面的过程印证一下</strong></p><blockquote><p><strong>[root@localhost ~]# chmod 0777 &#x2F;home&#x2F;</strong> </p><p><strong>[root@localhost ~]# ls &#x2F;home&#x2F; -ld</strong>  </p><p><strong>drwxrwxrwx. 3 root root 4096 9月 19 15:58 &#x2F;home&#x2F;</strong> </p><p><strong>[root@localhost ~]# touch &#x2F;home&#x2F;root.c</strong> </p><p><strong>[root@localhost ~]# ls -l &#x2F;home&#x2F;</strong> </p><p><strong>总用量 4</strong> </p><p><strong>-rw-r–r–. 1 root root 0 9月 19 15:58 abc.c</strong> </p><p><strong>drwxr-xr-x. 27 litao litao 4096 9月 19 15:53 litao</strong> </p><p><strong>-rw-r–r–. 1 root root 0 9月 19 15:59 root.c</strong> </p><p><strong>[root@localhost ~]# su - litao</strong>   <strong>#切换用户为litao</strong></p><p><strong>[litao@localhost ~] rm &#x2F;home&#x2F;root.c      #litao可以删除root创建的文件</strong></p><p><strong>rm：是否删除有写保护的普通空文件 “home&#x2F;root.c”? y</strong></p><p><strong>[litao@localhost ~ ]$ exit</strong></p><p><strong>logout</strong></p></blockquote><p><strong><font color=red>上面的代码证明了：其他用户不能读写你的文件，但是我可以删除你</font>。为了解决这个不科学的问题, Linux引入了粘滞位的概念</strong></p><hr><h3 id="粘滞位的理解"><a href="#粘滞位的理解" class="headerlink" title="粘滞位的理解"></a><strong>粘滞位的理解</strong></h3><p>由上面代码可知：<font color=red><strong>我们设置权限不让其他用户不能读写一个文件，这是可以的；但是防不住别人删这个文件！</strong></font></p><p><font color=green><strong>一个共享目录下，你不让我写，不让我读，但防不住我删除！因此诞生了粘滞位！</strong></font></p><p><strong>当一个目录被设置为<code>&quot;粘滞位&quot;(用chmod +t)</code>,则该目录下的文件只能由：<mark>owner和root删除，other不能删除</mark></strong></p><blockquote><p><strong>一、超级管理员(root)删除</strong> </p><p><strong>二、该目录的所有者(owner)删除</strong> </p><p><strong>三、该文件的所有者(owner)删除</strong></p></blockquote><img src="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119101919166.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-quan-xian-guan-li/image-20221119101919166.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221119101919166">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux权限管理&quot;&gt;&lt;a href=&quot;#Linux权限管理&quot; class=&quot;headerlink&quot; title=&quot;Linux权限管理&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux权限管理&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;Linux权限管理-1&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境基础开发工具使用</title>
    <link href="https://not-go.github.io/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/"/>
    <id>https://not-go.github.io/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/</id>
    <published>2023-02-20T04:17:00.000Z</published>
    <updated>2023-06-23T16:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux环境基础开发工具使用"><a href="#Linux环境基础开发工具使用" class="headerlink" title="Linux环境基础开发工具使用"></a><strong>Linux环境基础开发工具使用</strong></h1><h2 id="Linux软件包管理器-yum"><a href="#Linux软件包管理器-yum" class="headerlink" title="Linux软件包管理器 yum"></a><strong>Linux软件包管理器 yum</strong></h2><h3 id="什么是软件包"><a href="#什么是软件包" class="headerlink" title="什么是软件包"></a><strong>什么是软件包</strong></h3><blockquote><ol><li><p><strong>在Linux下安装软件, 一个通常的办法是下载到程序的源代码, 并进行编译, 得到可执行程序</strong> </p></li><li><p><strong>但是这样太麻烦了, 于是有些人把一些常用的软件提前编译好, 做成软件包(可以理解成windows上的安装程序)放在一个服务器上, 通过包管理器可以很方便的获取到这个编译好的软件包, 直接进行安装.。<mark>软件包和软件包管理器, 就好比 “App” 和 “应用商店” 这样的关系</mark></strong></p></li><li><p><strong><mark>yum(Yellow dog Updater, Modified)</mark>是Linux下非常常用的一种<mark>包管理器</mark>。 主要应用在Fedora, RedHat,  Centos等发行版上</strong></p></li></ol></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120212123716.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120212123716.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221120212123716"><hr><h3 id="了解rzsz-文件传输工具"><a href="#了解rzsz-文件传输工具" class="headerlink" title="了解rzsz(文件传输工具)"></a><strong>了解rzsz(文件传输工具)</strong></h3><p><font color=red><strong>这个工具用于 windows 机器和远端的 Linux 机器通过 XShell 传输文件—安装完毕之后可以<code>通过拖拽的方式将文件上传过去</code></strong></font></p><p><strong>关于 yum 的所有操作必须保证主机(虚拟机)网络畅通</strong></p><blockquote><p><strong><code>rzsz文件传输工具的基本使用：</code></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rz <span class="token operator">-</span>E <span class="token comment">//通过该指令可选择需要从本地机器上传到云服务器的文件</span>sz 文件夹名 <span class="token comment">//该指令可将云服务器上的文件下载到本地机器的指定文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521001.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521001.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521001"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120212909759.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120212909759.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221120212909759"><p><strong>补充：可以通过 ping 指令验证网络是否通畅</strong></p><blockquote><p><strong>ping <a href="http://www.baidu.com/">www.baidu.com</a></strong></p></blockquote><hr><h3 id="查看软件包"><a href="#查看软件包" class="headerlink" title="查看软件包"></a><strong>查看软件包</strong></h3><p><strong>通过 <font color=red>yum list 命令可以罗列出当前yum源一共有哪些软件包</font>。 由于包的数目可能非常之多, 这里我们需要使用 grep 命令只筛选出我们关注的包</strong> </p><p><strong>例如:</strong></p><blockquote><p><strong>yum list | grep lrzsz</strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120213215880.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120213215880.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221120213215880"><p><strong>结果如下:</strong> </p><blockquote><p><strong>lrzsz.x86_64 0.12.20-36.el7 @base</strong></p></blockquote><p><strong>补充信息：</strong></p><blockquote><p><strong><code>软件包名称结构</code>: 主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构</strong>  </p><p><strong><code>&quot;x86_64&quot;</code> 后缀表示64位系统的安装包, <code>&quot;i686&quot;</code> 后缀表示32位系统安装包，选择包时要和系统匹配</strong> </p><p><strong><code>&quot;el7&quot;</code> 表示操作系统发行版的版本，<code>&quot;el7&quot;</code> 表示的是 centos7&#x2F;redhat7，<code>&quot;el6&quot;</code> 表示 centos6&#x2F;redhat6</strong> </p><p><strong>最后一列, <code>base</code> 表示的是 “软件源” 的名称, 类似于 “小米应用商店”, “华为应用商店” 这样的概念.</strong></p></blockquote><hr><h3 id="安装与卸载软件指令"><a href="#安装与卸载软件指令" class="headerlink" title="安装与卸载软件指令"></a><strong>安装与卸载软件指令</strong></h3><p><strong><font color=red>通过 yum, 我们可以通过很简单的一条命令完成软件的安装：</font></strong></p><blockquote><p><strong><code>安装命令结构：sudo yum install 软件名</code></strong></p><p><strong>比如：<mark>sudo yum install lrzsz</mark>      &#x2F;&#x2F;这里的lrzsz是Linux和windows互传工具</strong></p><p><strong><code>卸载命令结构：sudo yum remove 软件名</code></strong></p><blockquote><p><strong>比如：<mark>sudo yum remove lrzsz</mark></strong></p></blockquote></blockquote><p><strong><font color=red>安装软件时，yum 会自动找到都有哪些软件包需要下载, 这时候敲 “y” 确认安装. 出现 “complete” 字样, 说明安装完成</font></strong></p><p><strong>注意事项:</strong></p><blockquote><ol><li><strong>安装软件时由于需要向系统目录中写入内容, 一般需要 sudo 或者切到 root 账户下才能完成</strong> </li><li><strong>yum安装软件只能一个装完了再装另一个</strong></li><li><strong>正在yum安装一个软件的过程中, 如果再尝试用yum安装另外 一个软件, yum会报错</strong> </li><li><strong>如果 yum 报错, 请自行百度</strong></li></ol></blockquote><hr><h3 id="更新yum源"><a href="#更新yum源" class="headerlink" title="更新yum源"></a><strong>更新yum源</strong></h3><p><strong>参考：</strong><a href="https://developer.aliyun.com/article/913404">阿里云开发者社区</a></p><p><font color=red><strong>由于不是所有人的Linux上面的yum源都是国内的链接，从而导致下载东西极其的缓慢，所以我们有时候需要更新yum源为国内的！</strong></font></p><p><strong>注：做任何配置，绝对不要先删除，一定是先备份！</strong></p><p><strong><mark>步骤：</mark></strong></p><p><font color=red><strong>1.首先进入&#x2F;etc&#x2F;yum.repos.d&#x2F;目录下，新建一个repo_bak目录，用于保存系统中原来的repo文件</strong></font></p><blockquote><p><strong>[root@VM-12-13-centos ~] # cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</strong></p><p><strong>[root@VM-12-13-centos ~] # mkdir repo_bak</strong></p><p>**[root@VM-12-13-centos ~] # mv <em>.repo repo_bak&#x2F;</em>*</p></blockquote><p><font color=red><strong>2.在CentOS中配置使用网易和阿里的开源镜像 到网易和阿里开源镜像站点下载系统对应版本的repo文件</strong></font></p><blockquote><p><strong>[root@VM-12-13-centos ~] # wget <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a></strong></p><p><strong>[root@VM-12-13-centos ~]# wget <a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></strong></p><p><strong>[root@VM-12-13-centos ~]# ls</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Centos<span class="token operator">-</span><span class="token number">7.</span>repo  CentOS<span class="token operator">-</span>Base<span class="token operator">-</span><span class="token number">163.</span>repo  repo<span class="token punctuation">.</span>bak<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><font color=red><strong>3.清除系统yum缓存并生成新的yum缓存</strong></font></p><blockquote><p><strong>[root@VM-12-13-centos ~]# ls</strong>      # 列出&#x2F;etc&#x2F;yum.repos.d&#x2F;目录下的文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Centos<span class="token operator">-</span><span class="token number">7.</span>repo  CentOS<span class="token operator">-</span>Base<span class="token operator">-</span><span class="token number">163.</span>repo  repo<span class="token punctuation">.</span>bak<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>[root@VM-12-13-centos ~]# yum clean all</strong>   # 清除系统所有的yum缓存</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Loaded plugins<span class="token operator">:</span> fastestmirror<span class="token punctuation">,</span> langpacksRepository base is listed more than once in the configurationRepository updates is listed more than once in the configurationRepository extras is listed more than once in the configurationRepository centosplus is listed more than once in the configurationCleaning repos<span class="token operator">:</span> base extras updatesCleaning up everythingCleaning up list of fastest mirrors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>[root@VM-12-13-centos ~]# yum makecache   # 生成yum缓存</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Loaded plugins<span class="token operator">:</span> fastestmirror<span class="token punctuation">,</span> langpacksRepository base is listed more than once in the configurationRepository updates is listed more than once in the configurationRepository extras is listed more than once in the configurationRepository centosplus is listed more than once in the configurationbase                                                                                  <span class="token operator">|</span> <span class="token number">3.6</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span>     extras                                                                                <span class="token operator">|</span> <span class="token number">3.4</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span>     updates                                                                               <span class="token operator">|</span> <span class="token number">3.4</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span>     <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> base<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>filelists_db                                                    <span class="token operator">|</span> <span class="token number">6.7</span> MB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span>     <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> base<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>group_gz                                                        <span class="token operator">|</span> <span class="token number">156</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span>     <span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> base<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>other_db                                                        <span class="token operator">|</span> <span class="token number">2.5</span> MB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">01</span>     <span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> base<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>primary_db                                                      <span class="token operator">|</span> <span class="token number">5.7</span> MB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span>     <span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> extras<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>prestodelta                                                   <span class="token operator">|</span>  <span class="token number">51</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">01</span>     <span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> extras<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>filelists_db                                                  <span class="token operator">|</span> <span class="token number">494</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">02</span>     <span class="token punctuation">(</span><span class="token number">7</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> extras<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>other_db                                                      <span class="token operator">|</span>  <span class="token number">86</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span>     <span class="token punctuation">(</span><span class="token number">8</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> extras<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>primary_db                                                    <span class="token operator">|</span> <span class="token number">130</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">01</span>     <span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> updates<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>prestodelta                                                  <span class="token operator">|</span> <span class="token number">406</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">01</span>     <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> updates<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>filelists_db                                                <span class="token operator">|</span> <span class="token number">2.1</span> MB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">01</span>     <span class="token punctuation">(</span><span class="token number">11</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> updates<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>other_db                                                    <span class="token operator">|</span> <span class="token number">354</span> kB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span>     <span class="token punctuation">(</span><span class="token number">12</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">:</span> updates<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>x86_64<span class="token operator">/</span>primary_db                                                  <span class="token operator">|</span> <span class="token number">3.6</span> MB  <span class="token number">00</span><span class="token operator">:</span><span class="token number">00</span><span class="token operator">:</span><span class="token number">01</span>     Determining fastest mirrorsMetadata Cache Created   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><font color=red><strong>4.测试安装</strong></font></p><blockquote><p><strong>[root@VM-12-13-centos ~]# yum install -y nginx</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Loaded plugins<span class="token operator">:</span> fastestmirrorRepository base is listed more than once in the configurationRepository updates is listed more than once in the configurationRepository extras is listed more than once in the configurationRepository centosplus is listed more than once in the configurationRepository epel is listed more than once in the configurationRepository epel<span class="token operator">-</span>debuginfo is listed more than once in the configurationRepository epel<span class="token operator">-</span>source is listed more than once in the configurationLoading mirror speeds from cached hostfilePackage <span class="token number">1</span><span class="token operator">:</span>nginx<span class="token operator">-</span><span class="token number">1.20</span><span class="token number">.1</span><span class="token operator">-</span><span class="token number">2.</span>el7<span class="token punctuation">.</span>x86_64 already installed and latest versionNothing to <span class="token keyword">do</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><hr><h2 id="Linux开发工具介绍"><a href="#Linux开发工具介绍" class="headerlink" title="Linux开发工具介绍"></a><strong>Linux开发工具介绍</strong></h2><h3 id="vi-x2F-vim开发工具介绍"><a href="#vi-x2F-vim开发工具介绍" class="headerlink" title="vi&#x2F;vim开发工具介绍"></a><strong>vi&#x2F;vim开发工具介绍</strong></h3><p><strong><mark>vi&#x2F;vim的区别简单点来说，它们都是多模式编辑器，只能用来写代码</mark>，不同的是vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。例如语法加亮，可视化操作不仅可以在终端运行，也可以运行于x window、 mac os、 windows</strong></p><p><strong><font color=red>为什么要学vim？—有时候需要我们在生成环境下，需要你快速定位问题所在，甚至需要你快速的修改代码</font></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521003.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521003.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521003"><hr><h3 id="vi-x2F-vim的按键图解"><a href="#vi-x2F-vim的按键图解" class="headerlink" title="vi&#x2F;vim的按键图解"></a><strong>vi&#x2F;vim的按键图解</strong></h3><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521002.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521002"><p><strong><font color=red>正常退出vi&#x2F;vim：shift+: q</font></strong></p><p><strong><font color=red>强制退出vi&#x2F;vim：citrl+c</font></strong></p><hr><h2 id="Linux编辑器—vim的使用"><a href="#Linux编辑器—vim的使用" class="headerlink" title="Linux编辑器—vim的使用"></a><strong>Linux编辑器—vim的使用</strong></h2><h3 id="vim的配置"><a href="#vim的配置" class="headerlink" title="vim的配置"></a><strong>vim的配置</strong></h3><p><strong>参考文章：<a href="https://github.com/wsdjeg/vim-galore-zh_cn">vim的配置全解</a></strong></p><p><strong><font color=red>快速配置命令</font>：<code>curl -sLf https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh -o ./install.sh &amp;&amp; bash ./install.sh</code></strong></p><p><strong><font color=red>快速卸载命令</font>：<code>bash ~/.VimForCpp/uninstall.sh</code></strong></p><p><strong><mark>配置后效果：</mark></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120221139237.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120221139237.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221120221139237"><hr><h3 id="vim的基本概念"><a href="#vim的基本概念" class="headerlink" title="vim的基本概念"></a><strong>vim的基本概念</strong></h3><p><strong>vim的三种模式(其实有好多模式，目前认为掌握3种即可),分别是<mark>命令行模式（command mode）</mark>、<mark>插入模式（Insert mode）</mark>和<mark>底行模式（last line mode）</mark>，各模式的功能区分如下：</strong></p><ul><li><strong><font color=red>命令行模式(Normal mode)</font></strong></li></ul><blockquote><p><strong>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode</strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521004.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521004.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521004"><ul><li><strong><font color=red>插入模式(Insert mode)</font></strong></li></ul><blockquote><p><strong>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式</strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521005.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521005.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521005"><ul><li><strong><font color=red>底行模式(last line mode)：shift+:</font></strong></li></ul><blockquote><p><strong>文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 <font color=red>在命令模式下，shift+:</font> 即可进入该模式。要查看你的所有模式：打开vim，底行模式直接输入</strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521006.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521006.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521006"><p><strong>打印一下刚输入的内容：</strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521007.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521007.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521007"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521008.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521008.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521008"><p><strong><mark>三种模式转换：</mark></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120220501282.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120220501282.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221120220501282"><p><strong><font color=red>任何模式想回到命令行模式：无脑ESC</font></strong></p><hr><p>​                                               </p><h3 id="vim的基本操作"><a href="#vim的基本操作" class="headerlink" title="vim的基本操作"></a><strong>vim的基本操作</strong></h3><ul><li><strong><font color=red>进入vim,在系统提示符号输入vim及文件名称后，就进入vim全屏幕编辑画面:</font></strong></li></ul><blockquote><p><strong>比如：<mark>$ vim test.c</mark></strong></p><p><strong>注意：进入vim后，是出于<mark>正常模式</mark>(默认模式)下的，需要切换为<mark>插入模式</mark>才可以输入内容</strong> </p></blockquote><ul><li><strong><font color=red>[正常模式]切换至[插入模式]方法：a、i、o、insert</font></strong></li></ul><blockquote><ol><li><strong>输入a</strong> </li><li><strong>输入i</strong> </li><li><strong>输入o</strong></li><li><strong>按下insert键</strong></li></ol></blockquote><ul><li><strong><font color=red>[插入模式]切换至[正常模式]方法：ESC</font></strong></li></ul><blockquote><p><strong>目前处于[插入模式]，就只能一直输入文字，如果发现输错了字,想用光标键往回移动，将该字删除，可以先按一下「ESC」键转到[正常模式]再删除文字。当然，也可以直接删除</strong></p></blockquote><ul><li><strong><font color=red>[正常模式]切换至[底行模式]方法：shift+：</font></strong></li></ul><blockquote><p><strong>「shift + ：」</strong></p></blockquote><ul><li><strong><font color=red>退出vim及保存文件,在[正常模式]下，按一下「:」冒号键进入「Last line mode」,然后：</font></strong></li></ul><blockquote><ul><li><p><strong>w （保存当前文件）</strong></p></li><li><p><strong>wq (输入「wq」,存盘并退出vim)</strong></p></li><li><p><strong>q! (输入q!,不存盘强制退出vim)</strong></p></li></ul></blockquote><hr><h3 id="vim正常模式命令集-扩展，主要看vim指令总结"><a href="#vim正常模式命令集-扩展，主要看vim指令总结" class="headerlink" title="vim正常模式命令集(扩展，主要看vim指令总结)"></a><strong>vim正常模式命令集(扩展，主要看vim指令总结)</strong></h3><ul><li><strong>插入模式(insert)</strong></li></ul><blockquote><p><strong><mark>按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件</mark></strong> </p><p><strong><mark>按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字</mark></strong> </p><p><strong><mark>按「o」进入插入模式后，是插入新的一行，从行首开始输入文字</mark></strong></p></blockquote><ul><li><strong>从插入模式切换为命令模式</strong></li></ul><blockquote><p><strong>按「ESC」键</strong></p></blockquote><ul><li><strong><code>移动光标：w(向后)、b(向前)、gg(文首)、shift+g(文末)</code></strong></li></ul><blockquote><p><strong>vim可以直接用键盘上的光标来上下左右移动，但正规的vim是用小写英文字母<mark>「h」、「j」、「k」、 「l」</mark>，分别控制光标<mark>左、下、上、右移一格</mark></strong> </p><p><strong>按「G」：移动到文章的最后</strong> </p><p><strong>按「 $ 」：移动到光标所在行的“行尾”</strong> </p><p><strong>按「^」：移动到光标所在行的“行首”</strong> </p><p><strong>按「w」：光标跳到下个字的开头</strong> </p><p><strong>按「e」：光标跳到下个字的字尾</strong> </p><p><strong>按「b」：光标回到上个字的开头</strong> </p><p><strong>按「#l」：光标移到该行的第#个位置，如：5l,56l</strong> </p><p><strong>按［gg］：进入到文本开始</strong> </p><p><strong>按［shift＋g］：进入文本末端</strong> </p><p><strong>按「ctrl」+「b」：屏幕往“后”移动一页</strong> </p><p><strong>按「ctrl」+「f」：屏幕往“前”移动一页</strong> </p><p><strong>按「ctrl」+「u」：屏幕往“后”移动半页</strong> </p><p><strong>按「ctrl」+「d」：屏幕往“前”移动半页</strong></p></blockquote><ul><li><strong><code>删除文字：x、nx、dd、ndd</code></strong></li></ul><blockquote><p><strong>「x」：删除光标所在位置的字符。每按一次，删除光标所在位置的一个字符</strong> </p><p><strong>「nx」：删除光标所在位置开始往后的n个字符。例如，「6x」表示删除光标所在位置的“后面（包含自己在内）”6个字符</strong> </p><p><strong>「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符</strong> </p><p><strong>「nX」：例如，「20X」表示删除光标所在位置的“前面”20个字符</strong> </p><p><strong>「dd」：删除光标所在行</strong> </p><p><strong>「ndd」：从光标所在行开始删除n行</strong></p></blockquote><ul><li><strong><code>复制粘贴：yy、nyy</code></strong></li></ul><blockquote><p><strong>「yw」：将光标所在位置开始到字尾的字符复制到缓冲区</strong></p><p><strong>「nyw」：将光标所在位置开始往后的n个字复制到缓冲区</strong> </p><p><strong>「yy」：复制光标所在行到缓冲区</strong></p><p><strong>「nyy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字</strong></p><p><strong>「p」：将已复制的内容在光标的下一行粘贴</strong></p><p><strong>注意：所有与“y”有关的复制命令都必须与“p”配合才能完 成复制与粘贴功能</strong></p></blockquote><ul><li><strong><code>替换：r、R</code></strong></li></ul><blockquote><p><strong>「r」：替换光标所在处的字符</strong></p><p><strong>「R」：替换光标所到之处的字符，直到按下「ESC」键为止</strong></p></blockquote><ul><li><strong><code>撤销操作：u(撤销)、ctrl+r(返回撤销)</code></strong></li></ul><blockquote><p><strong>「u」：撤销当前操作</strong></p><p><strong>「ctrl + r」: 恢复刚刚的撤销</strong></p></blockquote><ul><li><strong><code>更改：cw</code></strong></li></ul><blockquote><p><strong>「cw」：更改光标所在处的字到字尾处</strong> </p><p><strong>「c#w」：例如，「c3w」表示更改3个字</strong></p></blockquote><ul><li><strong><code>跳至指定的行：</code></strong></li></ul><blockquote><p><strong>「ctrl」+「g」列出光标所在行的行号</strong></p><p><strong>「#G」：例如，「15G」，表示移动光标至文章的第15行行首</strong></p></blockquote><hr><h3 id="vim末行模式命令集-扩展，主要看vim指令总结"><a href="#vim末行模式命令集-扩展，主要看vim指令总结" class="headerlink" title="vim末行模式命令集(扩展，主要看vim指令总结)"></a><strong>vim末行模式命令集(扩展，主要看vim指令总结)</strong></h3><p><strong>在使用末行模式之前，请记住先按「ESC」键确定您已经处于正常模式，再按「：」冒号即可进入末行模式</strong></p><ul><li><strong>列出行号</strong></li></ul><blockquote><p><strong>「set nu」: 输入「set nu」后，会在文件中的每一行前面列出行号</strong></p></blockquote><ul><li><strong>跳到文件中的某一行</strong></li></ul><blockquote><p><strong>「#」:「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15， 再回车，就会跳到文章的第15行</strong></p></blockquote><ul><li><strong>查找字符</strong></li></ul><blockquote><p><strong>「&#x2F;关键字」: 先按「&#x2F;」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 「n」会往后寻找到您要的关键字为止</strong></p><p><strong>「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直 按「n」会往前寻找到您要的关键字为止</strong></p></blockquote><ul><li><strong>保存文件：w(保存文件)</strong></li></ul><blockquote><p>「w」: 在冒号输入字母「w」就可以将文件保存起来</p></blockquote><ul><li><strong>离开vim：q(退出)、wq(保存退出)</strong></li></ul><blockquote><p><strong>「q」：按「q」就是退出，如果无法离开vim，可以在「q」后跟一个「!」强制离开vim</strong></p><p><strong>「wq」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件</strong></p></blockquote><hr><h3 id="常用vim指令总结"><a href="#常用vim指令总结" class="headerlink" title="常用vim指令总结"></a><strong>常用vim指令总结</strong></h3><p><strong><mark>个人觉得下面的图片的指令就够日常使用了：</mark></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120220925086.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/image-20221120220925086.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221120220925086"><blockquote><p><strong>yy：复制当前行，nyy(数字n+yy)：复制第一行n次，nyy(数字n+yy)：复制n行1次</strong></p><p><strong>p：粘贴当前行的后面，np：粘贴n次</strong></p><p><strong>dd：剪切(删除)当前行，ndd：删除n行</strong></p><p><strong>u：撤销刚刚的操作</strong></p><p><strong>ctrl+r：针对u操作，再次进行撤销</strong></p><p><strong>shift+g：快速将光标定位到<mark>文本的结束</mark></strong></p><p><strong>gg：快速讲光标定位到<mark>文本的开始</mark></strong></p><p><strong>n+shift+g：光速快速定位到文本的任意一行</strong></p><p><strong>shift+4：$光标快速定位到<mark>本行文本结束</mark></strong>   注：$和^称为锚点</p><p><strong>shift+6：^光标快速定位到<mark>本行文本开始</mark></strong></p><p><strong>w：以单词为间距后移光标    b：以单词为间距前移光标</strong></p><p><strong>h j k l：左下上右</strong></p><p><strong>shift+ ~（波浪号）：大小写切换快速切换</strong></p><p><strong>r：替换光标所在的字符，支持hr</strong></p><p><strong>shift+r：批量化替换</strong></p><p><strong>x：删除光标所在的字符，nx</strong></p><p><strong>shift+q：底行模式</strong></p></blockquote><hr><h2 id="Linux编辑器—gcc-x2F-g-的使用"><a href="#Linux编辑器—gcc-x2F-g-的使用" class="headerlink" title="Linux编辑器—gcc&#x2F;g++的使用"></a><strong>Linux编辑器—gcc&#x2F;g++的使用</strong></h2><h3 id="gcc的完成过程：预处理、编译、汇编、链接"><a href="#gcc的完成过程：预处理、编译、汇编、链接" class="headerlink" title="gcc的完成过程：预处理、编译、汇编、链接"></a><strong>gcc的完成过程：预处理、编译、汇编、链接</strong></h3><p><strong><code>巧计：ESc</code> —<code>预处理、编译、汇编过程(巧记：iso)</code>—链接：gcc test.o -o test</strong></p><p><font color=red><strong>1.预处理(进行宏替换)</strong></font></p><blockquote><p><strong><mark>预处理功能主要包括</mark>：<mark>宏定义</mark>,<mark>头文件展开</mark>,<mark>条件编译</mark>,<mark>去注释</mark>等</strong></p><p><strong>预处理指令是以#号开头的代码行</strong></p><p><strong>实例:  <mark>gcc –E test.c –o test.i</mark></strong> </p><p><strong><code>选项“-E”,该选项的作用是让 gcc 在预处理结束后停止编译过程</code></strong> </p><p><strong><code>选项“-o”是指目标文件</code></strong></p><p><strong><code>“.i”文件为已经过预处理的C原始程序</code></strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521010.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521010"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521011.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521011.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521011"><p><strong>从上图可以知道：编译器必须通过一定的方式，知道头文件的位置</strong></p><p><strong><mark>头文件存放位置：ls &#x2F;usr&#x2F;include</mark></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521012.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521012.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521012"><p><strong>底行模式直接分屏打开文件：shift+：vs 文件名，比如：<mark>shift+： vs test.c</mark></strong></p><p><strong>分屏切换：ctrl+w+w 左右屏幕切换光标</strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521013.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521013.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521013"><p><font color=red><strong>2.编译(生成汇编)</strong></font>：<strong>将C语言编译成为汇编语言</strong></p><blockquote><p><strong>在这个阶段中，gcc 首先要检查代码的规范性、是否有语法错误等,以确定代码的实际要做的工作,在检查 无误后,gcc 把代码翻译成汇编语言</strong></p><p><strong>用户可以使用“-S”选项来进行查看,该选项只进行编译而不进行汇编,生成汇编代码</strong></p><p><strong>实例: <mark>gcc –S test.i –o test.s</mark></strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521014.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521014.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521014"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521015.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521015.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521015"><p><font color=red><strong>3.汇编(生成机器可识别代码)</strong></font>：<strong>将汇编语言翻译成可执行的二进制文件.o&#x2F;.obj</strong></p><blockquote><p><strong>汇编阶段是把编译阶段生成的“.s”文件转成目标文件</strong> </p><p><strong>读者在此可使用选项“-c”就可看到汇编代码已转化为“.o”的二进制目标代码了</strong> </p><p><strong>实例: <mark>gcc –c test.s –o test.o</mark></strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521016.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521016.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521016"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521017.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521017.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521017"><p>这里看test.o二进制是乱码，可以使用二进制查看器来查看二进制码—<mark>命令od test.o</mark>—<strong>二进制文件不是可执行文件</strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521018.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521018.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521018"><p><font color=red><strong>4.链接(生成可执行文件或库文件)</strong></font><strong>：将代码与库的代码关联起来</strong></p><blockquote><p><strong>在成功编译之后,就进入了链接阶段</strong></p><p><font color=red><strong>链接隐含的就是链接我们自己的程序和库，形成可执行程序！</strong></font></p><p><strong>实例: <mark>gcc test.o –o test</mark></strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521019.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521019.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521019"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521020.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521020"><hr><h3 id="gcc选项"><a href="#gcc选项" class="headerlink" title="gcc选项"></a><strong>gcc选项</strong></h3><blockquote><p><strong>-E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面</strong> </p><p><strong>-S 编译到汇编语言不进行汇编和链接</strong> </p><p><strong>-c 编译到目标代码</strong> </p><p><strong>-o 文件输出到 文件 -static 此选项对生成的文件采用静态链接</strong> </p><p><strong>-g 生成调试信息。GNU 调试器可利用该信息。</strong> </p><p><strong>-shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.</strong> </p><p>**-O0 -O1 -O2 -O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 **</p><p>**-w 不生成任何警告信息。 **</p><p><strong>-Wall 生成所有警告信息</strong></p></blockquote><hr><h2 id="Linux调试器—gdb使用"><a href="#Linux调试器—gdb使用" class="headerlink" title="Linux调试器—gdb使用"></a><strong>Linux调试器—gdb使用</strong></h2><h3 id="gdb调试器的背景"><a href="#gdb调试器的背景" class="headerlink" title="gdb调试器的背景"></a><strong>gdb调试器的背景</strong></h3><blockquote><p><strong><code>程序的发布方式有两种：debug模式和release模式</code></strong> </p><p><strong><font color=red>Linux gcc&#x2F;g++出来的二进制程序，默认是release模式</font></strong> </p><p><strong><mark>要使用gdb调试，必须在源代码生成二进制程序的时候, 加上 -g 选项(也就是切换成debug模式)</mark></strong></p></blockquote><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521022.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521022.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521022"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521023.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521023.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521023"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521024.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521024.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521024"><p><strong>gdb调试方法：</strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521025.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521025.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521025"><hr><h3 id="gbk的使用"><a href="#gbk的使用" class="headerlink" title="gbk的使用"></a><strong>gbk的使用</strong></h3><p><font color=red><strong>核心命令：b、d、s、n，info b</strong></font></p><blockquote><p><strong>b 行号：打断点</strong></p><p><strong>d 断点编号：取消断点</strong></p><p><strong>l 行号：显示代码</strong></p><p><strong>s：逐语句(进入函数)</strong></p><p><strong>n：逐过程</strong></p><p><strong>display：常显示</strong></p><p><strong>undisplay：取消常显示</strong></p><p><strong>until 行号：跳转指定行</strong></p><p><strong>r：运行程序(前提打断点不然直接运行完了)</strong></p><p><strong>c：从一个断点跳转到另一个断点</strong></p><p><strong>finish：执行完成一个函数就停下来</strong></p></blockquote><p><strong>基本命令：</strong></p><blockquote><p><strong>list或l 行号：显示binFile源代码，接着上次的位置往下列，每次列10行。</strong> </p><p><strong>list或l 函数名：列出某个函数的源代码。</strong> </p><p><strong>r或run：运行程序。</strong> </p><p><strong>n 或 next：单条执行。</strong> </p><p><strong>s或step：进入函数调用</strong> </p><p><strong>break或b 行号：在某一行设置断点</strong> </p><p><strong>break 函数名：在某个函数开头设置断点</strong> </p><p><strong>info break ：查看断点信息。</strong> </p><p><strong>finish：执行到当前函数返回，然后挺下来等待命令</strong> </p><p><strong>print(p)：打印表达式的值，通过表达式可以修改变量的值或者调用函数</strong></p><p><strong>p 变量：打印变量值。</strong> </p><p><strong>set var：修改变量的值</strong> </p><p><strong>continue(或c)：从当前位置开始连续而非单步执行程序</strong> </p><p><strong>run(或r)：从开始连续而非单步执行程序</strong> </p><p><strong>delete breakpoints：删除所有断点</strong> </p><p><strong>delete breakpoints n：删除序号为n的断点</strong> </p><p><strong>disable breakpoints：禁用断点</strong> </p><p><strong>enable breakpoints：启用断点</strong> </p><p><strong>info(或i) breakpoints：参看当前设置了哪些断点</strong> </p><p><strong>display 变量名：跟踪查看一个变量，每次停下来都显示它的值</strong> </p><p><strong>undisplay：取消对先前设置的那些变量的跟踪</strong> </p><p><strong>until X行号：跳至X行</strong> </p><p><strong>breaktrace(或bt)：查看各级函数调用及参数</strong> </p><p><strong>info（i) locals：查看当前栈帧局部变量的值</strong> </p><p><strong>quit：退出gdb</strong></p></blockquote><hr><h2 id="函数库概念"><a href="#函数库概念" class="headerlink" title="函数库概念"></a><strong>函数库概念</strong></h2><p><font color=red><strong>头文件：给我们提供了可使用的方法，所有的开发环境，具有语法提示，本质是通过头文件帮我们搜索的</strong></font></p><p><font color=red><strong>库文件：给我们提供了可使用的方法的实现，以供链接，形成我们自己的可执行程序</strong></font></p><blockquote><p>**我们的C程序中，并没有定义“printf”的函数实现,且在预编译中包含的“stdio.h”中也只有该函数的声明,而 没有定义函数的实现,那么,是在哪里实“printf”函数的呢? **</p><p><strong>最后的答案是:系统把这些函数实现都被做到名为 libc.so.6 的库文件中去了,在没有特别指定时,gcc 会到 系统默认的搜索路径“&#x2F;usr&#x2F;lib”下进行查找,也就是链接到 libc.so.6 库函数中去,这样就能实现函数“printf”了,而这也就是链接的作用</strong></p></blockquote><p><strong><font color=red>函数库一般分为静态库(静态链接)和动态库(动态链接)两种：</font></strong></p><p>①<strong>动态库：<code>Linux(.so)</code>、<code>windows(.dll)</code>—<font color=red>动态链接—优点：大家共享一个库(只有一个库)，可以节约资源—缺点：库缺失，导致几乎所有程序失效</font></strong></p><p>②<strong>静态库：<code>Linux(.a)</code>、<code>windows(.lib)</code>—<font color=red>静态链接—将库中相关代码，直接拷贝到自己的可执行程序中(多个重复库)—优点：不依赖任何库，程序可以独立执行—缺点：浪费资源</font></strong></p><p>tips：大家所说的删库跑路就是说的动态库，公司为了节约资源使用动态库，你把库删了，大部分程序就直接崩，你基本就进局子了</p><p><strong>默认情况下，形成的可执行程序都是动态链接的！</strong></p><p><strong><mark>补充：Linux下安装C&#x2F;C++静态库工具命令</mark></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521021.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521021.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521021"><hr><h2 id="Linux缓冲区理解"><a href="#Linux缓冲区理解" class="headerlink" title="Linux缓冲区理解"></a><strong>Linux缓冲区理解</strong></h2><h3 id="缓冲区的理解"><a href="#缓冲区的理解" class="headerlink" title="缓冲区的理解"></a><strong>缓冲区的理解</strong></h3><p><strong><font color=red>缓冲区是内存空间的一部分</font>。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区</strong></p><blockquote><p><strong><mark>为什么要引入缓冲区呢?</mark></strong></p><ol><li><strong><font color=red>比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故<code>应用缓冲区可大大提高计算机的运行速度</code></font></strong></li><li><strong><font color=red>又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。现在您基本明白了吧，<code>缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据</code>。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作</font></strong></li></ol></blockquote><blockquote><p><strong><font color=red>缓冲区的类型：</font></strong></p><ol><li><strong><code>全缓冲</code>：在这种情况下，当<mark>填满标准I&#x2F;O缓存后才进行实际I&#x2F;O操作</mark>。全缓冲的典型代表是<mark>对磁盘文件的读写</mark></strong></li><li><strong><code>行缓冲</code>：在这种情况下，当在输入和输出中<mark>遇到换行符\n时，执行真正的I&#x2F;O操作</mark>。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I&#x2F;O操作。典型代表是<mark>键盘输入数据</mark></strong></li><li><strong><code>不带缓冲</code>：也就是不进行缓冲，<mark>标准出错情况stderr</mark>是典型代表，这使得出错信息可以直接尽快地显示出来</strong></li></ol></blockquote><blockquote><p><strong><font color=green>缓冲区的刷新情况：</font></strong></p><ol><li><strong><mark>缓冲区满时，自动刷新缓冲区</mark></strong></li><li><strong><mark>执行flush语句</mark></strong></li><li><strong><mark>执行endl语句，相当于\n</mark></strong></li><li><strong><mark>关闭文件</mark></strong></li></ol></blockquote><hr><h3 id="显示缓冲区的方法"><a href="#显示缓冲区的方法" class="headerlink" title="显示缓冲区的方法"></a><strong>显示缓冲区的方法</strong></h3><p><font color=red><strong>显示缓冲区的方法：</strong></font></p><blockquote><p><strong><font color=red>立马将内存中的空间显示出来的方法：刷新策略，即行刷新\n【输入的字符串是否是完整的一行，即缓冲区换码，程序退出，遇到换行符\n就刷新出去】</font></strong></p><p><strong><code>扩展：\n、\r、enter的区别</code></strong></p><ol><li><strong><code>\n： 换行，使光标下移一格</code></strong></li><li><strong><code>\r： 回车，使光标回到本行行首</code></strong></li><li><strong><code>enter：换行并回车，使光标移动到以下一格行首</code></strong></li></ol><p><strong><mark>如果是\r，则不会刷新出缓冲区，不会显示出内容</mark></strong></p><p><strong><mark>不想用\n让数据立马刷新—加入函数fflush(stdout);—直接刷新</mark></strong></p><p><strong>举例：</strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521035.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521035.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521035"><p><strong><mark>从以下代码执行可以明显看出，是先执行了sleep再执行的打印</mark></strong></p><p><strong><font color=red>因为打印内容被放入了缓冲区，判断其不是完整的一行，就继续执行了sleep，然后等整个程序读完了，才放出缓冲区的打印内容</font></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/2022080909152110.gif" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/2022080909152110.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="2022080909152110"><p><strong><mark>fflush直接刷新缓冲区：</mark></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521036.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521036.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521036"><p><strong><font color=red>从下面图片可以看到，是先打印了，然后sleep等待了1s才显示的用户命令</font></strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/2022080909152112.gif" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/2022080909152112.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="2022080909152112"></blockquote><hr><h3 id="进度条程序"><a href="#进度条程序" class="headerlink" title="进度条程序"></a><strong>进度条程序</strong></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">char</span> bar<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//100个#+1个\n，只要大于等于101就行</span>     <span class="token function">memset</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>lable<span class="token operator">=</span><span class="token string">"|/-\\"</span><span class="token punctuation">;</span><span class="token comment">//进度运行符号：/ - \     while(i &lt;= 100 )</span>     <span class="token punctuation">&#123;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%-100s][%d%%][%c]\r"</span><span class="token punctuation">,</span> bar<span class="token punctuation">,</span> i<span class="token punctuation">,</span> lable<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//i%4让进度运行符号循环打印</span>         <span class="token comment">//100s：缓冲区预留100个空间字符串，C语言对齐方式从右往左打，所以要用-100s</span>         <span class="token comment">//%d打印进度数字，%d%%就是显示一个%符号</span>         <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         bar<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>         <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//usleep单位：微秒</span> <span class="token punctuation">&#125;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>优化一下：</strong></p><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521037.png" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521037.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521037"><img src="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521113.gif" class="lazyload placeholder" data-srcset="/2023/02/20/3.linux-huan-jing-ji-chu-kai-fa-gong-ju-shi-yong/20220809091521113.gif" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220809091521113"></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux环境基础开发工具使用&quot;&gt;&lt;a href=&quot;#Linux环境基础开发工具使用&quot; class=&quot;headerlink&quot; title=&quot;Linux环境基础开发工具使用&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux环境基础开发工具使用&lt;/strong&gt;&lt;/h1&gt;&lt;h2 </summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux项目自动化工具工具-make/Makefile</title>
    <link href="https://not-go.github.io/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/"/>
    <id>https://not-go.github.io/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/</id>
    <published>2023-02-20T04:16:00.000Z</published>
    <updated>2023-06-23T16:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux项目自动化构建工具-make-x2F-Makefile"><a href="#Linux项目自动化构建工具-make-x2F-Makefile" class="headerlink" title="Linux项目自动化构建工具-make&#x2F;Makefile"></a><strong>Linux项目自动化构建工具-make&#x2F;Makefile</strong></h1><h2 id="make-x2F-Makefile背景"><a href="#make-x2F-Makefile背景" class="headerlink" title="make&#x2F;Makefile背景"></a><strong>make&#x2F;Makefile背景</strong></h2><blockquote><ol><li><p><strong>会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力</strong> </p></li><li><p><strong>一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作 makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编 译，极大的提高了软件开发的效率</strong></p></li><li><p><strong>make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命 令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一 种在工程方面的编译方法</strong> </p></li><li><p><strong>make是一条命令，makefile是一个文件(内容包含 的是依赖关系和依赖方法)，两个搭配使用，完成项目自动化构建</strong></p></li></ol></blockquote><hr><h2 id="make原理"><a href="#make原理" class="headerlink" title="make原理"></a><strong>make原理</strong></h2><blockquote><ol><li><strong>make会在当前目录下找名字叫“Makefile”或“makefile”的文件</strong> </li><li><strong>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“test”这个文件， 并把这个文件作为最终的目标文件</strong></li><li><strong>如果test文件不存在，或是test所依赖的后面的test.o文件的文件修改时间要比test这个文件新（可以用 touch 测试），那么，他就会执行后面所定义的命令来生成test这个文件</strong></li><li><strong>如果<mark>test所依赖的test.o文件不存在，那么make会在当前文件中找目标为test.o文件的依赖性</mark>，如果找到则再根据那一个规则生成test.o文件（这有点像一个堆栈的过程）</strong> </li><li><strong>当然，你的C文件和H文件是存在的啦，于是make会生成 test.o 文件，然后再用 test.o 文件声明 make的终极任务，也就是执行文件test了</strong> </li><li><strong>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件</strong></li><li><strong>在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错， 而对于所定义的命令的错误，或是编译不成功，make根本不理</strong></li><li><strong>make只管文件的依赖性，即如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦</strong></li></ol></blockquote><hr><h3 id="依赖关系与伪目标概念"><a href="#依赖关系与伪目标概念" class="headerlink" title="依赖关系与伪目标概念"></a><strong>依赖关系与伪目标概念</strong></h3><blockquote><p><strong>关于依赖关系的理解：</strong></p><ol><li><p><strong><font color=red>依赖关系：代表了两个文件之间的一种隐性的关系，这决定了我们能不能这样做</font></strong></p></li><li><p><strong><font color=red>伪目标：伪目标由关键字.PHONY修饰，作用是表明目标可以一直被执行，并且为目标后面不要跟关系</font></strong></p><img src="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/image-20221120232828467.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/image-20221120232828467.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221120232828467"></li></ol><p><strong><mark>思考：什么是可以总是被执行，什么是不可以总是被执行？</mark></strong></p><p><strong>简言之：就是可以重复执行，有点像<mark>良好的SQL语句</mark>那种</strong></p><img src="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/image-20221120233543447.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/image-20221120233543447.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221120233543447"></blockquote><p><strong><font color=red>模拟使用make&#x2F;Makefile：</font></strong></p><p><strong><code>1.我们这里先创建一个Makefile文件，然后再里面写下其功能：</code></strong></p><img src="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242001.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242001.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220810115242001"><p><strong><code>2.这里的&quot;test:test.c&quot;决定了下面的gcc定义的文件名必须为test，从而进行依赖</code></strong></p><img src="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242002.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220810115242002"><p><strong><code>3.我们使用make命令就可以调用Makefile了，从而生成了一个test文件</code></strong></p><img src="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242003.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242003.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220810115242003"><p><strong>有了Makefile以后使用make就可以直接编译目标文件了</strong>—<mark>有宏定义那味道了</mark></p><img src="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242004.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242004.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220810115242004"><hr><h3 id="自动项目清理命令"><a href="#自动项目清理命令" class="headerlink" title="自动项目清理命令"></a><strong>自动项目清理命令</strong></h3><blockquote><ol><li><strong>工程是需要被清理的</strong></li><li><strong>像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行， 不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译</strong></li><li><strong>但是一般我们这种clean的目标文件，我们将它设置为伪目标，用 .PHONY 来修饰，而伪目标的特性是总是被执行的</strong></li><li><strong>如果大家有兴趣可以将 mytest 目标文件声明成伪目标，测试一下</strong></li></ol><p><strong><mark>补充：.PHONY：—可以理解为Makefile中的一个关键字，后面跟的都叫做伪目标—伪目标总是被执行的</mark></strong></p></blockquote><img src="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242005.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242005.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220810115242005"><p><strong>使用make clean就可以直接清除目标文件了</strong>—<mark>有宏定义那味道了</mark></p><img src="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242006.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-xiang-mu-zi-dong-hua-gou-zao-gong-ju/20220810115242006.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220810115242006">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux项目自动化构建工具-make-x2F-Makefile&quot;&gt;&lt;a href=&quot;#Linux项目自动化构建工具-make-x2F-Makefile&quot; class=&quot;headerlink&quot; title=&quot;Linux项目自动化构建工具-make&amp;#x2F;Mak</summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程概念</title>
    <link href="https://not-go.github.io/2023/02/20/4.linux-jin-cheng-gai-nian/"/>
    <id>https://not-go.github.io/2023/02/20/4.linux-jin-cheng-gai-nian/</id>
    <published>2023-02-20T04:15:00.000Z</published>
    <updated>2023-06-23T16:57:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux进程概念"><a href="#Linux进程概念" class="headerlink" title="Linux进程概念"></a>Linux进程概念</h1><h2 id="进程的理解"><a href="#进程的理解" class="headerlink" title="进程的理解"></a><strong>进程的理解</strong></h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a><strong>进程的概念</strong></h3><p><strong><mark>基本概念：</mark></strong></p><blockquote><ul><li><strong><code>操作系统理论概念：程序的一个执行实例，正在执行的程序等</code></strong> </li><li><strong><code>Linux内核观点：担当分配系统资源（CPU时间，内存）的实体</code></strong></li><li><font color=red><strong>核心理解：进程&#x3D;可执行程序+该进程对应的内核数据结构</strong></font></li></ul></blockquote><p><strong><mark>进程控制块(PCB)的理解：</mark></strong></p><blockquote><ul><li><strong><font color=red>进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合</font></strong></li><li><strong><mark>操作系统理论上</mark>称之为<code>PCB（process control block）</code>，<mark>Linux操作系统下</mark>的PCB是: <code>task_struct</code></strong></li><li><strong>凡是提到进程，必须首先想到进程task_struct(PCB)</strong></li><li><strong><mark>PCB是操作系统描述进程的一个统称</mark>。当可执行程序加载到内存，是运行了一个进程。实际的大小要比文件本身要大。操做系统管理进程要先对进程进行描述，会添加一些属性(所以比本身文件大)，属性包括描述信息+内容代码数据等</strong></li><li><strong>操作系统允许多个进程同时允许，为了方便管理，操作系统还会将进程组织起来，一般是组织成一个<mark>双向链表的数据结构</mark>，如下图：</strong></li></ul><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121221804073.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121221804073.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221121221804073"></blockquote><hr><h3 id="task-struct与PCB的区别"><a href="#task-struct与PCB的区别" class="headerlink" title="task_struct与PCB的区别"></a><strong>task_struct与PCB的区别</strong></h3><ul><li><strong><mark>PCB是操作系统描述进程的一个统称</mark></strong></li><li><strong><mark>task_struct是</mark>Linux下<mark>描述进程的结构体</mark>，<mark>是Linux内核的一种数据结构</mark>，它会被装载到内存里并且包含进程的信息</strong></li></ul><hr><h3 id="task-struct的内容分类-了解"><a href="#task-struct的内容分类-了解" class="headerlink" title="task_struct的内容分类(了解)"></a><strong>task_struct的内容分类(了解)</strong></h3><p><strong><font color=red>task_ struct内容分类：</font></strong></p><blockquote><p><strong><mark>标示符: 描述本进程的唯一标示符，用来区别其他进程</mark></strong></p><p><strong><mark>状态: 任务状态，退出代码，退出信号等</mark></strong></p><p><strong><mark>优先级: 相对于其他进程的优先级</mark></strong></p><p><strong><mark>程序计数器: 程序中即将被执行的下一条指令的地址</mark></strong></p><p><strong><mark>内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</mark></strong></p><p><strong><mark>上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]</mark></strong> </p><p><strong><mark>I／O状态信息: 包括显示的I&#x2F;O请求,分配给进程的I／O设备和被进程使用的文件列表</mark></strong></p><p><strong><mark>记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等</mark></strong></p><p><strong><mark>其他信息</mark></strong></p></blockquote><hr><h3 id="组织进程和查看进程的方法"><a href="#组织进程和查看进程的方法" class="headerlink" title="组织进程和查看进程的方法"></a><strong>组织进程和查看进程的方法</strong></h3><p><strong><mark>查看进程：进程的信息可以通过 <code>/proc 系统文件夹</code>查看</mark></strong></p><p><strong><mark>如果要获取PID为1的进程信息，你需要查看 &#x2F;proc&#x2F;1 这个文件夹</mark></strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121223146465.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121223146465.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221121223146465"><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121223307031.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121223307031.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221121223307031"><p><strong><mark>大多数进程信息也可以使用top和ps这些用户级工具获取</mark></strong></p><blockquote><p><strong><font color=red>单独使用ps命令，会显示所有进程信息：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ps aux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><font color=red>ps命令与grep命令搭配使用，即可只显示某一进程的信息：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ps aux <span class="token operator">|</span> head <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> ps aux <span class="token operator">|</span> grep proc <span class="token operator">|</span> grep <span class="token operator">-</span>v grep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121224532840.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121224532840.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221121224532840"></blockquote><blockquote><ol><li><strong>可以使用命令 <code>kill -9 pid</code>  <mark>杀死进程</mark></strong></li><li><strong>proc文件：内存文件系统—当前系统实时的进程信息</strong></li><li><strong><mark>每一个进程</mark>在系统中，存在一个<mark>唯一的标识符PID</mark></strong></li></ol></blockquote><hr><h3 id="进程标识符的获取方法"><a href="#进程标识符的获取方法" class="headerlink" title="进程标识符的获取方法"></a><strong>进程标识符的获取方法</strong></h3><p><strong><code>方法一：通过getpid()、getppid()函数获取</code></strong></p><blockquote><p><strong>通过系统调用获取进程标示符：</strong></p><ol><li><strong><font color=red><code>子进程</code>标识符(<code>PID</code>)：getpid()</font></strong></li><li><strong><font color=red><code>父进程</code>标识符(<code>PPID</code>)：getppid()</font></strong></li></ol></blockquote><p><strong><mark>举例代码：</mark></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pid: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ppid: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121225809663.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121225809663.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221121225809663"><hr><p><code>方法二：通过fork()函数获取</code></p><blockquote><p><strong><font color=red>前提知识：</font></strong></p><ol><li><strong><mark>fork是一个系统调用级别的函数，其功能就是创建一个子进程</mark></strong></li><li><strong><font color=red>fork执行一次，有两个返回值</font>，<code>父进程返回子进程PID</code>，<code>子进程返回0</code></strong> </li><li><strong><mark>父子进程代码共享，数据各自开辟空间，私有一份（采用写时拷贝）</mark></strong></li></ol></blockquote><p><font color=red><strong>举例代码：打印父子进程pid：</strong></font></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span>   <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">pid_t</span> id<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//理论上：id:0 子进程  id>0 父进程</span>     <span class="token comment">//实际上：子进程、父进程各自得到一个id进行条件判断</span>     <span class="token comment">//父进程得到的变量id是子进程pid，子进程得到的id是0</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span>mark<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>       <span class="token comment">//child</span>       <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>       <span class="token punctuation">&#123;</span>          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是子进程,我的pid:%d,我的父进程是:%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">else</span>      <span class="token punctuation">&#123;</span>        <span class="token comment">//parent</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是父进程，我的pid:%d,我的父进程是:%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722002.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220815131722002"><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722001.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722001.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220815131722001"><blockquote><p><strong><font color=green>奇怪的现象：</font></strong></p><ul><li><strong><mark>这里遇到了一个奇怪的问题：这里的if和else同时执行了，进行了两次printf打印，并没有受到条件的约束，为什么呢？</mark></strong></li><li><strong><font color=red>首先我们思考，C语言上if 和else if可以同时执行嘛？当然不可以。有没有可能两个以上死循环？当然不可以</font></strong></li><li><strong><font color=red>但是这里却发现Linux下可以！</font></strong></li></ul></blockquote><p><font color=red><strong>出现这个现象的原因：</strong></font></p><blockquote><p><strong><code>fork之后，父进程和子进程会共享代码，也就是写时拷贝了代码</code>（<mark>这就解释了为什么printf会打印两次的原因</mark>）</strong></p><p><strong><code>fork之后，父进程和子进程返回值不同，可以通过不同的返回值，进行判断让父子执行不同的代码块</code>（<mark>这就解释了为什么条件约束失效</mark>）</strong></p></blockquote><hr><h3 id="fork-函数有两个返回值的原因剖析"><a href="#fork-函数有两个返回值的原因剖析" class="headerlink" title="fork()函数有两个返回值的原因剖析"></a><strong>fork()函数有两个返回值的原因剖析</strong></h3><p><font color=red><strong>重点剖析：fork()为什么给父进程返回子进程pid，给子进程返回0？</strong></font></p><blockquote><p><strong>父子关系：父亲—儿子：1：n(n&gt;&#x3D;1)</strong></p><p><strong><font color=red>原因：</font></strong></p><ol><li><strong><mark>父进程必须要有标识子进程的方法：fork()之后，给父进程返回子进程的pid！</mark></strong></li><li><strong><mark>子进程最重要的是要知道自己被创建成功了，因为子进程找父进程成本非常低—使用getppid()</mark></strong></li></ol></blockquote><p><strong><font color=red>重点剖析：fork()之后父子进程谁先执行</font></strong></p><blockquote><ol><li><strong>通常情况下，我们总是用 sleep 等操作来保证另一个进程先执行，但父子进程谁先执行并不是不可预测的</strong></li><li><strong>从linux内核2.6.32开始，在默认情况下，父进程将成为fork之后优先调度的对象</strong></li><li><strong>采取这种策略的原因很简单：fork是父进程发起的调用，因此fork之后，父进程在CPU中处于活跃的状态，并且其内存管理信息也被置于硬件内存单元的转译后备缓冲器(TLB)，所以先调度父进程无论从减少上下文切换、CPU让出等方面都可以提高性能</strong></li><li><strong>linux内核从2.6.24开始，内核采用完全公平调度（CFS），用户创建的普通进程，都采用CFS调度策略。对于CFS调度策略，内核提供的控制选项默认是0，表示父进程优先获得调度，如果该值被改为1，子进程会优先获得调度。但POSIX标准和linux都没有保证会优先调度父进程，因此在应用中，我们不能对父子进程的执行顺序做任何假设</strong></li><li><strong>如果确实需要父子进程的某一特定执行顺序，那么还是得需要进程间的同步手段</strong></li><li><strong><code>所以：从理论上，优先调度父进程。从使用上，不可预测。</code></strong></li></ol><p><strong><font color=red>结论：进程调度顺序由<mark>操作系统内核</mark>和<mark>调度算法</mark>共同决定</font></strong></p></blockquote><p><font color=red><strong>重点剖析：为什么fork()会返回两次？</strong></font></p><blockquote><p><strong><font color=red>前提分析：</font></strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121235936383.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221121235936383.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221121235936383"><p><strong><font color=red>原因分析：</font></strong></p><ol><li><strong><font color=green>当程序执行到下面的语句： <code>pid=fork(); 由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回</code>。 因此fork函数会返回两次，<mark>一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的</mark>。 fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</font></strong><ul><li><strong><mark>在父进程中，fork返回新创建子进程的进程PID</mark></strong></li><li><strong><mark>在子进程中，fork返回0</mark></strong></li><li><strong><mark>如果出现错误，fork返回一个负值</mark></strong></li></ul></li><li><strong>我们可以通过fork返回的值来判断当前进程是子进程还是父进程，其实就相当于链表，进程形成了链表，父进程的fork函数返回的值指向子进程的进程PID, 因为子进程没有子进程，所以其fork函数返回的值为0</strong></li><li><strong><font color=red>调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂</font></strong></li><li><strong><font color=green>子进程代码是从fork处开始执行的， 为什么不是从#include处开始复制代码的？这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了当前情况; fork只拷贝下一个要执行的代码到新的进程</font></strong></li></ol><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122133604563.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122133604563.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122133604563"></blockquote><hr><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h2><h3 id="Linux的进程状态"><a href="#Linux的进程状态" class="headerlink" title="Linux的进程状态"></a><strong>Linux的进程状态</strong></h3><blockquote><p><strong><font color=red>Linux系统的进制状态分类：</font></strong></p><ol><li><p><strong><code>运行状态(R，running)</code>：<mark>并不意味着进程一定在运行中，它表明进程要么是在运行中要么在运行队列里</mark></strong></p></li><li><p><strong><code>睡眠状态(S，sleeping)</code>： <mark>意味着进程在等待事件完成，这里的睡眠有时候也叫做</mark><code>可中断睡眠 interruptible sleep</code></strong></p></li><li><p><strong><code>磁盘休眠状态(D，Disk sleep)</code>：<mark>有时候也叫</mark><code>不可中断睡眠状态（uninterruptible sleep）</code>，<mark>在这个状态的进程通常会等待IO的结束</mark></strong></p></li><li><p><strong><code>暂停状态(T，stopped)</code>：<mark>可以通过发送 SIGSTOP 信号给进程来停止（T）进程。这个被暂停的进程可 以通过发送 SIGCONT 信号让进程继续运行</mark></strong></p></li><li><p><strong><code>死亡状态(X，dead)</code>：<mark>这个状态只是一个返回状态，你不会在任务列表里看到这个状态</mark></strong></p></li><li><p><strong><code>僵尸状态(Z，zombie)</code>：<mark>是一个比较特殊的状态。当进程退出并且父进程，没有读取到子进程退出的返回代码时就会产生僵死(尸)进程</mark></strong></p></li><li><p><strong><code>杀死进程的方法：kill -9 进程PID</code>。<mark>ctrl+c只能杀前台进程，kill命令可以杀后台进程</mark></strong></p></li><li><p><strong><code>Linux内核进程状态源代码：</code></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> task_state_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">"R (running)"</span><span class="token punctuation">,</span> <span class="token comment">/* 0 */</span><span class="token operator">--</span><span class="token operator">-</span>运行    <span class="token string">"S (sleeping)"</span><span class="token punctuation">,</span> <span class="token comment">/* 1 */</span><span class="token operator">--</span><span class="token operator">-</span>浅度睡眠，随时被唤醒，被杀掉    <span class="token string">"D (disk sleep)"</span><span class="token punctuation">,</span><span class="token comment">/* 2 */</span><span class="token operator">--</span><span class="token operator">-</span>深度睡眠，不会被杀掉，只有自己主动唤醒才能恢复    <span class="token string">"T (stopped)"</span><span class="token punctuation">,</span> <span class="token comment">/* 4 */</span><span class="token operator">--</span><span class="token operator">-</span>暂停    <span class="token string">"t (tracing stop)"</span><span class="token punctuation">,</span> <span class="token comment">/* 8 */</span><span class="token operator">--</span><span class="token operator">-</span>进程被调试的时候，遇到断点所处的状态    <span class="token string">"X (dead)"</span><span class="token punctuation">,</span> <span class="token comment">/* 16 */</span><span class="token operator">--</span><span class="token operator">-</span>死亡    <span class="token string">"Z (zombie)"</span><span class="token punctuation">,</span> <span class="token comment">/* 32 */</span><span class="token operator">--</span><span class="token operator">-</span>僵尸<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><strong><font color=red>进程状态间的切换，如下图：</font></strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722012.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722012.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220815131722012"></blockquote><hr><h3 id="进程阻塞与进程挂起的理解"><a href="#进程阻塞与进程挂起的理解" class="headerlink" title="进程阻塞与进程挂起的理解"></a><strong>进程阻塞与进程挂起的理解</strong></h3><blockquote><p><strong>进程阻塞：</strong></p><p><strong>1.一个进程使用资源的时候，可不仅仅是在申请CPU资源</strong></p><p><strong>2.进程可能申请更多的其他资源：磁盘，网卡，显卡等</strong></p><p><strong>3.如果我们申请CPU资源，暂时无法得到满足，是需要排队的，即进入运行队列</strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722010.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220815131722010"></blockquote><blockquote><p><strong>进程挂起：</strong></p><p><strong>1.挂起进程在操作系统中可以定义为暂时被淘汰出内存的进程，机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存，重新进入等待被执行的状态，表现为系统在一定的时间没有任何动作</strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/202208151317220111.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/202208151317220111.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="202208151317220111"></blockquote><hr><h3 id="进程状态查看方法"><a href="#进程状态查看方法" class="headerlink" title="进程状态查看方法"></a><strong>进程状态查看方法</strong></h3><p><strong><mark>进程状态的查看：</mark><code>ps aux</code> &#x2F; <code>ps axj</code></strong>  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//常用的进程状态查看方法</span>ps aux<span class="token operator">|</span>head <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> ps aux<span class="token operator">|</span>grep 进程PIDps ajx<span class="token operator">|</span>head <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> ps ajx<span class="token operator">|</span>grep 进程PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122155815623.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122155815623.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122155815623"><ol><li><strong><mark>系统原生的用法不好用，如下图：</mark></strong></li><li><strong><font color=red>ps aux：显示所有进程 有效用户ID或名字</font></strong></li><li><strong><font color=red>ps ajx：显示所有进程 PPID、PID、PGID、SID、COMMAND等</font></strong></li></ol><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122145831606.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122145831606.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122145831606"><blockquote><p><strong>ps a &#x2F;&#x2F;显示现行终端机下的所有程序，包括其他用户的程序</strong></p><p><strong>ps u 　 &#x2F;&#x2F;以用户为主的格式来显示程序状况。</strong></p><p><strong>ps x 　 &#x2F;&#x2F;显示所有程序，不以终端机来区分</strong></p><p><strong>ps aux &#x2F;&#x2F;显示有效用户ID或名字</strong></p><p><strong>ps ajx  &#x2F;&#x2F;显示PPID，PID，PGID，SID，UID，COMMAND等</strong></p><p><strong>ps awx &#x2F;&#x2F;显示完全程序参数</strong></p></blockquote><hr><h3 id="进程状态：运行状态R"><a href="#进程状态：运行状态R" class="headerlink" title="进程状态：运行状态R"></a><strong>进程状态：运行状态R</strong></h3><p><strong><mark>测试方法：使用命令top,查看进程状态</mark></strong></p><p><strong>效果：</strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122153826349.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122153826349.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122153826349"><p><strong><font color=red>这里我们可以看到一些进程状态时R，这些标识为R的进程就是正在运行或者进入运行队列的进程</font></strong></p><hr><h3 id="进程状态：睡眠状态S"><a href="#进程状态：睡眠状态S" class="headerlink" title="进程状态：睡眠状态S"></a><strong>进程状态：睡眠状态S</strong></h3><p><strong>测试代码：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Process is running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Process PID:%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果：</strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122155001083.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122155001083.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122155001083"><blockquote><ol><li><strong>这里我们看到子进程8130的运行状态就是S状态</strong></li><li><strong>一个进程处于浅度睡眠状态（sleeping），意味着该进程正在等待某件事情的完成，处于浅度睡眠状态的进程随时可以被唤醒，也可以被杀掉（这里的睡眠有时候也可叫做可中断睡眠（interruptible sleep））</strong></li></ol></blockquote><hr><h3 id="进程状态：深度睡眠状态D"><a href="#进程状态：深度睡眠状态D" class="headerlink" title="进程状态：深度睡眠状态D"></a><strong>进程状态：深度睡眠状态D</strong></h3><blockquote><ol><li><strong>一个进程处于深度睡眠状态（disk sleep），表示该进程不会被杀掉，即便是操作系统也不行，只有该进程自动唤醒才可以恢复。该状态有时候也叫不可中断睡眠状态（uninterruptible sleep），处于这个状态的进程通常会等待IO的结束</strong></li><li><strong>例如，某一进程要求对磁盘进行写入操作，那么在磁盘进行写入期间，该进程就处于深度睡眠状态，是不会被杀掉的，因为该进程需要等待磁盘的回复（是否写入成功）以做出相应的应答。（磁盘休眠状态）</strong></li></ol></blockquote><hr><h3 id="进程状态：暂停状态T"><a href="#进程状态：暂停状态T" class="headerlink" title="进程状态：暂停状态T"></a><strong>进程状态：暂停状态T</strong></h3><p><strong><mark>在Linux当中，我们可以通过发送<code>SIGSTOP信号</code>使进程进入暂停状态（stopped），发送SIGCONT信号可以让处于暂停状态的进程继续运行</mark></strong></p><p><strong>例如：</strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122160557869.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122160557869.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122160557869"><p><strong>我们再对该进程发送SIGCONT信号，该进程就继续运行了：</strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122160623252.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122160623252.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122160623252"><hr><h3 id="进程状态：死亡状态X"><a href="#进程状态：死亡状态X" class="headerlink" title="进程状态：死亡状态X"></a><strong>进程状态：死亡状态X</strong></h3><blockquote><ol><li><strong>死亡状态只是一个返回状态，当一个进程的退出信息被读取后，该进程所申请的资源就会立即被释放，该进程也就不存在了，所以你不会在任务列表当中看到死亡状态（dead）</strong></li></ol></blockquote><hr><h3 id="进程状态：僵尸状态Z"><a href="#进程状态：僵尸状态Z" class="headerlink" title="进程状态：僵尸状态Z"></a><strong>进程状态：僵尸状态Z</strong></h3><blockquote><ol><li><strong>僵死状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程（使用wait()系统调用，后面讲）没有读取到子进程退出的返回代码时就会产生僵死(尸)进程</strong></li><li><strong>僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码</strong></li><li><strong>所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态</strong></li></ol></blockquote><p><strong><mark>举例代码：</mark></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> id<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span>mark<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//child</span>        <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am chile，pid：%d，ppid：%d，count：%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">--</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child quit...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//father</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father，pid：%d，ppid：%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122161740786.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122161740786.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122161740786"><p><strong><font color=red>从上图我们就看到了子进程24337的状态由S+变成了Z+，进入僵尸状态的进程我们称它为僵尸进程！</font></strong></p><p><strong><font color=green>僵尸进程对于我们的操作系统来说是有极大危害的！</font></strong></p><p><strong><mark>僵尸进程危害：</mark></strong></p><blockquote><p>1.<strong>进程的退出状态必须被维持下去，因为他要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态</strong></p><p>2.<strong>维护退出状态本身要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，<code>Z状态一直不退出，PCB一直都要维护</code></strong></p><p>3.<strong>那一个父进程创建了很多子进程，就是<code>不回收</code>，就会<code>造成内存资源的浪费</code>，因为数据结构对象本身就要占用内存，想想C中定义一个结构体变量（对象），是要在内存的某个位置进行开辟空间！</strong></p><p>4.<strong><code>导致内存泄漏</code>【常见问题：<mark>1.频繁GC(垃圾回收机制)，发生GC的时候，所有进程都必须等待，GC频率越高，就感觉系统越卡顿</mark>。<mark>2.内存不足引发的程序运行崩溃</mark>】</strong></p></blockquote><hr><h3 id="特殊的进程状态：孤儿状态"><a href="#特殊的进程状态：孤儿状态" class="headerlink" title="特殊的进程状态：孤儿状态"></a><strong>特殊的进程状态：孤儿状态</strong></h3><blockquote><ol><li><strong><mark>若子进程先退出而父进程没有对子进程的退出信息进行读取，那么我们称该进程为僵尸进程</mark></strong></li><li><strong><mark>但若是父进程先退出，那么将来子进程进入僵尸状态时就没有父进程对其进行处理，此时该子进程就称之为”孤儿进程”</mark></strong></li><li><strong><font color=red>孤儿进程被1号init进程领养，当然要有init进程回收，1号init就是操作系统</font></strong></li></ol></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span><span class="token comment">//child</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, pid : %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token keyword">else</span>     <span class="token punctuation">&#123;</span><span class="token comment">//parent</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am parent, pid: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122163230583.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122163230583.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122163230583"><hr><h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a><strong>进程优先级</strong></h2><h3 id="进程优先级基本概念"><a href="#进程优先级基本概念" class="headerlink" title="进程优先级基本概念"></a><strong>进程优先级基本概念</strong></h3><blockquote><p><strong><mark>cpu资源分配的先后顺序，就是指进程的优先权（priority）</mark></strong></p><p><strong>优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可以改善系统性能</strong> </p><p><strong>还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能</strong></p></blockquote><p><strong>核心问题：</strong></p><p><font color=red><strong>1.什么是优先级？什么是权限？</strong></font></p><blockquote><p><strong><code>优先级是进程获取资源的先后顺序</code></strong></p><p><strong><code>权限是能还是不能获取资源</code></strong></p></blockquote><p><font color=red><strong>2.为什么存在优先级？</strong></font></p><blockquote><p><strong>排队的本质叫做确定优先级，资源总是不够的，需要优先分配给重要的进程</strong></p></blockquote><p><strong><font color=red>3.查看进程优先级方法？</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//Linux Unix系统下，用ps -l命令监控运行的进程的详细信息</span>ps <span class="token operator">-</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722015.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/20220815131722015.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" width="20220815131722015"><blockquote><p><strong>UID : 代表执行者的身份</strong> </p><p><strong>PID : 代表这个进程的代号</strong> </p><p><strong>PPID ：代表这个进程是由哪个进程发展衍生而来的，亦即父进程的代号</strong></p><p><strong><mark>PRI ：代表这个进程可被执行的优先级，其值越小越早被执行</mark></strong> </p><p><strong><mark>NI ：代表这个进程的nice值</mark></strong></p></blockquote><hr><h3 id="对于PRI和NI的理解"><a href="#对于PRI和NI的理解" class="headerlink" title="对于PRI和NI的理解"></a><strong>对于PRI和NI的理解</strong></h3><blockquote><ul><li><strong><mark>PRI代表进程的优先级（priority）</mark>，通俗点说就是进程被CPU执行的先后顺序，该<mark>值越小进程的优先级别越高，默认是80</mark></strong></li><li><strong><mark>NI代表的是nice值</mark>，其表示<mark>进程可被执行的优先级的修正数值</mark></strong></li><li><strong><mark>PRI值越小越快被执行</mark>，当加入nice值后，将会使得PRI变为：<mark>PRI(new) &#x3D; PRI(old) + NI</mark></strong></li><li><strong>若NI值为负值，那么该进程的PRI将变小，即其优先级会变高</strong> </li><li><strong><mark>调整进程优先级，在Linux下，就是调整进程的nice值</mark></strong></li><li><strong><code>NI的取值范围：-20~19，40个级别</code></strong></li><li><strong><code>PRI的取值范围：60~99，每次设置优先级都会被恢复为默认的80</code></strong></li><li><strong>Linux不允许进程无节制的设置优先级</strong></li></ul><p><strong>注：<font color=red>需要强调一点的是，进程的nice值不是进程的优先级，，他们不是一个概念，但是进程nice值会影响到进程的优先级变化。 可以理解nice值是进程优先级的修正数据</font></strong></p></blockquote><hr><h3 id="查看和修改进程优先级命令"><a href="#查看和修改进程优先级命令" class="headerlink" title="** 查看和修改进程优先级命令**"></a>** 查看和修改进程优先级命令**</h3><blockquote><ol><li><strong><mark>查看进程优先级的命令</mark>：<code>top</code></strong></li><li><strong><mark>top命令用于显示系统运行的进程信息，作用类似于windows中的任务管理器，只不过top不是图形化的，而是显示实时文本信息</mark></strong></li><li><strong><mark>修改进程优先级的命令</mark>：<code>修改进入top后按“r”–&gt;输入进程PID–&gt;输入nice值</code></strong> </li><li><font color=red><strong>注：每次设置优先级，这个PRI(old)优先级都会恢复为80</strong></font></li></ol></blockquote><p><strong>修改步骤：</strong></p><ol><li><p><strong><mark>输入top，查看进程优先级</mark></strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122165420825.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122165420825.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122165420825"></li><li><p><strong><mark>输入r，进入修改功能</mark></strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122165604781.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122165604781.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122165604781"></li><li><p><strong><mark>输入要修改的PID并输入nice值，这里以PID 3155举例，我们改nice为19</mark></strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122170325565.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122170325565.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122170325565"></li><li><p><strong><mark>最后我们来看看3155进程的NI就变成了19</mark></strong></p><img src="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122170237571.png" class="lazyload placeholder" data-srcset="/2023/02/20/4.linux-jin-cheng-gai-nian/image-20221122170237571.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122170237571"><p><strong><font color=red>这里就可以很清晰的看到了，我们原来的3155进程PR是20，NI修改为19后，PR就变成了39&#x3D;20+19</font></strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux进程概念&quot;&gt;&lt;a href=&quot;#Linux进程概念&quot; class=&quot;headerlink&quot; title=&quot;Linux进程概念&quot;&gt;&lt;/a&gt;Linux进程概念&lt;/h1&gt;&lt;h2 id=&quot;进程的理解&quot;&gt;&lt;a href=&quot;#进程的理解&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境变量与程序地址空间</title>
    <link href="https://not-go.github.io/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/"/>
    <id>https://not-go.github.io/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/</id>
    <published>2023-02-20T04:14:00.000Z</published>
    <updated>2023-06-23T17:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux环境变量与程序地址空间"><a href="#Linux环境变量与程序地址空间" class="headerlink" title="Linux环境变量与程序地址空间"></a><strong>Linux环境变量与程序地址空间</strong></h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><strong>环境变量</strong></h2><h3 id="环境变量概念与深入理解"><a href="#环境变量概念与深入理解" class="headerlink" title="环境变量概念与深入理解"></a><strong>环境变量概念与深入理解</strong></h3><blockquote><ol><li><p>**<mark>环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些参数</mark> **</p></li><li><p>**比如：我们在编写C&#x2F;C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找 **</p></li><li><p><strong>环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性</strong></p></li><li><p><strong>Linux下的环境变量和Windows下的环境变量意思差不多，只是Windows使用了GUI，如下图：</strong></p><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122171412538.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122171412538.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122171412538"></li></ol></blockquote><p><font color=red><strong>常见环境变量：</strong></font></p><blockquote><p><strong>PATH : 指定命令的搜索路径</strong> </p><p><strong>HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)</strong> </p><p><strong>SHELL : 当前Shell,它的值通常是&#x2F;bin&#x2F;bash</strong></p></blockquote><p><font color=red><strong>查看环境变量方法：</strong></font></p><blockquote><ol><li><strong>方法一：echo $PATH</strong></li><li><strong>方法二：env|grep PATH</strong></li></ol><p><strong>注：每个<code>：</code>分割一个环境路径</strong></p><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20220816214125020.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20220816214125020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20220816214125020"><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20220816214125021.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20220816214125021.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20220816214125021"></blockquote><p><font color=red><strong>和环境变量相关的命令：</strong></font></p><blockquote><ol><li>e<strong>cho: 显示某个环境变量值</strong> </li><li><strong>export: 设置一个新的环境变量</strong> </li><li><strong>env: 显示所有环境变量</strong> </li><li><strong>unset: 清除环境变量</strong> </li><li><strong>set: 显示本地定义的shell变量和环境变量</strong></li></ol></blockquote><p><font color=red><strong>环境变量的组织方式：</strong></font><strong>每个程序都会收到一张环境表，环境表是一个字符指针数组，每个指针指向一个以’\0’结尾的环境字符串</strong></p><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20220816214125022.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20220816214125022.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20220816214125022"><hr><h3 id="代码获取环境变量的方法"><a href="#代码获取环境变量的方法" class="headerlink" title="代码获取环境变量的方法"></a><strong>代码获取环境变量的方法</strong></h3><p><strong>方法一：打印命令行第三个参数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>env<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//我们给main函数传递的argc、argv[]参数，其实是传递的命令行中输入的程序名和选项！</span>    <span class="token comment">//char *env[]存储的是环境变量的地址</span>     <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> env<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> env<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//注：char *env[]就是下图的environ</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20220816214125023.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20220816214125023.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20220816214125023"><p><font color=red><strong>方法二：通过第三方变量environ获取</strong></font></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//libc中定义的全局变量environ指向环境变量表,environ没有包含在任何头文件中,所以在使用时 要用extern声明</span>    <span class="token keyword">extern</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> environ<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>environ<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>environ<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122172548683.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122172548683.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122172548683"><hr><h3 id="系统调用获取和设置环境变量的方法"><a href="#系统调用获取和设置环境变量的方法" class="headerlink" title="系统调用获取和设置环境变量的方法"></a><strong>系统调用获取和设置环境变量的方法</strong></h3><p><strong><mark>putenv：获取环境变量</mark></strong></p><p><strong><mark>setenv：设置环境变量</mark></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"PATH"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122172814553.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122172814553.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122172814553"><hr><h2 id="程序地址空间"><a href="#程序地址空间" class="headerlink" title="程序地址空间"></a><strong>程序地址空间</strong></h2><h3 id="程序地址空间图-准确来说是进程地址空间图"><a href="#程序地址空间图-准确来说是进程地址空间图" class="headerlink" title="程序地址空间图(准确来说是进程地址空间图)"></a><strong>程序地址空间图(准确来说是进程地址空间图)</strong></h3><p><strong><font color=red>这里主要提一下：”程序的地址空间”是不准确的，准确的应该说成进程地址空间。在进程地址空间概念小节会详细说明！</font></strong></p><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122175745066.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122175745066.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122175745066"><hr><h3 id="程序地址空间的验证"><a href="#程序地址空间的验证" class="headerlink" title="程序地址空间的验证"></a><strong>程序地址空间的验证</strong></h3><p><strong>参考现象代码：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h></span></span><span class="token keyword">int</span> g_val<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> g_unval<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"code addr：%p\n"</span><span class="token punctuation">,</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read only addr：%p\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"init addr：%p\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>g_val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"uninit addr：%p\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>g_unval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"heap addr：%p\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"stack addr：%p\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"stack addr：%p\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>argc<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"args addr：%p\n"</span><span class="token punctuation">,</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>envp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"env addr：%p\n"</span><span class="token punctuation">,</span>envp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122180730548.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122180730548.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122180730548"><p><strong><mark>大家可以观察一下，按照打印的顺序，地址都是由低到高依次打印的，这也就证实了上面那个图</mark></strong></p><p><font color=red><strong>我们将代码稍加改动下：</strong></font></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token keyword">int</span> g_val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child: pid: %d, ppid: %d, g_val: %d, &amp;g_val: %p\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>g_val<span class="token punctuation">,</span><span class="token operator">&amp;</span>g_val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father: pid: %d, ppid: %d, g_val: %d, &amp;g_val: %p\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>g_val<span class="token punctuation">,</span><span class="token operator">&amp;</span>g_val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122181053619.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122181053619.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122181053619"><p> <strong><mark>值是一样的，地址也是一样也很正常，没有什么问题</mark></strong></p><p><strong><font color=red>我们在修改以下代码：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token keyword">int</span> g_val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> g_val <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child: pid: %d, ppid: %d, g_val: %d, &amp;g_val: %p\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>g_val<span class="token punctuation">,</span><span class="token operator">&amp;</span>g_val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father: pid: %d, ppid: %d, g_val: %d, &amp;g_val: %p\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>g_val<span class="token punctuation">,</span><span class="token operator">&amp;</span>g_val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122181421804.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122181421804.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122181421804"><p><strong><font color=red>从这里开始我们就发现问题了，明明子进程全局变量改成了200，父子进程的地址是一样的，为什么父进程没有受到影响呢？</font></strong></p><p><strong>我们可能认为是父进程先执行的，子进程后执行的，所以子进程改了没有影响父进程，那么好，接下来我就让子进程先结束</strong></p><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122181800731.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122181800731.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122181800731"><p><strong><font color=red>从上图，我们发现让子进程先结束也并没有改变结果呀！说明并不是父子程序执行顺序引起的问题！</font></strong></p><blockquote><p><strong><font color=green>那究竟是为什么呢？</font></strong></p><p><strong><code>首先让我们分析一下问题：</code></strong></p><ul><li><strong><mark>进程已经将全局变量改成200，为什么父进程没有受影响？</mark></strong></li><li><strong><mark>为什么子进程已经改了，父进程才来读数据，读到100已经够奇怪了，为什么它们的地址还是一样的？</mark></strong></li></ul><p><strong><font color=red>推理分析过程：</font></strong></p><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122182240083.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122182240083.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122182240083"></blockquote><blockquote><p><strong><font color=red>经过上图的分析，我们总结一下：</font></strong></p><ol><li><strong>变量内容不一样,所以父子进程输出的变量绝对不是同一个变量</strong></li><li><strong>但地址值是一样的，说明：该地址绝对不是物理地址！</strong> </li><li><strong>在Linux地址下，这种地址叫做虚拟地址</strong></li><li><strong>我们在用C&#x2F;C++语言所看到的地址，全部都是虚拟地址！物理地址，用户一概看不到，由OS统一管理</strong></li><li><strong>其实所谓的虚拟地址就是上面程序地址空间的那个图，它们经过一定的方式转换成物理地址，进行物理级别的访问</strong></li></ol></blockquote><hr><h3 id="进程地址空间概念"><a href="#进程地址空间概念" class="headerlink" title="进程地址空间概念"></a><strong>进程地址空间概念</strong></h3><p><font color=red><strong>所谓的进程地址空间：其实就是OS通过软件的方式，给进程提供一个软件视角，认为自己会独占系统的所有资源(内存)</strong></font></p><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122194039383.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122194039383.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122194039383"><blockquote><ol><li><strong><mark>这里就是通过父进程的进程地址空间通过页表映射，映射到物理内存中，当我们创建子进程的时候，本质上是系统内部多了一个进程，而且每一次申请一个新进程的时候，操作系统会为当前新进程创建一个属于该进程的地址空间，所以子进程也有一个属于自己的页表，因为在创建的时候是以父进程为模板，也就意味着父子进程使用的代码和数据都是一样的</mark></strong></li><li><strong><font color=red>所以我们的子进程对变量进行写入，应不应该影响父进程呢？</font></strong><ul><li><strong><code>页表里取的变量都不一样，很明显是不影响！(这也就回答了上面的为什么修改不会互相影响)</code></strong></li></ul></li><li><strong><code>所以在更改的时候，在物理内存空开辟一个4个字节的空间，将新的值200写进去，更改映射关系，不再指向父进程数据，而是指向新开辟的空间，所以它们的虚拟地址是一样的，但是打印出来的值是不一样的，这种写入时再发生内存重新申请的技术叫做写时拷贝</code></strong></li><li><strong>这样也就实现了在数据上实现了分离！</strong></li></ol></blockquote><hr><h3 id="引入虚拟内存空间原因"><a href="#引入虚拟内存空间原因" class="headerlink" title="引入虚拟内存空间原因"></a><strong>引入虚拟内存空间原因</strong></h3><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122193920045.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122193920045.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122193920045"><blockquote><ol><li><strong><font color=red>通过上图对于虚拟内存空间的总结，我们可以知道引入虚拟内存空间的<mark>最主要原因</mark>是：</font><code>保护物理内存</code></strong></li><li><strong><font color=red>虚拟内存空间技术相当于一种<code>保护模式</code>，保证进程不使用物理地址，而是使用虚拟地址，最后由操作系统将虚拟地址映射到物理内存地址上</font></strong></li><li><strong><font color=red>进程直接访问内存是不安全的，在访问内存添加了一层软硬件层，可以对转化过程进行审核，非法的操作直接拦截，通过地址空间，进行功能模块的解耦</font></strong></li></ol><p><strong><code>举个例子：</code></strong></p><ul><li><strong><mark>假如我们写代码出现了野指针问题，那么这个野指针就会在虚拟地址空间到处乱指，但是无论它怎么乱指也影响不到物理内存，所以随便你乱串，操作系统都不怕，野指针影响的只是你的程序，对操作系统没一点影响！所以这就是起到了保护作用！</mark></strong></li></ul><p><strong><font color=green>最终我们得出引入虚拟内存空间的原因：</font></strong></p><ol><li><strong><font color=green>保护内存</font></strong></li><li><strong><font color=green>管理进程</font></strong></li><li><strong><font color=green>让进程或者程序以一种统一的视角看待内存(简化进程本身的设计与实现)</font></strong></li></ol></blockquote><hr><h3 id="关于进程地址空间技术的一些疑难问题解答"><a href="#关于进程地址空间技术的一些疑难问题解答" class="headerlink" title="关于进程地址空间技术的一些疑难问题解答"></a><strong>关于进程地址空间技术的一些疑难问题解答</strong></h3><blockquote><ol><li><strong><code>为什么数据要进行写时拷贝？</code></strong><ul><li><strong><mark>进程具有独立性。多进程运行，需要独享各种资源，多进程运行期间互不干扰，不能让子进程的修改影响到父进程</mark></strong></li></ul></li><li><strong><code>为什么不在创建子进程的时候就进行数据的拷贝？</code></strong><ul><li><strong><mark>子进程不一定会使用父进程的所有数据，并且在子进程不对数据进行写入的情况下，没有必要对数据进行拷贝，我们应该按需分配，在需要修改数据的时候再分配（延时分配），这样可以高效的使用内存空间</mark></strong></li></ul></li><li><strong><code>代码会不会进行写时拷贝？</code></strong><ul><li><strong><mark>90%的情况下是不会的，但这并不代表代码不能进行写时拷贝，例如在进行进程替换的时候，则需要进行代码的写时拷贝</mark></strong></li></ul></li><li><strong><code>为什么要有进程地址空间？</code></strong><ul><li><strong><mark>有了进程地址空间后，就不会有任何系统级别的越界问题存在了。例如进程1不会错误的访问到进程2的物理地址空间，因为你对某一地址空间进行操作之前需要先通过页表映射到物理内存，而页表只会映射属于你的物理内存。总的来说，虚拟地址和页表的配合使用，本质功能就是保护内存</mark></strong></li><li><strong><mark>有了进程地址空间后，每个进程都认为看得到都是相同的空间范围，包括进程地址空间的构成和内部区域的划分顺序等都是相同的，这样一来我们在编写程序的时候就只需关注虚拟地址，而无需关注数据在物理内存当中实际的存储位置</mark></strong></li><li><strong><mark>有了进程地址空间后，每个进程都认为自己在独占内存，这样能更好的完成进程的独立性以及合理使用内存空间（当实际需要使用内存空间的时候再在内存进行开辟），并能将进程调度与内存管理进行解耦或分离</mark></strong></li></ul></li><li><strong><code>对于创建进程的现阶段理解：</code></strong><ul><li><strong><mark>一个进程的创建实际上伴随着其进程控制块（task_struct）、进程地址空间（mm_struct）以及页表的创建</mark></strong></li></ul></li></ol></blockquote><hr><h2 id="Linux内核的进程调度队列"><a href="#Linux内核的进程调度队列" class="headerlink" title="Linux内核的进程调度队列"></a><strong>Linux内核的进程调度队列</strong></h2><h3 id="Linux内核调度系统简图"><a href="#Linux内核调度系统简图" class="headerlink" title="Linux内核调度系统简图"></a><strong>Linux内核调度系统简图</strong></h3><p><strong><font color=red>Linux内核调度系统：</font></strong></p><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122195435565.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122195435565.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122195435565"><p><strong><font color=red>Linux内核调度队列：</font></strong></p><ul><li><strong>扩展：一个CPU只有一个runqueue(运行队列)，如果有多个CPU就要考虑进程个数的负载均衡问题</strong></li></ul><img src="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122200807212.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-huan-jing-bian-liang-yu-cheng-xu-di-zhi-kong-jian/image-20221122200807212.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221122200807212"><hr><h3 id="对于Linux内核调度队列的理解"><a href="#对于Linux内核调度队列的理解" class="headerlink" title="对于Linux内核调度队列的理解"></a><strong>对于Linux内核调度队列的理解</strong></h3><blockquote><p><strong><font color=red>活动队列(如上图)：</font></strong></p><ul><li><strong><mark>时间片还没有结束的所有进程都按照优先级放在该队列</mark></strong></li><li><strong><mark>nr_active: 总共有多少个运行状态的进程</mark></strong></li><li><strong><mark>queue[140]: 一个元素就是一个进程队列，相同优先级的进程按照FIFO规则进行排队调度,所以，数组下标就是优先级！</mark></strong></li><li><strong><mark>bitmap[5]:一共140个优先级，一共140个进程队列，为了提高查找非空队列的效率，就可以用5*32个比特位表示队列是否为空，这样，便可以大大提高查找效率</mark></strong></li><li><strong><mark>从该结构中，选择一个最合适的进程，过程是怎么的呢？</mark></strong><ol><li><strong>从0下表开始遍历queue[140]</strong></li><li><strong>找到第一个非空队列，该队列必定为优先级最高的队列</strong></li><li><strong>拿到选中队列的第一个进程，开始运行，调度完成！</strong></li><li><strong>遍历queue[140]时间复杂度是常数！但还是太低效了！</strong></li></ol></li></ul><p><strong><font color=red>过期队列(如上图)：</font></strong></p><ul><li><strong><mark>过期队列和活动队列结构一模一样</mark></strong></li><li><strong><mark>过期队列上放置的进程，都是时间片耗尽的进程</mark></strong></li><li><strong><mark>当活动队列上的进程都被处理完毕之后，对过期队列的进程进行时间片重新计算</mark></strong></li></ul><p><strong><font color=red>active指针与expired指针(如上图)：</font></strong></p><ul><li><strong><mark>active指针永远指向活动队列</mark></strong></li><li><strong><mark>expired指针永远指向过期队列</mark></strong></li><li><strong><mark>可是活动队列上的进程会越来越少，过期队列上的进程会越来越多，因为进程时间片到期时一直都存在的</mark></strong></li><li><strong><mark>没关系，在合适的时候，只要能够交换active指针和expired指针的内容，就相当于有具有了一批新的活动进程！</mark></strong></li></ul></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux环境变量与程序地址空间&quot;&gt;&lt;a href=&quot;#Linux环境变量与程序地址空间&quot; class=&quot;headerlink&quot; title=&quot;Linux环境变量与程序地址空间&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux环境变量与程序地址空间&lt;/strong&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程控制</title>
    <link href="https://not-go.github.io/2023/02/20/1.linux-jin-cheng-kong-zhi/"/>
    <id>https://not-go.github.io/2023/02/20/1.linux-jin-cheng-kong-zhi/</id>
    <published>2023-02-20T04:13:00.000Z</published>
    <updated>2023-06-23T17:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux进程控制"><a href="#Linux进程控制" class="headerlink" title="Linux进程控制"></a>Linux进程控制</h1><h2 id="Linux进程创建"><a href="#Linux进程创建" class="headerlink" title="Linux进程创建"></a>Linux进程创建</h2><h3 id="fork-函数的基本了解"><a href="#fork-函数的基本了解" class="headerlink" title="fork()函数的基本了解"></a>fork()函数的基本了解</h3><p><strong><font color=red>在linux中fork()函数是非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程！</font></strong></p><blockquote><ol><li><strong><mark>fork()函数的头文件</mark>：<code>#include&lt;unistd.h&gt;</code></strong></li><li><strong><mark>fork()函数原型</mark>：<code>pid_t fork(void)</code></strong></li><li><strong><mark>fork()函数返回值</mark>：<code>父程序返回子程序PID，子程序返回0，出错返回-1</code></strong></li></ol></blockquote><hr><h3 id="fork-调用期间，内核的操作"><a href="#fork-调用期间，内核的操作" class="headerlink" title="fork()调用期间，内核的操作"></a>fork()调用期间，内核的操作</h3><p><strong><font color=green>进程调用fork，当控制转移到内核中的fork代码后，内核做了一下事情：</font></strong></p><ul><li><strong><mark>分配新的内存块和内核数据结构给子进程</mark></strong></li><li><strong><mark>将父进程部分数据结构内容拷贝至子进程</mark></strong></li><li><strong><mark>添加子进程到系统进程列表当中</mark></strong></li><li><strong><mark>fork返回，开始调度器调度</mark></strong></li></ul><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125155823122.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125155823122.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221125155823122"><p><strong><font color=red>当一个进程调用fork之后，父子进程共享代码，子进程写时拷贝父进程数据，每个进程都将可以开始它们自己的执行，看如下程序：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//给了if分流父子进程的fork现象</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Now PID：%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> id<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span>mark<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//child</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child pid：%d  return：%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//father</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father pid：%d  return：%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125161200085.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125161200085.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221125161200085"><p><strong><mark>再来看一个代码现象：</mark></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//未给if分流父子进程的fork现象</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Before: pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"After:pid is %d,fork return %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125161444836.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125161444836.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221125161444836"><blockquote><p><strong>以第二个代码例子为例，<font color=red>这里看到了三行输出，一行before，两行after。进程9045先打印before消息，然后它又打印after。另一个after 消息有9046打印的。注意到进程9046没有打印before，为什么呢？如下图所示：</font></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125164155424.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125164155424.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221125164155424"><p><strong><font color=red>上图解析：</font></strong></p><ul><li><strong>fork之前，我们是先执行before，所以第一行我们打印除了befor</strong></li><li><strong>fork执行时，子进程写时拷贝一份父进程数据，fork返回两个返回值分别给父子进程</strong></li><li><strong>fork之后，父子进程代码共享，但fork返回值有两个，于是执行后续的代码2次，打印两个after</strong></li></ul><p><strong><font color=red>值得注意的是：</font></strong></p><ol><li><strong><font color=red>fork之后，父子进程谁先执行，完全由调度器决定</font></strong></li><li><strong><font color=red>fork之后，并不是重新创建一个新的子进程，而是使用老的父进程，也就是我们说的父子进程代码共享，所以进程还是一个，我们说的父子进程只是方便描述</font></strong></li><li><strong><font color=red>发生写时拷贝，父子进程的虚拟地址相同，物理地址的映射不同，所以最后父子进程获得的getpid()和pid值是不一样的</font></strong></li></ol></blockquote><hr><h3 id="fork-函数的返回值"><a href="#fork-函数的返回值" class="headerlink" title="fork()函数的返回值"></a>fork()函数的返回值</h3><p><strong><font color=red>思考一些问题：</font></strong></p><ol><li><strong><mark>为何要给子进程返回0，给父进程返回子进程的pid？</mark></strong></li><li><strong><mark>如何理解fork有两个返回值的问题？</mark></strong></li></ol><blockquote><ol><li><p><strong><font color=red>第一个问题：</font></strong></p><ul><li><strong><font color=red>首先父子进程的 1 : n 的关系，所以在父子进程的立场中，父进程不需要标识，子进程需要标识。其次子进程是要执行任务的，父进程需要区分子进程，所以给父进程返回子进程的pid，因为父进程可以通过这个pid来区分是哪个子进程。给子进程返回0，本质上是因为子进程不需要访问父进程pid，因为子进程也不需要知道父进程pid，子进程不需要管理父进程，任务是给子进程的，它只需要知道自己调用成功了就可以</font></strong></li></ul></li><li><p><strong><font color=red>第二个问题：</font></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125164554219.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125164554219.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221125164554219"></li></ol></blockquote><hr><h3 id="写时拷贝技术"><a href="#写时拷贝技术" class="headerlink" title="写时拷贝技术"></a>写时拷贝技术</h3><p><strong><font color=red>通常父子代码共享，父子在不修改时，数据也是共享的，当任意一方试图修改时，便以写时拷贝的方式各自一份副本。具体见下图：</font></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125165613400.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125165613400.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221125165613400"><p><strong><font color=red>对于写时拷贝的理解：</font></strong></p><ol><li><strong><font color=green>对这里的”共享”怎么理解？</font></strong><ul><li><strong><mark>答：父子进程对应的页表指向的是同一块物理内存。当任何一方写入的时候，以便使用写时拷贝的方式生成一份副本</mark></strong></li></ul></li><li><strong><font color=green>为何要写时拷贝？</font></strong><ul><li><strong><mark>答：进程具有独立性！</mark></strong></li></ul></li><li><strong><font color=green>为何不在创建的时候就分开？</font></strong><ul><li><strong><mark>答：子进程不一定会使用父进程的所有数据，写入，本质是需要的时候！也就是按需分配，这种方式还做到了一点：延时分配，因为当被创建的时候，不一定被立马调度，如果不立马被调度，那就不需要先给它分配空间。因为要是先给它分配空间了，那也就是在它被调度之前的时间段中，系统可用的内存是变少的，所以延时分配永远可以保证系统可用资源是最大化的！所以延时分配的本质是：可以高效使用任何内存空间！</mark></strong></li></ul></li><li><strong><font color=green>为何代码不会写时拷贝？</font></strong><ul><li><strong><mark>答：90%的情况不会(但是不代表不能)，因为我们学语言到现在，我们要改的永远是数据，我们没有在让程序运行的时候，改程序运行的逻辑</mark></strong></li></ul></li></ol><hr><h3 id="fork-函数的常规用法"><a href="#fork-函数的常规用法" class="headerlink" title="fork()函数的常规用法"></a>fork()函数的常规用法</h3><ol><li><strong><font color=red>一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子进程来处理请求</font></strong></li><li><strong><font color=red>一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数</font></strong></li></ol><hr><h3 id="fork-函数调用失败的原因"><a href="#fork-函数调用失败的原因" class="headerlink" title="fork()函数调用失败的原因"></a>fork()函数调用失败的原因</h3><ol><li><strong><font color=red>系统中有太多的进程：内存空间上的不支持</font></strong></li><li><strong><font color=red>实际用户的进程数超过了限制：操作系统上的不支持</font></strong></li></ol><hr><h2 id="Linux进程终止"><a href="#Linux进程终止" class="headerlink" title="Linux进程终止"></a>Linux进程终止</h2><h3 id="进程退出的三种情况"><a href="#进程退出的三种情况" class="headerlink" title="进程退出的三种情况"></a>进程退出的三种情况</h3><blockquote><ol><li><strong><mark>代码正常运行完毕，结果正确</mark></strong></li><li><strong><mark>代码正常运行完毕，结果不正确</mark></strong></li><li><strong><mark>代码运行异常</mark></strong></li></ol><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125171908381.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221125171908381.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221125171908381"></blockquote><hr><h3 id="进程退出的常见方式"><a href="#进程退出的常见方式" class="headerlink" title="进程退出的常见方式"></a>进程退出的常见方式</h3><blockquote><ol><li><strong><font color=red>正常终止(可以通过 <code>echo $?</code> 查看最近一次进程退出码)：</font></strong><ol><li><strong><mark>从main函数中return返回</mark></strong></li><li><strong><mark>调用exit()函数返回</mark></strong></li><li><strong><mark>调用_exit()函数返回</mark></strong></li></ol></li><li><strong><font color=red>异常退出：ctrl+c，信号中止</font></strong></li></ol></blockquote><p><strong><font color=green>Linux下错误码打印方法：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//这里这样写是因为不支持C99，需要在编译的时候加个-std=c99</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">150</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误码序号：%d，错误信息：%s\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token function">streror</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126200810476.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126200810476.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126200810476"><p><strong><font color=red>注：Linux下只有133个错误码，每个错误码都有对应的错误信息！</font></strong></p><hr><h3 id="exit-和-exit-的区别"><a href="#exit-和-exit-的区别" class="headerlink" title="exit()和_exit()的区别"></a>exit()和_exit()的区别</h3><p><strong><font color=red>两者的区别在于，exit会在进程结束做一些收尾工作（比如刷新缓冲区），而_exit不会，看下面的对比：</font></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126202644455.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126202644455.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126202644455"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是show()函数!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是main()函数!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126202026362.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126202026362.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126202026362"><p><strong><mark>我们把exit()函数换成_exit()函数来看看效果：</mark></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是show()函数!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是main()函数!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126201855883.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126201855883.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126201855883"><blockquote><p><strong><font color=red>从上面来个代码效果和剖析函数原型我们可以得出结论：</font></strong></p><ol><li><strong><mark>exit最后也调用了_exit，但exit还做了其他工作：</mark></strong><ul><li><strong><code>执行用户通过 atexit或on_exit定义的清理函数</code></strong></li><li><strong><code>关闭所有打开的流，所有的缓存数据均被写入</code></strong></li><li><strong><code>调用_exit</code></strong></li></ul></li><li><strong><mark>exit和return的区别：</mark></strong><ul><li><strong><code>exit是终止整个进程，任何地方调用都会终止整个进程</code></strong></li><li><strong><code>return是终止函数，等同于exit(n)</code></strong></li></ul></li></ol></blockquote><hr><h3 id="关于退出码的一些思考"><a href="#关于退出码的一些思考" class="headerlink" title="关于退出码的一些思考"></a>关于退出码的一些思考</h3><p><strong>由退出码想到了一系列问题：</strong></p><blockquote><ol><li><strong><font color=red>进程异常退出，退出码还有意义吗？</font></strong><ul><li><strong>没有意义！说简单点，到异常的地方就已经被终止了，根本没有执行 return</strong></li></ul></li><li><strong><font color=red>进程终止了，操作系统在做什么？</font></strong><ul><li><strong>释放曾经申请的数据结构，释放曾经申请的内存，从各种队列等数据中移除</strong></li></ul></li><li><strong><font color=red>为何要有进程等待？</font></strong><ul><li><strong>回收子进程资源</strong></li><li><strong>获取子进程退出信息</strong></li></ul></li></ol></blockquote><hr><h2 id="Linux进程等待"><a href="#Linux进程等待" class="headerlink" title="Linux进程等待"></a>Linux进程等待</h2><h3 id="进程为什么要等待"><a href="#进程为什么要等待" class="headerlink" title="进程为什么要等待"></a>进程为什么要等待</h3><ol><li><strong><font color=red>回收僵尸进程，解决内存泄漏（僵尸进程是杀不死了，kill -9不能干掉僵尸进程）</font></strong></li><li><strong><font color=red>获取子进程的运行结束状态（交给子进程的工作做的怎么样了）</font></strong></li><li><strong><font color=red>父进程晚于子进程退出，规范化的进行资源回收</font></strong></li></ol><blockquote><ul><li><strong><code>等待的本质也是管理的一种方式，OS的核心就在于管理二字</code></strong></li><li><strong><code>简而言之，进程等待的原因：获取子进程的信息和防止内存泄漏</code></strong></li></ul></blockquote><hr><h3 id="等待函数wait与waitpid的理解"><a href="#等待函数wait与waitpid的理解" class="headerlink" title="等待函数wait与waitpid的理解"></a>等待函数wait与waitpid的理解</h3><p><strong><font color=red>我们用man 2 wait来看一下wait和waitpid函数的官方文档：</font></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126203612530.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126203612530.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126203612530"><p><strong><mark>补充：在普通状态下用<code>man -2 wait</code>查看，在vim下用<code>! man 2 wait</code>可以快速查看</mark></strong></p><blockquote><p><strong><font color=red>wait与waitpid理解：</font></strong></p><ol><li><strong><mark>头文件：</mark><code>#include&lt;sys/types.h&gt;和#include&lt;sys/wait.h&gt;</code></strong></li><li><strong><mark>wait返回值：等待成功返回子进程pid，等待失败返回-1</mark></strong></li><li><strong><mark>waitpid返回值：等待成功返回子进程的pid，如果指定了WNOHANG选项，且子进程正在运行（没有已退出的子进程可收集）则返回0，等待失败返回-1</mark></strong></li></ol><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126204004258.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126204004258.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126204004258"></blockquote><hr><h3 id="wait-的使用"><a href="#wait-的使用" class="headerlink" title="wait()的使用"></a>wait()的使用</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>返回值： 成功返回被等待进程pid，失败返回<span class="token operator">-</span><span class="token number">1</span>。参数： 输出型参数，获取子进程退出状态<span class="token punctuation">,</span>不关心则可以设置成为<span class="token constant">NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><mark>wait的使用案例：</mark></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">&#123;</span>                       <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>                                                                   <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>              <span class="token keyword">else</span>   <span class="token punctuation">&#123;</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>                                                                                            <span class="token punctuation">&#123;</span>                                                                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait child success!, %d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>                  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Father running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126204543932.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126204543932.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126204543932"><blockquote><ol><li><strong>结论：<mark>由此可见，在父进程等待的时候，子进程在运行，重要的是，在子进程运行结束后没有看到Z状态进程，这是因为父进程在等待子进程结束，然后回收子进程</mark></strong></li><li><strong><font color=red>一点小问题：</font></strong><ul><li><strong><code>在子进程运行期间，父进程wait的时候，父进程在做什么？</code></strong><ul><li><strong><mark>就是在 “等” 什么也没干，就是在等子进程退出，这种等子进程退出的过程叫做阻塞等待</mark></strong></li><li><strong><mark>因为父子谁先运行不确定，但是wait之后，大部分情况都是子进程先退出，父进程读取子进程退出信息，父进程才退出。建议大家以后一定要让父进程等待子进程退出，如果不等的话，一定会导致僵尸进程的问题</mark></strong></li></ul></li></ul></li></ol></blockquote><p><strong><font color=red>补充：上面ps命令下面的########的显示方法</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ps ajx <span class="token operator">|</span> grep <span class="token function">test</span><span class="token punctuation">(</span>代码文件名称<span class="token punctuation">)</span> <span class="token operator">|</span> grep <span class="token operator">-</span>v grep<span class="token punctuation">;</span> sleep <span class="token number">1</span><span class="token punctuation">;</span> echo <span class="token string">"###########"</span><span class="token punctuation">;</span> done<span class="token comment">//这个代码里的while、do、done是shell编程里使用的，自行了解就行了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="waitpid-的使用"><a href="#waitpid-的使用" class="headerlink" title="waitpid()的使用"></a>waitpid()的使用</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">pid_ t <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>返回值： 当正常返回的时候waitpid返回收集到的子进程的进程ID 如果设置了选项WNOHANG<span class="token punctuation">,</span>而调用中waitpid发现没有已退出的子进程可收集<span class="token punctuation">,</span>则返回<span class="token number">0</span> 如果调用中出错<span class="token punctuation">,</span>则返回<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>这时errno会被设置成相应的值以指示错误所在参数： pid：Pid<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>等待任一个子进程。与wait等效 Pid<span class="token operator">></span><span class="token number">0.</span>等待其进程ID与pid相等的子进程     status<span class="token operator">:</span> <span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token operator">:</span> 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出） <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token operator">:</span> 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）         options<span class="token operator">:</span> WNOHANG<span class="token operator">:</span> 若pid指定的子进程没有结束，则<span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数返回<span class="token number">0</span>，不予以等待。若正常结束，则返回该子进程的ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li><strong><mark>如果子进程已经退出，调用wait&#x2F;waitpid时，wait&#x2F;waitpid会立即返回，并且释放资源，获得子进程退出信息</mark></strong></li><li><strong><mark>如果在任意时刻调用wait&#x2F;waitpid，子进程存在且正常运行，则进程可能阻塞</mark></strong></li><li><strong><mark>如果不存在该子进程，则立即出错返回</mark></strong></li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                       <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>                 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>                                                                    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>              <span class="token keyword">else</span>   <span class="token punctuation">&#123;</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//pid_t ret = wait(NULL);</span>       <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                                                                 <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>       <span class="token punctuation">&#123;</span>                       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait child success!, %d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Father running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126212157857.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126212157857.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126212157857"><blockquote><p><strong><font color=red>结论：</font></strong></p><ol><li><strong><mark>由此可见，waitpid和wait没有什么区别</mark></strong></li><li><strong><mark>进程等待成功是否意味着子进程运行成功？</mark></strong><ul><li><strong>绝对不是，进程等待成功只意味着子进程退出了</strong></li></ul></li></ol></blockquote><hr><h3 id="进程子状态的获取：int-status"><a href="#进程子状态的获取：int-status" class="headerlink" title="进程子状态的获取：int* status"></a>进程子状态的获取：int* status</h3><p><strong><mark>我们接下来看看status表示的是什么：</mark></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126212631111.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126212631111.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126212631111"><p><strong><font color=red>由此可见，status表示的不是退出码，这个数字很奇怪，那它到底表示的是什么呢？</font></strong></p><blockquote><p><strong><code>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针</code>。如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，我们就可以设定这个参数为NULL</strong></p></blockquote><p><strong><font color=red>关于status参数的理解：</font></strong></p><blockquote><ol><li><p><strong><mark>wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充</mark></strong></p></li><li><p><strong><mark>如果传递NULL，表示不关心子进程的退出状态信息</mark></strong></p></li><li><p><strong><mark>否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程</mark></strong></p></li><li><p><strong><mark>status不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图（只研究status低16比特位）</mark></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126214449865.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126214449865.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126214449865"><p><strong><font color=red>关于0xff与0x7f的使用理解：</font></strong></p><ol><li><strong><code>0xff：通常用来取得低八位</code></strong><ul><li><strong><mark>f二进制是：1111，即0xff为：0000 0000 1111 1111</mark></strong> </li><li><strong><mark>这里的status&gt;&gt;8，取status的后8位，后八位全是0，而&amp;操作，二进制位同真为真</mark></strong></li><li><strong><mark>如果(status&gt;&gt;8)&amp;0xff结果为0，则表示后8位全是0，代码运行结果正确</mark></strong></li><li><strong><mark>如果(status&gt;&gt;8)&amp;0xff结果不为0，则表示后8位不全是0，代码运行结果不正确</mark></strong></li></ul></li><li><strong><code>0x7f：通常用来取得低七位</code></strong><ul><li><strong><mark>7二进制是：0111，即0x7f为：0000 0000 0111 1111</mark></strong></li><li><strong><mark>异常终止高八位没用，所以这里不需要将status&gt;&gt;8</mark></strong></li><li><strong><mark>status&amp;0x7f，就是将status的第七位与111 1111进行&amp;操作，从而得到终止信号</mark></strong></li></ul></li></ol><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126221427755.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126221427755.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126221427755"></li></ol></blockquote><hr><h3 id="status的验证"><a href="#status的验证" class="headerlink" title="status的验证"></a>status的验证</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">77</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">else</span>   <span class="token punctuation">&#123;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//pid_t ret = wait(NULL);</span>      <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                                                                <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait child success!, %d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"status: %d\n"</span><span class="token punctuation">,</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child exit code: %d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>status<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Father running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126225007858.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126225007858.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126225007858"><blockquote><ol><li><strong><font color=red>我们通过第9行代码获取到了子进程退出的退出码exit(77)</font></strong></li><li><strong><font color=green>进程异常的时候，本质是进程运行的时候出现了某种错误，导致进程收到信号！</font></strong></li></ol></blockquote><p> <strong>那么我们怎么知道我们收到信号了呢？我们接着看：</strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126225214129.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126225214129.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126225214129"><blockquote><p><strong><mark>由此可见，我们没有收到任何信号，因为信号里没有0号信号！</mark></strong></p></blockquote><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126225327641.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126225327641.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126225327641"><blockquote><p>  <strong>由上图，我在进程运行的时候用2号信号把子进程给kill了，子进程立马终止然后传递过去了2号信号。且退出码为0(我刚才说过，如果进程出现异常，退出码没有任何意义!)</strong></p></blockquote><p> <strong><font color=red>上面都是提到的单进程，接下来我就写一个多进程执行的，前面没有说waitpid的第一个参数，其实第一个参数在单进程的时候就标识的那个参数，多参数的时候就可以指定一个参数，也就是说一个waitpid只能等一个子进程：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token class-name">pid_t</span> ids<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>        <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>          <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>                                                       <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child do something!: %d, %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>             <span class="token function">exit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                                                                                          <span class="token comment">//father</span>      ids<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> id<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>                 <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>ids<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait child success!, %d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"status: %d\n"</span><span class="token punctuation">,</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child exit code: %d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>status<span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child get signal: %d\n"</span><span class="token punctuation">,</span>status<span class="token operator">&amp;</span><span class="token number">0x7F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     count<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126225756378.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126225756378.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126225756378"><blockquote><ul><li><strong>其实我们很少用到创建多进程的场景</strong></li><li><strong>在最开始我们说waitpid的时候给了两个宏，也就是说，我们可以不适用位操作，直接使用宏即可，如下代码：</strong></li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> ids<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>         <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child do something!: %d, %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>                                                                                              <span class="token comment">//father</span>      ids<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>                                                                                                <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>ids<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait child success!, %d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//正常退出</span>         <span class="token punctuation">&#123;</span>           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child exit code: %d\n"</span><span class="token punctuation">,</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span>         <span class="token punctuation">&#123;</span>           <span class="token comment">//不正常退出</span>           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child not exit normal!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        <span class="token comment">// printf("status: %d\n",status);</span>        <span class="token comment">// printf("child exit code: %d\n",(status>>8)&amp;0xFF);</span>        <span class="token comment">// printf("child get signal: %d\n",status&amp;0x7F);</span>      <span class="token punctuation">&#125;</span>      count<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126230238437.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126230238437.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126230238437"><hr><h3 id="进程阻塞等待与非阻塞等待的区别"><a href="#进程阻塞等待与非阻塞等待的区别" class="headerlink" title="进程阻塞等待与非阻塞等待的区别"></a>进程阻塞等待与非阻塞等待的区别</h3><blockquote><ul><li><strong><code>阻塞等待：父进程一直等子进程，什么也不干</code></strong></li><li><strong><code>非阻塞等待：就是父进程在等待的同时也在做自己的事，在子进程退出后再去读取子进程的退出信息</code></strong></li></ul><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126233415817.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126233415817.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126233415817"><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126233427977.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126233427977.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126233427977"></blockquote><p><strong><font color=red>我们首先来剖析一下waitpid返回值的文档：</font></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126231719679.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126231719679.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126231719679"><p> <strong><mark>这里我解释一下waitpid()的返回值：如果成功的话，返回等待子进程的退出码，如果WNOHANG被指定的、并且指定的子进程是存在的、并且这个子进程的状态没有改变，就返回0，否则的话就返回-1</mark></strong></p><blockquote><p><strong><font color=red>这里先说一个细节：waitpid的返回值要么大于0要么小于0这两个状态，要是设置成非阻塞就很有可能出现第三个状态，就是调用waitpid调用成功了，但是子进程并没有退出，没有退出的话调用waitpid检车的时候，就相当于，我等它的时候，他没有退出，但是我waitpid调用成功了，因为状态没有变，所以我直接返回了，就相当于我就进行了一次检测。所以如果waitpid的返回值是0的话就证明waitpid调用是成功的，只不过被等的那个子进程没有退出罢了</font></strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                                    <span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait success!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exit code: %d\n"</span><span class="token punctuation">,</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ret: %d\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126231947081.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126231947081.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126231947081"><blockquote><ol><li><strong><font color=red>由此可见，此时waitpid的返回值立马就是0，但是子进程还在，而父进程立马就退出了，此时子进程的ppid立马改为了1，那么子进程也就变成了孤儿进程</font></strong></li><li><strong><font color=red>所以我们可以得到一个结论，如果我们以非阻塞的方式进行等待的时候，此时我们就不应该只等待一次，而是让父进程不断的轮询式的等待</font></strong></li></ol></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, pid: %d, ppid: %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                                                                <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wait success!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exit code: %d\n"</span><span class="token punctuation">,</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"father do other things!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span>     <span class="token punctuation">&#123;</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"waitpid error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126232811975.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221126232811975.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221126232811975"><blockquote><p><strong>由此可见，在子进程在做自己的事情的时候，父进程并不是刻意的去等待，而是父进程也在做自己的事情，它们两个之间并不会相互影响，只不过每隔1秒进行一次检测，当子进程运行结束之后，父进程获取子进程相关的退出信息</strong></p></blockquote><p><strong><font color=red>这种检测方案叫做<mark>非阻塞接口</mark>的<code>轮询检测方案</code>!</font></strong></p><hr><h2 id="Linux进程替换"><a href="#Linux进程替换" class="headerlink" title="Linux进程替换"></a>Linux进程替换</h2><h3 id="进程替换原理"><a href="#进程替换原理" class="headerlink" title="进程替换原理"></a>进程替换原理</h3><ul><li><strong><font color=blue>磁盘中保存一程序的代码和数据，程序替换就是，将磁盘中保存的新程序的代码和数据替换进程中的程序和代码。从新程序代码开始执行</font></strong></li><li><strong><font color=red>注意：<code>程序替换没有创建新进程</code>，所以该进程的pid和数据结构并没有改变</font></strong></li></ul><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127143724915.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127143724915.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127143724915"><hr><h3 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h3><p><strong><font color=red>在Linux中其实有六种以exec开头的函数，统称exec函数：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用说明</span>这些函数如果调用成功则加载新的程序从启动代码开始执行<span class="token punctuation">,</span>不再返回如果调用出错则返回<span class="token operator">-</span><span class="token number">1</span>所以exec函数只有出错的返回值而没有成功的返回值    <span class="token comment">//命名理解</span><span class="token comment">//这些函数原型看起来很容易混,但只要掌握了规律就很好记</span><span class="token function">l</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token operator">:</span> 表示参数采用列表<span class="token function">v</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span> <span class="token operator">:</span> 参数用数组<span class="token function">p</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">:</span> 有p自动搜索环境变量PATH<span class="token function">e</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span> <span class="token operator">:</span> 表示自己维护环境变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127144543035.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127144543035.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127144543035"><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127150000373.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127150000373.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127150000373"><p><strong><code>补充：execl系列的函数，根本就不需要判断返回值，因为只要是返回了就是失败！所以我们一般在程序替换后加上exit(1)，也就是说只要你成功了，那你就被替换掉了，只要失败了就不往后走了，就终止进程</code></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127150149343.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127150149343.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127150149343"><p> <strong><font color=red>接下来我先来用几个，其实剩下的都是非常相似的：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>                                                                           </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am a process!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/usr/bin/ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-a"</span><span class="token punctuation">,</span> <span class="token string">"-i"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127144710496.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127144710496.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127144710496"><blockquote><ul><li><strong>我们可以看到，我们利用execl成功的调用起了ls命令</strong></li><li><strong>我们得到一个结论，我的<mark>进程可以把别人的程序调用起来</mark></strong></li></ul></blockquote><p><strong><mark>我们学语言的时候肯定都听说过一句话，任何程序要被运行之前，必须要先从磁盘中加载到内存当中(因为冯诺依曼体系是这么决定的，因为磁盘属于外设)</mark>，<font color=red>那么我们就有了以下一些疑问了？</font></strong></p><blockquote><ol><li><strong><code>那么程序如何被加载的呢？</code></strong><ul><li><strong><font color=red>我们刚才用的execl就可以称之为叫做Linux下的加载器所用的底层技术</font></strong></li></ul></li><li><strong><code>当前进程在进行程序替换的时候，有没有创建新的进程？</code></strong><ul><li><strong><font color=red>没有！也就是说，我们在进行程序替换的时候，没有进行任何的程序创建。有的人可能认为不对啊！这里执行的代码和数据都已经被替换掉了，那怎么能是没创建新进程呢？</font></strong></li><li><strong><font color=red>其实衡量一个进程是进程，并不是根据这个进程执行什么代码、访问什么数据决定的，衡量一个进程是进程是由它在内核中的相关数据结构决定的，而其中我们在进行程序替换时PCB、虚拟地址空间、页表这三种结构是没有发生质的变化的。我们只是把老的代码用新的磁盘上的文件的代码和数据进行了替换，仅此而已</font></strong></li><li><strong><font color=red>所以这也就印证：进程不等价于程序，进程要比程序大的多</font></strong></li></ul></li><li><strong><code>进程替换之后如果还有代码会执行么？</code></strong><ul><li><strong><font color=red>不会！因为已经被替换了，进程程序替换，一经替换，绝不返回，后续代码不会执行</font></strong></li></ul></li><li><strong><code>如果程序替换失败呢？</code></strong><ul><li><strong><font color=red>程序替换失败后，程序后续并不会受到影响！也就是说，一旦替换失败，后面的代码正常运行</font></strong></li></ul></li></ol></blockquote><hr><h2 id="shell的实现原理"><a href="#shell的实现原理" class="headerlink" title="shell的实现原理"></a>shell的实现原理</h2><h3 id="对shell的理解"><a href="#对shell的理解" class="headerlink" title="对shell的理解"></a>对shell的理解</h3><blockquote><ul><li><strong><mark>shell叫做命令行解释器，它的作用是将你输入的命令交给bash去执行，而bash本身不会亲自给你去实现命令，而是会创建一个子进程去帮你执行<mark>，因为进程和进程之间是由独立性的，你运行的命令如果没有BUG还好，有BUG的话，这个BUG命令如果bash亲自执行，可能会将bash搞挂了，bash挂了，就没有办法给用户提供新的命令行解释服务了，所以这种事一般由子进程去做，子进程挂掉也不影响，首先不影响父进程bash，而且运行后的结果不管对还是不对，父进程都可以拿到结果</strong></li></ul><p><strong><font color=red>shell的简单实现方法：</font></strong></p><ol><li><strong>简单的shell，它的<font color=red>根本原理其中一定要有fork()这样的调用，这是其一</font></strong></li><li><strong><font color=red>其二就是我们创建出来的子进程，我们不是为了让子进程帮我们去执行解释器部分的代码，它的任务只是执行命令，所以也就是创建子进程，让子进程去执行一个全新的程序(程序替换)</font></strong></li></ol></blockquote><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127150741814.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127150741814.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127150741814"><hr><h3 id="shell的实现"><a href="#shell的实现" class="headerlink" title="shell的实现"></a>shell的实现</h3><p><strong><font color=red>用下图的时间轴来表示事件的发生次序，其中时间从左向右。shell由标识为sh的方块代表，它随着时间的流逝从左向右移动。shell从用户读入字符串”ls”。shell建立一个新的进程，然后在那个进程中运行ls程序并等待那个进程结束</font></strong></p><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127151206006.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127151206006.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127151206006"><p><strong><mark>实现流程：</mark></strong></p><blockquote><ol><li><strong><mark>获取命令行</mark></strong></li><li><strong><mark>解析命令行</mark></strong></li><li><strong><mark>建立一个子进程（fork）</mark></strong></li><li><strong><mark>替换子进程（execvp）</mark></strong></li><li><strong><mark>父进程等待子进程退出（wait）</mark></strong></li></ol></blockquote><p><strong><font color=red>实现代码：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEN</span> <span class="token expression"><span class="token number">1024</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM</span> <span class="token expression"><span class="token number">32</span></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">char</span> cmd<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">char</span><span class="token operator">*</span> myarg<span class="token punctuation">[</span>NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[牟建波@my-centos_mc dir]$ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">fgets</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> LEN<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 我们创建出来的子进程要执行命令(命令再cmd中)</span>     <span class="token comment">// 要执行命令就要将一个个命令拆开才可以调用</span>     <span class="token comment">// 所以要解析字符串</span>     <span class="token comment">//</span>     <span class="token comment">// 将最后一个命令的\n去掉(换成\0就行了) </span>     cmd<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>     myarg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>myarg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>                <span class="token class-name">pid_t</span> id <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">&lt;</span>mark<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//child</span>     <span class="token punctuation">&#123;</span>        <span class="token function">execvp</span><span class="token punctuation">(</span>myarg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> myarg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//随便写的</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token class-name">pid_t</span> ret <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exit code: %d\n"</span><span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127152123545.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-jin-cheng-kong-zhi/image-20221127152123545.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127152123545"><blockquote><p><strong><mark>对于实现shell后的一些结论：</mark></strong></p><ol><li><strong><font color=red>我们说shell就是一个进程，现在就可以理解了，当我们 .&#x2F;test 的时候 test 变成进程了，一直在运行，所以shell是在系统启动的时候就由某些任务将其进行启动</font></strong></li><li><strong><font color=red>系统启动以及用户登录的时候，某些登陆软件会自动调用bash程序，将其运行起来变成进程</font></strong></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux进程控制&quot;&gt;&lt;a href=&quot;#Linux进程控制&quot; class=&quot;headerlink&quot; title=&quot;Linux进程控制&quot;&gt;&lt;/a&gt;Linux进程控制&lt;/h1&gt;&lt;h2 id=&quot;Linux进程创建&quot;&gt;&lt;a href=&quot;#Linux进程创建&quot; class</summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux的进程互调技术(多语言互调)</title>
    <link href="https://not-go.github.io/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/"/>
    <id>https://not-go.github.io/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/</id>
    <published>2023-02-20T04:12:00.000Z</published>
    <updated>2023-06-23T17:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的进程互调技术-多语言互调"><a href="#Linux的进程互调技术-多语言互调" class="headerlink" title="Linux的进程互调技术(多语言互调)"></a>Linux的进程互调技术(多语言互调)</h1><h2 id="函数与进程之间的相似性"><a href="#函数与进程之间的相似性" class="headerlink" title="函数与进程之间的相似性"></a>函数与进程之间的相似性</h2><blockquote><p><strong><font color=red>如果你学过C语言，你应该有以下认识：</font></strong></p><ul><li><strong>&#x3D;&#x3D;一个C程序由很多函数组成，一个函数可以调用另一个函数，同时传递给它一些参数&#x3D;&#x3D;</strong></li><li><strong>&#x3D;&#x3D;被调用的函数执行一定的操作，然后返回一个值&#x3D;&#x3D;</strong></li><li><strong>&#x3D;&#x3D;每个函数都有它自己的局部变量&#x3D;&#x3D;</strong></li><li><strong>&#x3D;&#x3D;不同函数通过call&#x2F;return系统进行通信&#x3D;&#x3D;</strong></li></ul></blockquote><p><strong><code>这种通过参数和返回值，在拥有私有数据的函数间通信的模式是结构化程序设计的基础，Linux鼓励将这种应用于程序之内的模式扩展到程序之间,如下图：</code></strong></p><img src="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127154354018.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127154354018.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127154354018"><hr><h2 id="多语言程序互调技术"><a href="#多语言程序互调技术" class="headerlink" title="多语言程序互调技术"></a>多语言程序互调技术</h2><p><strong><font color=red>程序之间相互调用的好处：我们都知道各个语言有自己独特的优势，当我们做某一技术开发时，可能需要用到多种语言，而我们最终就是利用程序之间的相互调用使得各个语言之间可以进行衔接</font></strong></p><p><strong>&#x3D;&#x3D;例如，一个C程序可以通过exec系列函数调用shell脚本、python以及C++等语言实现的程序&#x3D;&#x3D;</strong></p><blockquote><ol><li><p><strong><code>Shell脚本</code></strong></p><img src="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127154956841.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127154956841.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127154956841"></li><li><p><strong><code>Python代码：</code></strong></p><img src="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127155011880.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127155011880.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127155011880"></li><li><p><strong><code>C++代码：</code></strong></p><img src="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127155035042.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127155035042.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127155035042"></li></ol></blockquote><p><strong><font color=red>多种语言程序互调测试：</font></strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> id<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//child</span>        <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"./test.sh"</span><span class="token punctuation">,</span><span class="token string">"test.sh"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用Shell脚本</span>        <span class="token comment">//execl("./test.py","test.py",NULL); //调用Python脚本</span>        <span class="token comment">//execl("./test","test",NULL); //调用Python脚本</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> ret<span class="token operator">=</span><span class="token function">waitpid</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exit code:%d\n"</span><span class="token punctuation">,</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong><font color=red>Shell脚本调用结果：</font></strong></p><p><strong>&#x3D;&#x3D;补充：shell脚本通过<code>sh 脚本名</code>调用&#x3D;&#x3D;</strong></p><img src="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127160750127.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127160750127.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127160750127"><p><strong><font color=red>Python代码调用结果：</font></strong></p><img src="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127160815555.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127160815555.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127160815555"><p><strong><font color=red>C++代码调用结果：</font></strong></p><img src="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127160904754.png" class="lazyload placeholder" data-srcset="/2023/02/20/1.linux-de-jin-cheng-hu-diao-ji-zhu/image-20221127160904754.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" class=" lazyload placeholder" title="image-20221127160904754"></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux的进程互调技术-多语言互调&quot;&gt;&lt;a href=&quot;#Linux的进程互调技术-多语言互调&quot; class=&quot;headerlink&quot; title=&quot;Linux的进程互调技术(多语言互调)&quot;&gt;&lt;/a&gt;Linux的进程互调技术(多语言互调)&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/categories/Linux%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux编程" scheme="https://not-go.github.io/tags/Linux%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
